' Moteur/SHELL CpcdosC+ - Interpreteur commandes

' Par Sebastien FAVIER
' Reecriture le 16/01/2017
' Mise a jour le 27/06/2020

' 27-01-2020	: Modification du texte de GUI/
'					Ajout de la commande ACUTALISER/
' 16-10-2018	: Adaptation 2.1 beta 1.1
' 17-01-2018	: CORRECTION de la commande Fermer/ (Close/ en angais)
'					La fermeture par le Handle, et Thread ID ne fonctionnait pas
'					+ Ajout du parametre SYS/ /BITMAP , /LISTE , /TAILLE , /RECHARGER
' 17-12-2017	: AJOUT du CheckBox/ et de l'effet de survole
'					+ AJOUT de l'effet de survole du bouton
' 16-12-2017	: AJOUT de l'argument DIR/ /B pour afficher les informations breves des repertoires
' 14-12-2017	: AJOUT des parametres SYS/ /OS:NomDeOS pour switcher sur un autre OS
'						Demarrer/ NomDeOS pour demarrer un OS
'						IUG/ /OS:NomDeOS Pour afficher le graphique d'un OS
' 11-12-2017	: CORRECTION des arguments de fonctions qui �taient ressortait toujours en majuscule.
' 06-12-2017	: CORRECTION IMPORTANTE de bugs d'allocation memoire a chaud
'					Ajout des scopes pour separer les bloc de memoires prives
' 22-11-2017	: AJOUT de BarreProgression/ (ProgressBar/ en anglais) et de la propriete .VALEUR (.VALUE en anglais)
' 21-11-2017 	: AJOUT de la commande REP/ (DIR/ en anglais) pour lister le contenu des repertoires avec les filtres '.\*'
' 19-11-2017	: MODIFICATION/OPTIMISATION de la leture des commentaires completement jumpe
'					+ CORRECTION de la lecture des fonctions en commentaires
' 14-11-2017	: CORRECTION de la commande anglaise "TextBlock/" qui n'�tait pas reconnue par le SHELL
'					Modification des varariables des executables "_EXE_**"
' 11-11-2017	: AJOUT (fin) des commandes SUPPRIMER/ RENOMMER/ DOSSIER/ COPIER/
' 07-11-2017	: CORRECTION d'un bug interne lors d'utilisation de variables apr�s l'utilisation d'une commande graphique
'					qui rempla�ait le num�ro de TID par celui de l'objet graphique en cours d'op�ration.
' 19-10-2017	: AJOUT de la possibilite de recuperer le contenu des proprietes graphiques via @#
'					+ Correction le 31-10-2017 en ajoutant le nom de variable apres le '#' et lancer un FIX/
' 19-09-2017	: AJOUT du parametre SYS/ /PROCESSUS pour creer un nouveau processus et donc nouveau PID
' 17-09-2017	: AJOUT des fonctions de fermeture des objets par HANDLE et NOM processus
' 15-09-2017	: AJOUT de la notion du 'handle' pour unifier toutes instance graphiques
' 17-08-2017	: AJOUT des commandes de gestion des ports COM
' 14-08-2017	: AJOUT de la precision evenementielle (Preciser le ou les nom d'evenements)
'					Afin d'optimiser la recherche de fonctions.
' 18-07-2017	: AJOUT de SYS/ /OS avec
'					+ /update pour mettre a jour la liste des OS
'					+ /Liste pour afficher la liste des OS
'					+ /nb pour afficher le nombre d'OS
' 06-07-2017	: CORRECTION d'un probleme de fonctions introuvables declares lies a la case. Elle n'est plus sensible!
' 21-06-2017	: AJOUT du support de la modification des proprietes graphiques pour la fenetre.
' 30-05-2017	: AJOUT de la propriete PARAMETRES pour les fenetres.
'					+ Renommage de la propriete TYPE en PARAMETRES (+picturebox)
' 29-05-2017	: AJOUT des proprietes ICONE et environnement graphique personnalisables depuis EV_GUI.CPC
' 26-05-2017	: AJOUT du support evenementielle du CLIC sur picturebox
' 11-05-2017	: CORRECTIONS Sleeps + "SYS/ /DEBUG"
' 09-05-2017	: CORRECTION de la confusion du thread SERVEUR et CLIENT qui affiche "cr�e" alors que non
' 08-05-2017	: CORRECTION des problemes lie aux niveau de publicites
' 19-04-2017	: Correction du changement de resolution si /MENU = 1
'					+ Le 'recherche en mode standard' encombrant pour le debugage
' 18-04-2017	: Ajout de \#NON-FN et \#NO-FN pour ne pas executer les fonctions /F:
'					+ Correction de l'�cran noir apr�s un stopK/
' 14-04-2017	: Correction de \#PAUSE
' 11-04-2017	: Serveur/ Renvoie '1' s'il a bien ete cree.
' 07-04-2017	: Ajout de la section critique CpcdosC+.
'				: SI/ ajout de '=='
' 23-03-2017	: Jout de la gestion des tableaux
'					+ Creation de tableaux automatiques
' 22-03-2017	: Ajout de FIX/ /TOUCHE /ATOUCHE /KEY /AKEY
' 20-03-2017	: Correction bugs appel de fonctions -> Crash 
'					+ Correction bug niveau privacite dans les fonctions
'					+ "double lecture" des lignes vides
'					+ ---> MEGA Optimisation
'					+ Correction Operande vide SI/ "" = ... toujours vraie
'					+ Bug SI/ N= ou !=
' 08-03-2017	: Correction bugs de PID & Cle + Retour valeur @# DANS les fonctions + SI/ != string
' 04-02-2017	: SERVEUR/ & CLIENT/ Ajout de l'attente ou attente en millisecondes d'une reception requete avec /ATTENDRE ou /WAIT
' 02-03-2017	: Ajout de FIX/ /Q
' 01-03-2017	: Ajout de \#PAUSE pour mettre en pause les defilement
' 24-02-2017	: Amelioration des erreurs serveur/ client/
' 23-02-2017	: Correction de la commande "Client/ /envoyer:n Serveur/ /stop:n" qui fonctionnait pas
' 22-02-2017 	: Correction & readaptation de la commande COULEURC/, ECRIRE/ et FONCTION/
' 16-02-2017	: FIX/ on peut mettre autant d'espaces avant "=" et meme sans avant et apres 
' 14-02-2017	: Finalisation des commandes SERVEUR/ et CLIENT/


#include "cpcdos.bi"


#define _scope do
#define _end_scope loop while 0

#define _scope_CMD _scope
#define _end_scope_CMD _end_scope

#define _scope_SAUT_COMMANDE _scope
#define _end_scope_SAUT_COMMANDE _end_scope

#print
#print ============ Shell Cpcdos CpcdosC+ ==============

#print * Init CMD_CpcdosCP
Sub _SHELL_Cpcdos_OSx__._INIT_CpcdosCP_CMD()
		DEBUG("[SHELL] Shell intialization...",  CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
	this.Liste_CMD_EN(1) = "REM/"
	this.Liste_CMD_EN(2) = "HELP/"
	this.Liste_CMD_EN(3) = "CLS/"
	this.Liste_CMD_EN(4) = "TXT/"
	this.Liste_CMD_EN(5) = "SET/"
	this.Liste_CMD_EN(6) = "GOTO/"
	this.Liste_CMD_EN(7) = "CCP/"
	this.Liste_CMD_EN(8) = "EXE/"
	this.Liste_CMD_EN(9) = "SYS/"
	this.Liste_CMD_EN(10) = "CLOSE/"
	this.Liste_CMD_EN(11) = "COLORF/"
	this.Liste_CMD_EN(12) = "STOPK/"
	this.Liste_CMD_EN(13) = "SERVER/"
	this.Liste_CMD_EN(14) = "PING/"
	this.Liste_CMD_EN(15) = "DOWNLOAD/"
	this.Liste_CMD_EN(16) = "DOS/"
	this.Liste_CMD_EN(17) = "CMD/"
	this.Liste_CMD_EN(18) = "LOGIN/"
	this.Liste_CMD_EN(19) = "OPEN/"
	this.Liste_CMD_EN(20) = "TEXTBLOCK/" ' correction 14/07/2017 avec le 'LOC/'
	this.Liste_CMD_EN(21) = "IF/"
	this.Liste_CMD_EN(22) = "END/"
	this.Liste_CMD_EN(23) = "FUNCTION/"
	this.Liste_CMD_EN(24) = "WRITE/"
	this.Liste_CMD_EN(25) = "DECLARE/"
	this.Liste_CMD_EN(26) = "GUI/"
	this.Liste_CMD_EN(27) = "STOP/"
	this.Liste_CMD_EN(28) = "RETURN/"
	this.Liste_CMD_EN(29) = "WINDOW/"
	this.Liste_CMD_EN(30) = "CREATE/"
	this.Liste_CMD_EN(31) = "PICTUREBOX/"
	this.Liste_CMD_EN(32) = "CLIENT/"
	this.Liste_CMD_EN(33) = "COLORB/"
	this.Liste_CMD_EN(34) = "BUTTON/"
	this.Liste_CMD_EN(35) = "LOC/"
	this.Liste_CMD_EN(36) = "START/"
	this.Liste_CMD_EN(37) = "DELETE/"
	this.Liste_CMD_EN(38) = "COPY/"
	this.Liste_CMD_EN(39) = "MOVE/"
	this.Liste_CMD_EN(40) = "RENAME/"
	this.Liste_CMD_EN(41) = "TEXTBOX/"
	this.Liste_CMD_EN(42) = "FOLDER/"
	this.Liste_CMD_EN(43) = "DIR/"
	this.Liste_CMD_EN(44) = "PROGRESSBAR/"
	this.Liste_CMD_EN(45) = "MSGBOX/"
	this.Liste_CMD_EN(46) = "CHECKBOX/"
	this.Liste_CMD_EN(47) = "REFRESH/"
	this.Liste_CMD_EN(48) = "DECOMPRESS/"
	this.Liste_CMD_EN(49) = "COMPRESS/"
	this.Liste_CMD_EN(50) = "EXPLORER/"
	this.Liste_CMD_EN(51) = "LISTBOX/"
	' this.Liste_CMD_EN(52) = "set/"
	' this.Liste_CMD_EN(53) = "set/"
	' this.Liste_CMD_EN(54) = "set/"

	' Proprietes de la GUI toujours a partir de 128. Ce qui laisse 127 Commande cpcdosc+
	this.Liste_CMD_EN(128) = ".TITLECOLOR"
	this.Liste_CMD_EN(129) = ".NAME"
	this.Liste_CMD_EN(130) = ".PID"
	this.Liste_CMD_EN(131) = ".PARAMETERS"
	this.Liste_CMD_EN(132) = ".PX"
	this.Liste_CMD_EN(133) = ".PY"
	this.Liste_CMD_EN(134) = ".SX"
	this.Liste_CMD_EN(135) = ".SY"
	this.Liste_CMD_EN(136) = ".WINDOWCOLOR"
	this.Liste_CMD_EN(137) = ".TITLE"
	this.Liste_CMD_EN(138) = ".BACKCOLOR"
	this.Liste_CMD_EN(139) = ".ICON"
	this.Liste_CMD_EN(140) = ".TITLEIMG"
	this.Liste_CMD_EN(141) = ".IMAGE"
	this.Liste_CMD_EN(142) = ".OPACITY"
	this.Liste_CMD_EN(143) = ".TEXTCOLOR"
	this.Liste_CMD_EN(144) = ".EVENT"
	this.Liste_CMD_EN(145) = ".TEXT"
	this.Liste_CMD_EN(146) = ".HANDLE"
	this.Liste_CMD_EN(147) = ".VALUE"
	' this.Liste_CMD_EN(148) = ".BACKCOLOR"
	' this.Liste_CMD_EN(149) = ".BACKCOLOR"
	' this.Liste_CMD_EN(150) = ".BACKCOLOR"


	' For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(index)	= String(64, 0) ' Procedure
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(index)	= String(64, 0) ' application
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(index)	= String(64, 0) ' Utilisateur
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(index)	= String(64, 0) ' OS
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(index)	= String(64, 0) ' Kernel
	' Next index
	
	' For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_Donnees(index)	= String(256, 0) ' Procedure
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_Donnees(index)	= String(256, 0) ' application
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_Donnees(index)	= String(256, 0) ' Utilisateur
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_Donnees(index)	= String(256, 0) ' OS
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_Donnees(index)	= String(256, 0) ' Kernel
	' Next index
	
	' For index as uinteger = 0 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(index) = 280395
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(index) = 280395
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(index) = String(256, 0)
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(index) = String(256, 0)
	' Next index
	
	' RAZ
	
	For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(index)	= "" ' Procedure
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(index)	= ""  ' application
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(index)	= ""  ' Utilisateur
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(index)	= ""  ' OS
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(index)	= ""  ' Kernel
	Next index
	
	For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_Donnees(index)	= ""  ' Procedure
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_Donnees(index)	= ""  ' application
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_Donnees(index)	= ""  ' Utilisateur
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_Donnees(index)	= ""  ' OS
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_Donnees(index)	= ""  ' Kernel
	Next index
	
	For index as uinteger = 0 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(index) = 0
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(index) = 0
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_CLE(index) = 0
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(index) = "" 
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(index) = "" 
	Next index
	
	DEBUG("[OK]",  CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
End sub

#print * SHELL CpcdosC+
Function _SHELL_Cpcdos_OSx__.CpcdosCP_SHELL(ByVal _COMMANDE_ as String, byval _CLE_ as double, byval NIVEAU_CCP as integer, byval Param_1 as Integer, byval Param_2 as String) as String
	' Cette fonction permet d'interpreter une commande de syntaxe CpcdosC+ aux fonctionnalites du noyau
	' 	_COMMANDE_	: Commande CpcdosC+
	'	_PID_		: Numero PID du processus
	'	_TID_		: Numero TID du thread associe au processus
	'	Param_1		: ?
	'	Param_2		: ?

	On local Error Goto Intercept_Error
	
	' Retourne des donnees
	Dim testCMD					as integer
	Dim CommTrouve				as Integer
	Dim VerifierLabel			as Integer = 0
	Dim Numero_de_Ligne 		as Integer = 0
	Dim Nom_Fichier_DBG 		as String = ""
	Dim CommandesAide			as String
	Dim Message_erreur			as String
	Dim RetourVAR				as string
	Dim Commande				as String = _COMMANDE_
	
	
	' Recuperer les identifiants uniques
	Dim Auth_Kernel				as uinteger = CPCDOS_INSTANCE.get_id_kernel		(_CLE_)
	Dim Auth_OS					as uinteger = CPCDOS_INSTANCE.get_id_OS			(_CLE_)
	Dim Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_)
	Dim Auth_PID				as uinteger = CPCDOS_INSTANCE.get_id_PID		(_CLE_)
	Dim Auth_TID				as uinteger = CPCDOS_INSTANCE.get_id_TID		(_CLE_)
	
	' Supprimer toutes les espaces et/ou tabulations sur la gauche
	_COMMANDE_ = LTRIM(LTRIM(_COMMANDE_), CHR(09))
	
	' OPTIMISATION : La syntaxe CpcdosC+ n'a aucune commande faisant moins de 3 caracteres
	If LEN(_COMMANDE_) < 3 Then exit function

	' OPTIMISATION : Si la commande est "REM/" on quitte la fonction
	Scope
		Dim Test_REM as Integer = Instr(Ucase(_COMMANDE_), "REM/")
		Dim Test_CMD as Integer = 0
		
		' Si elle est presente, on verifie sa syntaxe
		If Test_REM > 0 Then
			IF NOT CCP_Verifier_Syntaxe(_COMMANDE_, Test_REM) > 10 Then Exit Function
		End if
		
		' Si la ligne commence par // ou par ' alors c'est un commentaire
		IF INSTR(_COMMANDE_, "// ") = 1 OR INSTR(_COMMANDE_, "//" & CHR(09)) = 1 OR INSTR(_COMMANDE_, "///") = 1 OR INSTR(_COMMANDE_, "' ") = 1 OR INSTR(_COMMANDE_, "''") = 1 Then Exit Function
	End Scope

	Commande = _COMMANDE_


	_scope
		
		Dim Slash_FN_Presend 		as boolean = FALSE
		Dim SAME_ID					as boolean = false
		Dim Non_Remplace 			as integer = 0
		Dim Non_Fonction 			as integer = 0
		Dim Position_CMD 			as integer = 0
		
		
		Dim CommPosition			as integer
		Dim TailleComm				as Integer
		Dim AfficherAide 			as Integer = 0 ' 1:Lister 2:Contenu
		Dim Affichage 				as Integer = CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran
		Dim Niveau_2				as Integer = 2
		Dim NoCMD					as Integer
		Dim Mess_Aide 				as String
		Dim tst_Cap					as String
		Dim CMD_tst					as String
		Dim OnCherche				as String
		Dim EXEC_FONCTION_FICHIER 	as String
		Dim CommLANG(0 to 3) 		as String ' 1:Francais 2:Anglais 3:ByteCode 4:?
		
		Dim Param					as String	
		
		if Param_1 >= 330 Then
			RetourVAR = Param_2
		Else
			RetourVAR = ""
		end if

	
		DEBUG("[SHELL CC+] > " & Commande, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
		
		IF INSTR(Commande, "﻿") > 0 Then ' UTF-8
			Message_erreur = ERRAVT("AVT_079", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & ". Error can be requested.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")

			
			testCMD = 1
			CommTrouve = 1
			exit _scope
		ElseIF INSTR(Commande, "��") > 0 Then ' UTF 16 Big Endian
			Message_erreur = ERRAVT("AVT_079", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & ". Error can be requested.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			
			
			testCMD = 1
			CommTrouve = 1
			exit _scope
		ElseIF INSTR(Commande, "��") > 0 Then ' UTF 16 Little Endian
			Message_erreur = ERRAVT("AVT_079", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & ". Error can be requested.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			
			
			testCMD = 1
			CommTrouve = 1
			exit _scope
		End if

	
		' Si le parametre \#Non-var est present alors on ne remplace pas la variable
		IF Instr(ucase(Commande), "\#NO") > 0 then
			IF Instr(ucase(Commande), "\#NON-VAR") > 0 then
				Non_Remplace = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NON-VAR")-1)
			elseIF Instr(ucase(Commande), "\#NO-VAR") > 0 then
				Non_Remplace = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NO-VAR")-1)
			elseIF Instr(ucase(Commande), "\#NO-FN") > 0 then
				Non_Fonction = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NO-FN")-1)
			elseIF Instr(ucase(Commande), "\#NON-FN") > 0 then
				Non_Fonction = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NON-FN")-1)
			end if
		else
			Non_Remplace = 0
			Non_Fonction = 0
		end if
		
		' Verifier que le parametre PAUSE est present
		IF Instr(ucase(Commande), "\#PAUSE") > 0 then
			' Verifier qu'il n'y a pas autre chose
			IF RetourVAR = "" Then
				RetourVAR = "#PAUSE"
			End if
			
			Commande = MID(Commande, 1, Instr(ucase(Commande), "\#PAUSE")-1)
		end if
		
		' Conserver l'identifiant
		IF Instr(UCASE(Commande), "\#SAMEID") > 0 Then
			' Enlever l'argument a la fin
			Commande = Mid(Commande, 1, Instr(UCASE(Commande), "\#SAMEID") - 1)
			
			' Et signaler l'activation de SAME_ID
			SAME_ID = true
		End if
		
		' Contexte clic droit
		if Instr(Ucase(Commande), "#CTX_TEXTBOX") > 0 Then

			' Copier le contenu d'un textebox
			IF Instr(Ucase(Commande), "#CTX_TEXTBOX_COPY ") > 0 Then
				Dim NomTextebox as String = Mid(Commande, Instr(Ucase(Commande), "#CTX_TEXTBOX_COPY ") + Len("#CTX_TEXTBOX_COPY "))
				
				for INDEX_Textbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom) = NomTextebox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							
							DEBUG("[CPCDOS] CTX TEXT COPY : '" & CPCDOS_INSTANCE.__PRESSE_PAPIER_TEXTE__ & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")

							' EFFECTUER UNE COPIE
							CPCDOS_INSTANCE.__PRESSE_PAPIER_TEXTE__ = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte

							
						
							exit for
						end if
					End if
				Next INDEX_Textbox

				
			End if

			' Couper le contenu d'un textebox
			IF Instr(Ucase(Commande), "#CTX_TEXTBOX_CUT ") > 0 Then
				Dim NomTextebox as String = Mid(Commande, Instr(Ucase(Commande), "#CTX_TEXTBOX_CUT ") + Len("#CTX_TEXTBOX_CUT "))
				
				for INDEX_Textbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom) = NomTextebox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							
							DEBUG("[CPCDOS] CTX TEXT CUT : '" & CPCDOS_INSTANCE.__PRESSE_PAPIER_TEXTE__ & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")

							' EFFECTUER UNE COPIE
							CPCDOS_INSTANCE.__PRESSE_PAPIER_TEXTE__ = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte

							' Clean text
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte = ""

							' Actualiser l'affichage du textebox
							CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBox(INDEX_Textbox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).identification_objet.Index_FNT_PARENT)

							
						
							exit for
						end if
					End if
				Next INDEX_Textbox

			End if

			' Coller le contenu d'un textebox
			IF Instr(Ucase(Commande), "#CTX_TEXTBOX_PAST ") > 0 Then
				Dim NomTextebox as String = Mid(Commande, Instr(Ucase(Commande), "#CTX_TEXTBOX_PAST ") + Len("#CTX_TEXTBOX_PAST "))
				
				for INDEX_Textbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom) = NomTextebox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							
							DEBUG("[CPCDOS] CTX TEXT PAST : '" & CPCDOS_INSTANCE.__PRESSE_PAPIER_TEXTE__ & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")							
							
							' EFFECTUER UN COLLER
							Dim position_curseur as integer = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).PROP_TYPE.UserEdit_Pos

							' Placer le texte o� est positionn� le curseur
							Dim Traitement as string = mid(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte, 1, position_curseur) & CPCDOS_INSTANCE.__PRESSE_PAPIER_TEXTE__
							
							' Positionner apres le texte coll�
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).PROP_TYPE.UserEdit_Pos = len(Traitement)

							' Completer la fin du texte
							Traitement +=  mid(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte, position_curseur)

							'Mettre a jour
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte = Traitement

							' Actualiser l'affichage du textebox
							CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBox(INDEX_Textbox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).identification_objet.Index_FNT_PARENT)

						
							exit for
						end if
					End if
				Next INDEX_Textbox
			End if

			' Supprimer le contenu d'un textebox
			IF Instr(Ucase(Commande), "#CTX_TEXTBOX_DEL ") > 0 Then
				Dim NomTextebox as String = Mid(Commande, Instr(Ucase(Commande), "#CTX_TEXTBOX_DEL ") + Len("#CTX_TEXTBOX_DEL "))
				
				for INDEX_Textbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom) = NomTextebox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							
							DEBUG("[CPCDOS] CTX TEXT DELETED", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")

							' EFFACER
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte = ""

							' Actualiser l'affichage du textebox
							CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBox(INDEX_Textbox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).identification_objet.Index_FNT_PARENT)

							
						
							exit for
						end if
					End if
				Next INDEX_Textbox
			End if
			
			Exit function
		End if

		' Executer une fonction d'un fichier (DIRECT)
		IF Instr(UCASE(Commande), "##FONCTION=:") > 0 Then
			IF Instr(UCASE(Commande), ":=##") > 10 Then
				Dim Position1 as integer = Instr(UCASE(Commande), "##FONCTION=:") + 12
				Dim Position2 as integer = Instr(UCASE(Commande), ":=##")
				EXEC_FONCTION_FICHIER = MID(Commande, Position1, (Position2) - Position1)

				' Execution des actions des menu contextuels
				if instr(ucase(EXEC_FONCTION_FICHIER), "#CTX_ACTION:") > 0 Then
					Dim commande_action_index as integer = Val(Ltrim(Rtrim(Mid(ucase(EXEC_FONCTION_FICHIER), instr(ucase(EXEC_FONCTION_FICHIER), "#CTX_ACTION:") + 12))))

					Commande = CPCDOS_INSTANCE.SCI_INSTANCE.ContextMenu_INSTANCE.item_list(commande_action_index).action
					DEBUG("[CpcdosC+] Executing context menu action (" & commande_action_index & ") --> " & Commande, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
					EXEC_FONCTION_FICHIER = ""

					' Fermer le menu contextuel si deja ouvert
					CPCDOS_INSTANCE.SCI_INSTANCE.fermer_ContextMenu()
					
					' Executer cmd du clic droit
					return CpcdosCP_SHELL(Commande, _CLE_, NIVEAU_CCP, Param_1, Param_2) 
				End if
				Commande = Ltrim(Ltrim(MID(Commande, Position2 + 4), chr(09)))
			End if
		End if
		
		
		IF Non_Fonction = 0 Then
			dim NePasExec as boolean = false
			
			' Si c'est une commande qui veut JUSTEMENT creer un thread pour la fonction
			if Instr(UCASE(Commande), "CMD/") > 0 Then
				IF Instr(UCASE(Commande), "/CMD") > 0 OR Instr(UCASE(Commande), "/THREAD") > 0Then
					NePasExec = true
				end if
			end if
			
			if NePasExec = false Then
				' Demande d'execution d'une fonction d'un fichier CpcdosC+
				IF Instr(UCASE(Commande), "/F:") > 0 AND Instr(UCASE(Commande), "(") > Instr(UCASE(Commande), "/F:") AND Instr(UCASE(Commande), ")") > Instr(UCASE(Commande), "(") Then 
					Commande = CCP_Function(Commande, EXEC_FONCTION_FICHIER, _CLE_, NIVEAU_CCP, Param_1, Param_2)
					if mid(Commande, 1, 4) = "ERR_" Then
						return Commande
					end if
				END IF
			End if
		End if
		
		' 
		IF Instr(UCASE(Commande), "/FN:") > 0 AND Instr(UCASE(Commande), "(") > Instr(UCASE(Commande), "/F:") AND Instr(UCASE(Commande), ")") > Instr(UCASE(Commande), "(") Then 
			Non_Remplace = 1
			' Slash_FN_Presend = TRUE
		END IF
		
		' Verifier a nouveau que la commande fait au moins 3 caracteres
		IF LEN(Commande) < 3 Then 
			' DEBUG("[SHELL CC+] > Erreur de syntaxe ''" & Commande & "''.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			CpcdosCP_SHELL = ""
			Exit function
		End if
		
		' Si il y a 2 '%' alors on va verifier si c'est une variable. Si oui on le remplace (OPTIMISATION)
		If InstrREV(Commande, "%") > Instr(Commande, "%") THEN
			' Remplacer toutes les variables par leur contenu
			IF Non_Remplace = 0 then Commande = CCP_Rempl_VAR(Commande, NIVEAU_CCP, Auth_Kernel, Auth_OS , Auth_Utilisateur, Auth_PID, Auth_TID, RetourVAR)
			if Commande = CPCDOS_INSTANCE._CONTENU_IMPROPABLE then exit _scope ' Variable introuvable
		end if
		
		' Si on execute une fonction on cree une nouvelle CLE ID APRES avoir charger
		'  le contenu des %variables% en arguments
		' IF NOT EXEC_FONCTION_FICHIER = "" THEN
			' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					' DEBUG("[CpcdosC+] Redefinition de la cle d'identification de fonction", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				' Else
					' DEBUG("[CpcdosC+] Redefinition key ID for function", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				' End If
			' End if
			
			' ' Redefinition des cle d'identifications
			' Auth_TID = int(Auth_TID + CPCDOS_INSTANCE.Generer_RND(1, 99))
			' _CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
			
			' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				' DEBUG("[OK] --> CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & " (TID:" & Auth_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
			' End if	
		' END IF
		
		' Calculer
		IF Instr(UCASE(Commande), "/C(") > 0 Then Commande = CCP_Calcul(Commande)
		
		' Verifer si c'est pas un label
		If InstrREV(Commande, ":") > Instr(Commande, ":") Then VerifierLabel = 1
		IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				DEBUG("[CpcdosC+] Ready to executing : " & Commande & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Commande) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
			
		End if

		' Verifier a nouveau que la commande fait au moins 3 caracteres
		IF LEN(Commande) < 3 Then 
			' DEBUG("[SHELL CC+] > Erreur de syntaxe ''" & Commande & "''.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			CpcdosCP_SHELL = ""
			Exit function
		End if

		' Ceci ameliore l'aspect du CpcdosC+ en terme de recherche des bonnes commandes
		CMD_tst = UCASE(Commande)
		OnCherche = ""
		
		' A partir d'ici, nous n'avions plus d'espaces au debut
		'  On cherche donc le prochain espace et on a la CMD!
		Position_CMD = 0

		Dim Arrob as boolean = false
		
		' Capturer la cmd au la prochaine espace apres '/'
		tst_Cap = MID(CMD_tst, 1, Instr(CMD_tst, CHR(32)) - 1)
		IF NOT tst_Cap = "" then
			IF MID(tst_Cap, 1, 1) = CHR(64) Then ' Caractere '@'
				Position_CMD = Instr(CMD_tst, CHR(32))
				Arrob = true

				' Chercher le prochain espace apres l'espace precedent
				tst_Cap = MID(CMD_tst, 1, Instr(Position_CMD + 1, CMD_tst, CHR(32)) - 1)
			End if
		Else
			tst_Cap = CMD_tst
		END IF
		
		for Boucle as integer = 1 to this._MAX_CMD_CCP
			if boucle > this._MAX_CMD_CCP then exit for
		
			' DEV temporaire: Si commande vide alors on saute
			'  directement aux commandes graphiques
			IF this.Liste_CMD_EN(boucle) = "" AND boucle < 128 Then boucle = 128

			' Chercher la syntaxe Anglophone
			IF Instr(tst_Cap, this.Liste_CMD_EN(Boucle)) > 0 Then
				if Mid(this.Liste_CMD_EN(Boucle), 1, 1) = "." Then 
					dim cap_tmp as string = Ltrim(Ltrim(Rtrim(Rtrim(Rtrim(Rtrim(tst_Cap ), chr(10)), chr(13)), chr(09))), CHR(09))

					if NOT Instr(cap_tmp, ".") > 0 Then
						if Arrob = false Then
							if Instr(cap_tmp, "./") > 0 OR Instr(cap_tmp, ".\") > 0 Then exit for ' il s'agit purement d'un path
							if Instr(cap_tmp, "/.") > 0 OR Instr(cap_tmp, "\.") > 0 Then exit for ' il s'agit purement d'un path
							if Instr(cap_tmp, " = ") > 0 Then
								if Instr(cap_tmp, ".") > Instr(cap_tmp, " = ") Then
									exit for
								End if
							End if
						End if
					End if
				End if

				TailleComm = LEN(this.Liste_CMD_EN(Boucle))
				CommPosition = Position_CMD
				OnCherche = Lcase(this.Liste_CMD_EN(Boucle))
				Exit for
			End if
			
			' Chercher la syntaxe Francophone
			IF Instr(tst_Cap, this.Liste_CMD_EN(Boucle)) > 0 Then
				if Mid(this.Liste_CMD_EN(Boucle), 1, 1) = "." Then 
					dim cap_tmp as string = Rtrim(Ltrim(tst_Cap, chr(10)), chr(13))

					if Instr(cap_tmp, ".") > 0 Then
						if Arrob = false Then
							if Instr(cap_tmp, "./") > 0 OR Instr(cap_tmp, ".\") > 0 Then exit for ' il s'agit purement d'un path
							if Instr(cap_tmp, "/.") > 0 OR Instr(cap_tmp, "\.") > 0 Then exit for ' il s'agit purement d'un path
							if Instr(cap_tmp, " = ") > 0 Then
								if Instr(cap_tmp, ".") > Instr(cap_tmp, " = ") Then
									exit for
								End if
							End if
						End if
					End if
				End if

				' Debug("/!\ French syntax is deprecated and will be removed in future major release ! You should use " & this.Liste_CMD_EN(Boucle) & " instead", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				TailleComm = LEN(this.Liste_CMD_EN(Boucle))
				CommPosition = Position_CMD
				OnCherche = Lcase(this.Liste_CMD_EN(Boucle))
				Exit for
			End if
			
		Next Boucle

		' Rien n'a ete trouve, commande invalide!
		IF OnCherche = "" then exit _scope

			DEBUG("[SHELL CC+] > Executing : " & Commande, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
		
		
		
	_scope_CMD
	
		' ===============================================================
		'  Commande d'aide permettant d'afficher l'aide d'une commande
		' ===============================================================
		CommLang(2) = "help/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			Dim Mess_Debug 	as String
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			' ====================================================================
			
			Mess_Debug	= ""
			IF Param = "" then
				AfficherAide = 1 ' Lister
			else
				IF Param = " " then
					AfficherAide = 1 ' Lister
				ELSE
					AfficherAide = 2 ' Aide de la commande
					Commande = Ltrim(Ltrim(Rtrim(Rtrim(Rtrim(Rtrim(Param), chr(10)), chr(13)), chr(09))), CHR(09))
				END IF
			END IF
				IF AfficherAide = 1 THEN
					Mess_Debug = "** Available commands list **"
				Else
					Mess_Debug = "** Help for " & Commande & " command **"
					OnCherche = Commande
				END IF
			DEBUG(Mess_Debug, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
		
			' ====================================================================

			
		End if ' **** AIDE/ ****
		
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commentaire
		' ===============================================================
		CommLang(2) = "rem/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " rem/                       Write a comment in code"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'REMark'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command hasn't effect, you can put all!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   rem/ We will clean screen"
					Mess_Aide = Mess_Aide & CRLF & "   ' This works also"
					Mess_Aide = Mess_Aide & CRLF & "   // But also this!"
					Mess_Aide = Mess_Aide & CRLF & "   cls/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Screen was cleaned"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			
			exit _scope_CMD, _scope
		End if ' **** REM/ ****
		
	_end_scope_CMD

	
	_scope_CMD
	
		' ===============================================================
		'  Commande d'effacement de l'ecran
		' ===============================================================
		CommLang(2) = "cls/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " cls/                       Clear LC console screen"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'CLear Screen'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to clear LC console screen"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    LC:[FR] Ligne de Commandes [EN] Commands line (no GUI)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This text will be deleted"
					Mess_Aide = Mess_Aide & CRLF & "   cls/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Text has been deleted"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			' ====================================================================
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Cleaning screen", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF
			
			
			DIM Trame_GUI_TXTBOX as String = "#GUI_TXTBOX:" ' Textebox --> Console graphique
			
			' Effacer le textebox si c'est lui qui a fait la demande
			if Instr(Param_2, Trame_GUI_TXTBOX) > 0 Then
				Dim Index_txtbox as integer = Val(Mid(Param_2, Instr(Param_2, Trame_GUI_TXTBOX) + Len(Trame_GUI_TXTBOX)))
				CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Index_txtbox).Texte = ""
			else
				cls 0
			End if
			
			' ====================================================================

			exit _scope_CMD, _scope
		End if ' **** CLS/ ****
		
	_end_scope_CMD
		
	_scope_CMD
	
		' ===============================================================
		'  Commande d'effacement de l'ecran
		' ===============================================================
		CommLang(2) = "delete/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " delete/                    Delete a file"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Delete'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to delete a file from device"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Delete/ MyDirectoy/MyFile.log"
					Mess_Aide = Mess_Aide & CRLF & "   delete/ MyFile.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : copy/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			SCOPE
			' ====================================================================
			
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Deleting file '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF
			
			' INFO DU 29/09 : Faire une suppression avec l'option securise (plus lent)
			' INDEPENDANCE DOS --> Creer la fonction de suppression de fichier depuis CPinti Core
			
			
			Dim Resultat as integer = kill(Param) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS
			
			If Resultat <> 0 Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				Dim Message_erreur as String = ERRAVT("ERR_061", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
					DEBUG("[CpcdosC+] The file '" & Param & "' has been deleted!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** SUPPRIMER/ ****
		
	_end_scope_CMD
	
	_scope_CMD
		
		' ===============================================================
		'  Commande d'effacement de l'ecran
		' ===============================================================
		CommLang(2) = "copy/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " copy/                      Copy a file in a directory"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'copy'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to copy a source file"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Avaiable parameters :"
					Mess_Aide = Mess_Aide & CRLF & "    /Progression:VariableName -> Put actual pourcentage during copy"
					Mess_Aide = Mess_Aide & CRLF & "    /Bytes:VariableName -> Put bytes number during copy"
					Mess_Aide = Mess_Aide & CRLF & "    /BytesBySec:VariableName -> Put number of byte copied by secondes"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Copy/ MyDirectory/MyFile.log MyOtherDirectory/MyFile.log"
					Mess_Aide = Mess_Aide & CRLF & "   Copy/ File.txt, MyDirectory"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  You can get pourcentage during copy from another thread with level 5 variable :"			
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /Progression:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "      --> And during copy, variable %MyVariable% content the % of the copy"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same thing with bytes :"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /Bytes:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Count of byte by seconds :"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /BytesBySec:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Or more parameters in same time!"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /Progression:Var1 /Bytes:Var2 /BytesBySec:Var3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			' ====================================================================
			SCOPE
			
			Dim Resultat 			as boolean
			
			Dim PosOctets 			as integer
			Dim PosBytes 			as integer
			
			Dim PosOctetsParSec		as integer
			Dim PosBytesBySec		as integer
			
			Dim Priorite_copie		as integer = 0
			
			Dim Source 				as String
			Dim Destination 		as String
			
			Dim Var_Progression 	as String
			Dim Var_Octets 			as String
			Dim Var_OctetsParSec 	as String
			
			

			Dim PosProgress as integer = Instr(Ucase(Param), " /PROGRESSION:")
			
			IF NOT INSTR(Param, ",") > 0 Then 
					DEBUG("[CpcdosC+] For this version, you must separate arguments by a comma ','" & CRLF & "Examble: COPY/ FileA, FileB", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				exit _scope_CMD, _scope
			End if
			
			if PosProgress > 0 Then
				IF PosProgress > Instr(Param, ",") Then
					Var_Progression = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosProgress + 14, Instr(PosProgress + 14, Param & " ", " ") - (PosProgress + 14)), CHR(09))), CHR(09)))
					
					Param = Param & " "
					
					' Supprimer le progress
					Param = Mid(Param, 1, PosProgress - 1) & " " & Mid(Param, Instr(PosProgress + 14, Param & " ", " ") + 1)

				Else
						DEBUG("[CpcdosC+] Please put '/PROGRESSION' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					
					exit _scope_CMD, _scope
				End if
			End if
			
			PosOctets = Instr(Ucase(Param), " /OCTETS:")
			PosBytes  = Instr(Ucase(Param), " /BYTES:")

			if PosOctets > 0 OR PosBytes > 0 Then
				IF PosOctets > Instr(Param, ",") Then
					Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctets + 9, Instr(PosOctets + 9, Param & " ", " ") - (PosOctets + 9)), CHR(09))), CHR(09)))
					
					Param = Param & " "
					
					' Supprimer le octets
					Param = Mid(Param, 1, PosOctets - 1) & " " & Mid(Param, Instr(PosOctets + 9, Param & " ", " ") + 1)
					
				ElseIf PosBytes > Instr(Param, ",") Then
					Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytes + 8, Instr(PosBytes + 8, Param & " ", " ") - (PosBytes + 8)), CHR(09))), CHR(09)))
					
					Param = Param & " "
					
					' Supprimer le bytes
					Param = Mid(Param, 1, PosBytes - 1) & " " & Mid(Param, Instr(PosBytes + 8, Param & " ", " ") + 1)
					
				Else
						DEBUG("[CpcdosC+] Please put '/OCTETS' or '/BYTES' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					
					exit _scope_CMD, _scope
				End if
			End if
			
			PosOctetsParSec	= Instr(Ucase(Param), " /OCTETSPARSEC:")
			PosBytesBySec 	= Instr(Ucase(Param), " /BYTESBYSEC:")
			
			if PosOctetsParSec > 0 OR PosBytesBySec > 0 Then
				IF PosOctetsParSec > Instr(Param, ",") Then
					Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctetsParSec + 15, Instr(PosOctetsParSec + 15, Param & " ", " ") - (PosOctetsParSec + 15)), CHR(09))), CHR(09)))
					
					Param = Param & " "

					' Supprimer le OctetsParSec
					Param = Mid(Param, 1, PosOctetsParSec - 1) & " " & Mid(Param, Instr(PosOctetsParSec + 15, Param & " ", " "))
					
				ElseIf PosBytesBySec > Instr(Param, ",") Then
					Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytesBySec + 13, Instr(PosBytesBySec + 13, Param & " ", " ") - (PosBytesBySec + 13)), CHR(09))), CHR(09)))
					
					Param = Param & " "
					
					' Supprimer le bytesBySec
					Param = Mid(Param, 1, PosBytesBySec - 1) & " " & Mid(Param, Instr(PosBytesBySec + 13, Param & " ", " ") + 1)
					
				Else
						DEBUG("[CpcdosC+] Please put '/OctetsParSec' or '/BytesBySec' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					
					exit _scope_CMD, _scope
				End if
			End if
			
			' ==== MAX ===
			IF Instr(Ucase(Param), " /PRIORITE:MAX") > 0 Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:MAX") - 1)
				Priorite_copie = 3
			End if
			
			IF Instr(Ucase(Param), " /PRIORITY:MAX") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:MAX") - 1)
				Priorite_copie = 3
			End if
			
			' ==== STANDARD ===
			IF Instr(Ucase(Param), " /PRIORITY:STD") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:STD") - 1)
				Priorite_copie = 2
			End if
			
			IF Instr(Ucase(Param), " /PRIORITE:STD") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:STD") - 1)
				Priorite_copie = 2
			End if
			
			' ==== MINIMAL ====
			IF Instr(Ucase(Param), " /PRIORITY:MIN") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:MIN") - 1)
				Priorite_copie = 1
			End if
			
			IF Instr(Ucase(Param), " /PRIORITE:MIN") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:MIN") - 1)
				Priorite_copie = 1
			End if
			
			' ==== AUTOMATISEE SELON LE CPU ===
			IF Instr(Ucase(Param), " /PRIORITY:AUTO") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:AUTO") - 1)
				Priorite_copie = 0
			End if
			
			IF Instr(Ucase(Param), " /PRIORITE:AUTO") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:AUTO") - 1)
				Priorite_copie = 0
			End if
			
			Param = Rtrim(Param)
			
			Source 		 = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, ",") - 1)), CHR(09))), CHR(09))
			Destination  = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, ",") + 1)), CHR(09))), CHR(09))
			
			IF Not Var_Progression = "" Then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] File copy '" & Source & "' a '" & Destination & "' (Priority:" & Priorite_copie & ")  ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				END IF
			Else
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] File copy '" & Source & "' a '" & Destination & "' with " & Var_Progression & " like indicator (Priority:" & Priorite_copie & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				END IF
			End if

			Resultat = CPCDOS_INSTANCE.Copier_Fichier(Source, Destination, Priorite_copie, Var_Progression, Var_Octets, Var_OctetsParSec) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS
			
			If Resultat = false Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
					DEBUG("[CpcdosC+] The file '" & Param & "' has been copied!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** COPIER/ ****
		
	_end_scope_CMD
	
	_scope_CMD
		
		' ===============================================================
		'  Commande de renommage
		' ===============================================================
		CommLang(2) = "rename/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " rename/                    Rename a file or a directory"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Rename'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to rename a source file or directory"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Rename/ MyDirectory/MyFile.log MyNewFile.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Rename/ Folder, NewFolder"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  !! Not avaiable for folder for this version !!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			SCOPE
			' ====================================================================
			
			Dim Resultat as boolean 
			
			Dim Source 		as String
			Dim Destination as String
			
			
			
			Param = Rtrim(Param)
			
			
			
			IF NOT INSTR(Param, ",") > 0 Then 
					DEBUG("[CpcdosC+] For this version, you must separate arguments by a comma ','" & CRLF & "Examble: COPY/ FileA, FileB", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				exit _scope_CMD, _scope
			End if
			
			Source 		 = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, ",") - 1)), CHR(09))), CHR(09))
			Destination  = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, ",") + 1)), CHR(09))), CHR(09))
			
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] File renaming '" & Source & "' to '" & Destination & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF
			

			Resultat = CPCDOS_INSTANCE.Renommer_Fichier(Source, Destination) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS
			
			If Resultat = false Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
					DEBUG("[CpcdosC+] The file '" & Param & "' has been renamed!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** RENOMMER/ ****
	
	_end_scope_CMD	
	
	_scope_CMD
		
		' ===============================================================
		'  Commande de creation dossier
		' ===============================================================
		CommLang(2) = "folder/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " folder/                    Create a folder"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Rename'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create a new 'complete' directory"
					Mess_Aide = Mess_Aide & CRLF & "    By example, if you want to create A folder, B folder in A and"
					Mess_Aide = Mess_Aide & CRLF & "    C folder in B, vous can do this with 1 code line"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Examples"
					Mess_Aide = Mess_Aide & CRLF & "   Create relative directory:"
					Mess_Aide = Mess_Aide & CRLF & "    dossier/ MonRepertoire"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create MyFolter1, myfolder2 and Myfolder3"
					Mess_Aide = Mess_Aide & CRLF & "   Dossier/ MyFolder1/myfolder2/Myfolder3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			SCOPE
			' ====================================================================
			
			Param = Rtrim(Param)
			
			Dim Resultat 	as boolean 
			Dim Source 		as String = Rtrim(Rtrim(Ltrim(Ltrim(Param, CHR(09))), CHR(09)))
			
			Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Source, TRUE, TRUE, FALSE)
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Creating directory '" & Source & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF

			Resultat = CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Source, "")
			
			If Resultat = false Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
					DEBUG("[CpcdosC+] The folder '" & Param & "' has been created!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** DOSSIER/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande de listage repertoire
		' ===============================================================
		CommLang(2) = "dir/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " dir/                       List directory content"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'dir'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to list the directory content"
					Mess_Aide = Mess_Aide & CRLF & "    You can list files, folders and attributes"
					Mess_Aide = Mess_Aide & CRLF & "    You can also use filters . and *"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  List the current directory"
					Mess_Aide = Mess_Aide & CRLF & "    dir/ .   or   dir/ .\" '"
					Mess_Aide = Mess_Aide & CRLF & "  List the content of another directory"
					Mess_Aide = Mess_Aide & CRLF & "    dir/ MyFolder1/MyFolder2"
					Mess_Aide = Mess_Aide & CRLF & "  List files with .CPC extention:"
					Mess_Aide = Mess_Aide & CRLF & "    Rep/ MonDossier1/*.cpc"
					Mess_Aide = Mess_Aide & CRLF & "  List files with 'f' in file name :"
					Mess_Aide = Mess_Aide & CRLF & "    Rep/ MonDossier1/*f*.*"
					Mess_Aide = Mess_Aide & CRLF 
					Mess_Aide = Mess_Aide & CRLF & "   Store Files/Directory in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /L:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Files AND Directory list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Files in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /F:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Files list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Directory in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /D:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Directory list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Attributes in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /A:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Attributes list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   If you want brief information, you can use /B :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder /B     or    Dir/ /B MyFolder"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/ , folder/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Param = Rtrim(Param)
			
			Dim Affichage_Breve as boolean
			Dim Source 			as String
			Dim CPY_Source		as String 
			
			Dim SourceRecherche as String
			Dim Source_exe_path as String
			
			IF Instr(Ucase(Param), "/B") > 0 Then
				' Enlever l'argument
				Param = Mid(Param, 1, Instr(Ucase(Param), "/B") - 1) & Mid(Param, Instr(Ucase(Param), "/B") + 3)
				
				Affichage_Breve = True
			End if
			
			IF Instr(Ucase(Param), "/L:") > 0 Then
				' Lister les Fichier/Dossiers dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/L:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/L:") - 1)
				
				
				
			ElseIF Instr(Ucase(Param), "/F:") > 0 Then
				' Lister les Fichier dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/F:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/F:") - 1)
				
				
			ElseIF Instr(Ucase(Param), "/D:") > 0 Then
				' Lister les Dossiers dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/D:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/D:") - 1)
				
				
			ElseIF Instr(Ucase(Param), "/A:") > 0 Then
				' Lister les Attributs dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/A:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/A:") - 1)
				
				
			End if
			
			Source 			= Rtrim(Rtrim(Ltrim(Ltrim(Param, CHR(09))), CHR(09)))
			CPY_Source		= CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Source, TRUE, TRUE, FALSE)
			
			
			
			IF Instr(CPY_Source, "\") > 0 Then '"
				' Ex: REP/ Dossier\    ou   REP/ Dossier\*.*
				'  --> REP/ Dossier\*.*
				SourceRecherche = Mid(Source, InstrREV(CPY_Source, "\") +1) '"
				
				If SourceRecherche = "" Then SourceRecherche = "\*.*"
				
				IF NOT Instr(CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(SourceRecherche, TRUE, TRUE, FALSE), "_") > 0 Then
					SourceRecherche = "\*.*"
				Else
					Source = Mid(Source, 1, InstrREV(CPY_Source, "\") -1) 
					IF NOT Instr(SourceRecherche, "\") > 0 Then SourceRecherche = "\" & SourceRecherche
				End if
	
			Else
				' Ex: REP/ .
				' --> REP/ .\*.*
				IF Len(CPY_Source) = 1 Then
					IF CPY_Source = "." Then
						SourceRecherche = ".\*.*"
						Source = ""
					Else
						SourceRecherche = ".\*.*"
						Source = ""
					End if
				Else
					' EX: REP/
					' --> REP/ *.*
					SourceRecherche = "\*.*"
					' Source = ""
				End if
			End if
			
			' Si rien n'a ete precise
			if Source = "" Then
				' Si on ne precise rien, alors c'est le dossier courant dans l'executable
				Source_exe_path = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("_EXE_PATH_F_", 2, _CLE_))
				
				' Verifier si la variable existe
				if Source_exe_path = Ucase(CPCDOS_INSTANCE._CONTENU_IMPROPABLE) Then Source_exe_path = ""
				
				' Optimisation
				IF NOT Source_exe_path = "" Then
					Source = Source_exe_path
					Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Source_exe_path, TRUE, TRUE, FALSE)
				
					
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Getting '" & Source & "' directory content with '" & SourceRecherche & "' filters ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					END IF

				Else
					Source = "."
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Getting CPCDOS directory content with '" & SourceRecherche & "' filters ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					END IF
				End if
			Else
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Getting '" & Source & "' directory content with '" & SourceRecherche & "' filters ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				END IF
			End if
			
			scope
				Dim instance_FICHER_DOSSIER_ as _FICHER_DOSSIER_ 
				Dim Resultat as Boolean = CPCDOS_INSTANCE.SYSTEME_INSTANCE.lister_Repertoire(Source, SourceRecherche, instance_FICHER_DOSSIER_)
				
				If instance_FICHER_DOSSIER_.Est_OK = False Then
					' ERREUR
					DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					Dim Message_erreur as String = ERRAVT("ERR_064", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
					exit _scope_CMD, _scope
				Else
					Dim TailleCH 		as integer
					Dim TailleFichier 	as uinteger
					Dim TailleFinal 	as uinteger
					Dim TexteTaille 	as String
					Dim as String octets, kilo, mega, giga, tera
					Dim Resultat_chaine as String = ""
					
					Dim TexteTaille_FINAL as String
					
					' OK
					
					IF Affichage_Breve = False Then
							Resultat_chaine += " Directory content '" & Source & "' :" & CRLF
						
					End if
					
					
					' Afficher la bonne taille (Octets, Kilos, Mega, Giga)
					

						octets = "b"
						kilo = "kb"
						mega = "mb"
						giga = "gb"
						tera = "tb"
					
					for b as integer = 1 to instance_FICHER_DOSSIER_.nb_Elements
		
						if instance_FICHER_DOSSIER_.attributs_Elements(b).EstUnDossier = True Then
						
							TexteTaille = ""
						
							' Calculer la taille de la chaine pour enlever des espaces
							TailleCH = ((8 + 1 + 3) + 16) - len("[" & instance_FICHER_DOSSIER_.liste_Elements(b) & "]")
							
							' Ajouter le nom + l'attribut dossier
							IF Affichage_Breve = False Then
								Resultat_chaine += " - [" & instance_FICHER_DOSSIER_.liste_Elements(b) & "]" & SPACE(TailleCH) & " <D"
							Else
								Resultat_chaine += "[" & instance_FICHER_DOSSIER_.liste_Elements(b) & "] <D"
							End if
						Else
							' Calculer la taille de la chaine pour enlever des espaces
							TailleCH = ((8 + 1 + 3) + 16) - len(instance_FICHER_DOSSIER_.liste_Elements(b))
							
							' Recuperer la taille du fichier et le convertir en KiloOctets
							TailleFichier = instance_FICHER_DOSSIER_.attributs_Elements(b).taille
							
							' Incrmenter la taille total
							TailleFinal += TailleFichier
							
							Scope 

								' Attribuer l'unite correspondante a la taille
								IF TailleFichier < 1 Then
									' Fichier VIDE
									TexteTaille = "0 " & octets
								Else
									IF (TailleFichier/1024^4) < 1 Then ' Tera
										IF (TailleFichier/1024^3) < 1 Then ' Giga
											IF (TailleFichier/1024^2) < 1 Then ' Mega
												IF (TailleFichier/1024) < 1 Then ' Kilo
													TexteTaille = TailleFichier & " " & octets ' OCTETS
												Else
													TexteTaille = Left(str(TailleFichier/1024), instr(str(TailleFichier/1024), ".") + 3) & " " & kilo ' KILOS
												End if
											Else
												TexteTaille = Left(str(TailleFichier/1024^2), instr(str(TailleFichier/1024^2), ".") + 3) & " " & mega ' MEGA
											End if
										Else
											TexteTaille = Left(str(TailleFichier/1024^3), instr(str(TailleFichier/1024^3), ".") + 3) & " " & giga ' GIGA
										End if
									Else
										TexteTaille = Left(str(TailleFichier/1024^4), instr(str(TailleFichier/1024^4), ".") + 3) & " " & tera ' TERA
									End if
								End if
							End Scope
							
							' Ajouter le nom + l'attribut fichier
							IF Affichage_Breve = False Then
								Resultat_chaine += " - " & instance_FICHER_DOSSIER_.liste_Elements(b) & SPACE(TailleCH) & " <F"
							Else
								Resultat_chaine += instance_FICHER_DOSSIER_.liste_Elements(b) & " <F"
							End if
						end if
						
						' ** Ajouter les autres attributs **
						
						' Lecture Seule
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_ReadOnly = True Then Resultat_chaine += ",r"
						
						' Cache
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Hidden = True Then Resultat_chaine += ",h"
						
						' Systeme
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_System = True Then Resultat_chaine += ",s"
						
						' Archive
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Archive = True Then Resultat_chaine += ",a"
						
						' Normal
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Normal = True Then Resultat_chaine += ",n"
						
						
						' Ajouter un retour chariot
						IF Affichage_Breve = False Then
							Resultat_chaine += "> " & SPACE(15 - (instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Nombre * 2 + 2)) & TexteTaille & CRLF
						Else
							Resultat_chaine += "> " & TexteTaille & CRLF
						End if
					next b
					
					
					
					' Attribuer l'unite correspondante a la taille
					IF TailleFinal < 1 Then
						' Fichier VIDE
						TexteTaille_FINAL = "0 " & octets
					Else
						IF (TailleFinal/1024^4) < 1 Then ' Tera
							IF (TailleFinal/1024^3) < 1 Then ' Giga
								IF (TailleFinal/1024^2) < 1 Then ' Mega
									IF (TailleFinal/1024) < 1 Then ' Kilo
										TexteTaille_FINAL = TailleFinal & " " & octets ' OCTETS
									Else
										TexteTaille_FINAL = Left(str(TailleFinal/1024), instr(str(TailleFinal/1024), ".") + 3) & " " & kilo ' KILOS
									End if
								Else
									TexteTaille_FINAL = Left(str(TailleFinal/1024^2), instr(str(TailleFinal/1024^2), ".") + 3) & " " & mega ' MEGA
								End if
							Else
								TexteTaille_FINAL = Left(str(TailleFinal/1024^3), instr(str(TailleFinal/1024^3), ".") + 3) & " " & giga ' GIGA
							End if
						Else
							TexteTaille_FINAL = Left(str(TailleFinal/1024^4), instr(str(TailleFinal/1024^4), ".") + 3) & " " & tera ' TERA
						End if
					End if
					
					IF Affichage_Breve = False Then
							Resultat_chaine += " " & instance_FICHER_DOSSIER_.nb_Dossiers & " folder(s)" & " " & instance_FICHER_DOSSIER_.nb_Fichiers & " file(s) " & _
													" Total : " & instance_FICHER_DOSSIER_.nb_Elements & " element(s) " & TexteTaille_FINAL
						
					Else
						Resultat_chaine += "-> D:" & instance_FICHER_DOSSIER_.nb_Dossiers & " F:" & instance_FICHER_DOSSIER_.nb_Fichiers & _
													" T:" & instance_FICHER_DOSSIER_.nb_Elements & " S:" & TexteTaille_FINAL
					End if
					
					DEBUG(Resultat_chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End scope
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** DIR/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour afficher du texte a l'ecran
		' ===============================================================
		CommLang(2) = "txt/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " txt/                       Write text"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'TeXT'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to display text on LC console"
					Mess_Aide = Mess_Aide & CRLF & "   or in an directed ouput " & CHR(34) & "@#Ma_Variable" & CHR(34) & " ou " & CHR(34) & "@$Mon_Fichier.abc" & CHR(34) & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    LC:[FR] Ligne de Commandes [EN] Commands line (no GUI)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello world!"
					Mess_Aide = Mess_Aide & CRLF & "   @#Toto txt/ Hello tata!"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ %toto%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hi/#R"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Human /#R"
					Mess_Aide = Mess_Aide & CRLF & "  Results :"
					Mess_Aide = Mess_Aide & CRLF & "   Hello world!"
					Mess_Aide = Mess_Aide & CRLF & "   Hello world!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : fix/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF

			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			Dim TXT_CRLF				as Integer
			Dim TXT_Date				as Integer
			Dim TXT_Couleur				as Integer
			
			TXT_CRLF 	= CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF
			TXT_Date 	= CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate
			TXT_Couleur = CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal

			IF Instr(UCASE(Param), "/#ENCRYPT") > 0 Then
				Param = MID(Param, 1, Instr(UCASE(Param), "/#ENCRYPT") - 1) 

				' Encrypt message
				Param = CPCDOS_INSTANCE.encrypt_message(Param)
			End if

			IF Instr(UCASE(Param), "/#R") > 0 Then
				Param = MID(Param, 1, Instr(UCASE(Param), "/#R") - 1) ' /#R pour que le texte reste sur la ligne
				TXT_CRLF = CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF
			End if
			IF Instr(UCASE(Param), "/#DEBUG") > 0 Then
				Param = MID(Param, 1, Instr(UCASE(Param), "/#DEBUG") - 1) ' /#DEBUG pour obtenir les info de debuggage
				TXT_Date = CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate
			End if
			' Recuperer les Parametres

			DEBUG(Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, TXT_Couleur, 0, TXT_CRLF, TXT_Date, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** TXT/ ****
		
		
	_end_scope_CMD
	
	
	_scope_CMD
		
		' ===============================================================
		'  Commande pour fixer une variable CpcdosC+
		' ===============================================================
		CommLang(2) = "set/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " set/                       Create or modify a variable or array(s)"
			
		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create a variable or array(s)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Simple exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Variable = Johann"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hi %My_variable% !"
					Mess_Aide = Mess_Aide & CRLF & "  Delete variable/array:"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /S My_variable"
					Mess_Aide = Mess_Aide & CRLF & "  Asking user :"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /q My_Variable"
					Mess_Aide = Mess_Aide & CRLF & "   Wait key press (Blocking):"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /wkey My_Variable"
					Mess_Aide = Mess_Aide & CRLF & "   Ckeck keyboard buffer content (no blocking):"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /key My_Variable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple tableau :"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Array[0] = Toto"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Array[1] = Tata"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Array[2] = titi"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Array content 1:%My_Array[0]% 2:%My_Array[1]% 3:%My_Array[2]% "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Results :"
					Mess_Aide = Mess_Aide & CRLF & "   Array content 1:Toto 2:Tata 3:titi"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " To know: Variable names contenting " & CHR(34) & "_, ., -, $, /, \, (, ), [, ], ~, &, #, ^, @" & CHR(34) & " are authorized"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			SCOPE
			' ====================================================================
			
			Dim RapidAdd				as Boolean = false
			Dim PosPP					as Integer = 0
			Dim PosMM					as Integer = 0
			Dim PosEgale 				as Integer = 0 ' 587
			Dim PosSupprimer 			as Integer = 0 ' 571
			Dim PosATouche_EN 			as Integer = 0
			Dim PosTouche_EN 			as Integer = 0
			Dim PosQuestion	 			as Integer = 0
			Dim PosATouche	 			as Integer = 0
			Dim PosTouche	 			as Integer = 0
			
			Dim index 					as integer = 0
			
			Dim Nom_Variable_a_FIXER 	as String
			Dim Donnees_Variables_de_FIX as String
			
			PosEgale = instr(Param, "=")
			
			PosPP = instr(UCASE(Param), "++") ' Ajouter +1 a une variable
			PosMM = instr(UCASE(Param), "--") ' Ajouter -1 a une variable
			if PosPP > 0 OR PosMM > 0 Then RapidAdd = true

			PosQuestion = instr(UCASE(Param), "/Q") ' Poser une question a l'utilisateur
			IF PosQuestion > 0 then
				if instr(UCASE(Param), "/Q ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosQuestion < PosEgale then ' et qu'il soit apres le /s
							if instr(UCASE(Param), " /Q ") > PosQuestion then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosQuestion = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosQuestion < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosQuestion = 0
						END IF
					END IF
				END IF
			End if
			
			PosATouche = instr(UCASE(Param), "/ATOUCHE") ' Attendre la pression d'une touche
			IF PosATouche > 0 then
				if instr(UCASE(Param), "/ATOUCHE ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosATouche < PosEgale then ' et qu'il soit apres le /s
							if instr(UCASE(Param), " /ATOUCHE ") > PosATouche then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosATouche = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosATouche < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosATouche = 0
						END IF
					END IF
				END IF
			End if

			PosTouche = instr(UCASE(Param), "/TOUCHE") ' Ckecker le contenu du buffer
			IF PosTouche > 0 then
				if instr(UCASE(Param), "/TOUCHE ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosTouche < PosEgale then ' et qu'il soit apres le /TOUCHE
							if instr(UCASE(Param), " /TOUCHE ") > PosTouche then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosTouche = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosTouche < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosTouche = 0
						END IF
					END IF
				END IF
			End if
			
			PosATouche_EN = instr(UCASE(Param), "/WKEY") ' Attendre la pression d'une touche
			IF PosATouche_EN > 0 then
				if instr(UCASE(Param), "/WKEY ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosATouche_EN < PosEgale then ' et qu'il soit apres le /WKEY
							if instr(UCASE(Param), " /WKEY ") > PosATouche_EN then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosATouche_EN = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosATouche_EN < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosATouche_EN = 0
						END IF
					END IF
				END IF
			End if
			
			PosTouche_EN = instr(UCASE(Param), "/KEY") ' Ckecker le contenu du buffer
			IF PosTouche_EN > 0 then
				if instr(UCASE(Param), "/KEY ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosTouche_EN < PosEgale then ' et qu'il soit apres le /KEY
							if instr(UCASE(Param), " /KEY ") > PosTouche_EN then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosTouche_EN = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosTouche_EN < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosTouche_EN = 0
						END IF
					END IF
				END IF
			End if

			PosSupprimer = instr(UCASE(Param), "/S") ' Supprimer une variable
			IF PosSupprimer > 0 then
				if instr(UCASE(Param), "/S ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosSupprimer < PosEgale then ' et qu'il soit apres le /s
							if instr(UCASE(Param), " /S ") > PosSupprimer then
								Message_erreur = ERRAVT("AVT_049", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosSupprimer = 0
						end if
					end if
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosEgale > PosSupprimer then
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosSupprimer = 0
						end if
					END IF
				End if
			End if


			' Gerer le probleme de placement du signe '='
			If PosEgale > 0 then
				if instr(Param, "=") > 0 Then
					if instr(Param, "=") > PosEgale then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					end if
				ELSE
					Message_erreur = ERRAVT("AVT_048", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				END IF
			End if

			' Si l'utilisateur rentre tard le soir d'une soir�e bien arros�e et
			' compl�tement torch� entre une commande du type :
			' fix/ /s mariable = contenu wtf
			if PosEgale > PosSupprimer THEN
				IF PosEgale > 0 then
					IF PosSupprimer > 0 Then
						Message_erreur = ERRAVT("AVT_049", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if

			if PosEgale > PosQuestion THEN
				IF PosEgale > 0 then
					IF PosQuestion > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if
			
			if PosEgale > PosTouche THEN
				IF PosEgale > 0 then
					IF PosTouche > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if
			
			if PosEgale > PosATouche THEN
				IF PosEgale > 0 then
					IF PosATouche > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if
			
			if PosEgale > PosTouche_EN THEN
				IF PosEgale > 0 then
					IF PosTouche_EN > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if
			
			' Si variable++ variable--
			if PosEgale < 1 AND PosATouche < 1 AND PosTouche_EN < 1 AND PosQuestion < 1 AND PosSupprimer < 1 Then 
				if RapidAdd = true Then
					Dim VariableCalc as double
					Dim VariableCalc_STR as String
					
					' Il s'agit d'un ++
					If PosPP > 0 Then
						VariableCalc_STR = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, 1, PosPP - 1), CHR(09)))), chr(13)), chr(10))
						if len(VariableCalc_STR) > 0 Then
							VariableCalc = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable(VariableCalc_STR, Niveau_2, _CLE_))
							
							VariableCalc += 1
							
							CpcdosCP_SHELL = CpcdosCP_SHELL("SET/ " & VariableCalc_STR & " = " & VariableCalc, _CLE_, Niveau_2, Param_1, Param_2)
						Else
								DEBUG("[CpcdosC+] Unable to add " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						exit _scope_CMD, _scope
						
					' Il s'agit d'un --
					ElseIf PosMM > 0 Then
						VariableCalc_STR = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, 1, PosMM - 1), CHR(09)))), chr(13)), chr(10))
						if len(VariableCalc_STR) > 0 Then
							VariableCalc = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable(VariableCalc_STR, Niveau_2, _CLE_))
							
							VariableCalc -= 1
							
							CpcdosCP_SHELL = CpcdosCP_SHELL("SET/ " & VariableCalc_STR & " = " & VariableCalc, _CLE_, Niveau_2, Param_1, Param_2)
						Else
								DEBUG("[CpcdosC+] Unable to substract. " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
					End if
				
					exit _scope_CMD, _scope
				Else
					Message_erreur = ERRAVT("AVT_083", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
			End if
			
			IF PosTouche > 0 OR PosTouche_EN > 0 Then
				' Si on veut juste le contenu du buffer
				dim VariableQuestion as string
				Dim KeyBuffer as String
				
				IF PosTouche > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosTouche + 8), CHR(09)))), chr(13)), chr(10))
				Elseif PosTouche_EN > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosTouche + 5), CHR(09)))), chr(13)), chr(10))
				else
					DEBUG("[CpcdosC+] ERR IND_1.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
				
				KeyBuffer = Inkey
				
				if KeyBuffer = "" then KeyBuffer = "\#NULL"
				
				CpcdosCP_SHELL = CpcdosCP_SHELL("SET/ " & VariableQuestion & " = " & KeyBuffer, _CLE_, Niveau_2, Param_1, Param_2)
			
				exit _scope_CMD, _scope
			End if

			if PosQuestion > 0 OR PosATouche > 0 OR PosATouche_EN > 0 then
				' Si un veut une reponse de la part de l'utilisateur
				' Si on est en graphique, un messagebox apparait, si on est en console le message console apparait
				dim VariableQuestion as string
				
			
				' On recupere la variable en supprimant les espace et TABs
				IF PosATouche > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosATouche + 9), CHR(09)))), chr(13)), chr(10))
				ElseIf PosATouche_EN > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosATouche_EN + 6), CHR(09)))), chr(13)), chr(10))
				Elseif PosQuestion > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosQuestion + 3), CHR(09)))), chr(13)), chr(10))
				else
					DEBUG("[CpcdosC+] ERR IND_2.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
				
				' Faire sorte que quand on est en mode console, si une 2eme application
				' utilise cette commande, elle se met en pause.
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion 			= VariableQuestion
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_TOCK 		= 0
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_CLE_ 		= _CLE_
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_NIVEAU_CCP = NIVEAU_CCP
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_Param_1 	= Param_1
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_Param_2 	= Param_2
				
				' Vider le contenu du buffer
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.Buffer_commande = ""

				scope
				
				
					' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
					Dim _TID_Console_QUESTION as uinteger
					Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
					' Remplir la structure
					INSTANCE_STRUCT_THREAD.Nom 		= "THREAD__GetTouche"			' Nom du thread
					INSTANCE_STRUCT_THREAD.Fonction = @THREAD__GetTouche			' Adresse memoire
					INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID						' PID du processus parent
					INSTANCE_STRUCT_THREAD.OS_ID	= CPCDOS_INSTANCE.get_id_OS()	' ID de l'OS
					INSTANCE_STRUCT_THREAD.THREAD_ID= Auth_TID
					INSTANCE_STRUCT_THREAD.USER_ID	= CPCDOS_INSTANCE.get_id_Utilisateur()	' ID de l'user
					INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel
					
					INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_ASSEZ_HAUTE
					INSTANCE_STRUCT_THREAD.handle	= 0								' Argument pour CPinti Core
					INSTANCE_STRUCT_THREAD.ARG_CP	= NULL							' Argument pour CPinti Core
					INSTANCE_STRUCT_THREAD.ARG_1 	= NULL
					INSTANCE_STRUCT_THREAD.ARG_2 	= NULL
					INSTANCE_STRUCT_THREAD.ARG_3	= NULL
					INSTANCE_STRUCT_THREAD.ARG_4	= NULL
					INSTANCE_STRUCT_THREAD.ARG_5 	= NULL
					INSTANCE_STRUCT_THREAD.ARG_6 	= NULL

					
					IF PosQuestion > 0 Then
						INSTANCE_STRUCT_THREAD.ARG_1 	= cast(any ptr, 2)
						INSTANCE_STRUCT_THREAD.Nom = INSTANCE_STRUCT_THREAD.Nom & "_QUESTION"
					ElseIf PosATouche > 0 OR PosATouche_EN > 0 Then
						INSTANCE_STRUCT_THREAD.ARG_1 	= cast(any ptr, 1)
						INSTANCE_STRUCT_THREAD.Nom = INSTANCE_STRUCT_THREAD.Nom & "_KEY"
					End if
					
					INSTANCE_STRUCT_THREAD.ARG_2 	= cast(any ptr, POS) 		' Position curseur X 
					INSTANCE_STRUCT_THREAD.ARG_3 	= cast(any ptr, CSRLIN) 	' Position curseur Y
					
					scope
						' Creer le thread temporaire grace a la structure ci-dessus
						_TID_Console_QUESTION = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
						' On bloque le thread tant que FIXQuestion n'est pas null
						while(CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion = VariableQuestion)
							doevents(50000)
						Wend
						
						' On ferme le thread qui a permi taper sur la console
						CPCDOS_INSTANCE.Fermer_thread(Auth_PID, _TID_Console_QUESTION, false)
						
					End scope
					
				End scope
				
				exit _scope_CMD, _scope
			End if

			IF PosEgale > 0 then
				Dim PtitSautNomValide as integer
				Dim PremiereParenthese as integer = 0
				Dim DeuxiemeParenthese as integer = 0
				' Si on arrive la, c'est que le placement de '=' est OK! :-)
				' Recuperer le nom de variable
				Nom_Variable_a_FIXER = RTRIM(LTRIM(LTRIM(MID(Param, 1, PosEgale - 1)), CHR(09))) ' Supprimer ESPACES et tabulations
				
				
				' Verifier caractere par caractere s'il respecte le nom de variable type cpcdosc+
				For BoucleChercherValideNomVariable as integer = 1 to 255
					PtitSautNomValide = 0
					IF BoucleChercherValideNomVariable = 35 Then PtitSautNomValide = 1 ' #
					IF BoucleChercherValideNomVariable = 36 Then PtitSautNomValide = 1 ' $
					IF BoucleChercherValideNomVariable = 38 Then PtitSautNomValide = 1 ' &
					IF BoucleChercherValideNomVariable = 40 Then PtitSautNomValide = 1 ' (
					IF BoucleChercherValideNomVariable = 41 Then PtitSautNomValide = 1 ' )
					IF BoucleChercherValideNomVariable >= 45 Then
						IF BoucleChercherValideNomVariable <= 57 Then 
							PtitSautNomValide = 1  ' - . / 0 1 2 3 4 5 6 7 8 9
						End if
					End if
					IF BoucleChercherValideNomVariable >= 64 Then
						IF BoucleChercherValideNomVariable <= 95 Then 
							PtitSautNomValide = 1  ' @, A-Z (majuscule), [, \, ], ^
						End if
					End if
					IF BoucleChercherValideNomVariable >= 97 Then
						IF BoucleChercherValideNomVariable <= 122 Then 
							PtitSautNomValide = 1  ' a-z (minuscules)
						End if
					End if
					IF BoucleChercherValideNomVariable = 126 Then PtitSautNomValide = 1 ' ~
					'								Si 1 seule des 2 parentheses est presente
					IF PtitSautNomValide = 0 then
						IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0 Then
						ELSE
							If Instr(Nom_Variable_a_FIXER, chr(BoucleChercherValideNomVariable)) > 0 Then
								Message_erreur = ERRAVT("AVT_048", 0)
									DEBUG("[CpcdosC+] " & Message_erreur & ". Invalid character '" & chr(BoucleChercherValideNomVariable) &"' Command:" & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									exit _scope_CMD, _scope
								
							End if
						End if
					End if
				Next BoucleChercherValideNomVariable

				' Si c'est un tableau et ce qui a entre les parentheses n'est pas un chiffres
				'  mais une varaible, alors on remplace ce nom de variable par son contenu
				PremiereParenthese = INSTR(Nom_Variable_a_FIXER, "[")
				
				IF PremiereParenthese > 0 Then
					DeuxiemeParenthese = INSTR(Nom_Variable_a_FIXER, "]")
					' Si la premi�re parenthese '[' est bien avant la deuxieme ']'
					if PremiereParenthese >= DeuxiemeParenthese Then 
						Message_erreur = ERRAVT("AVT_073", 0)
							DEBUG("[AVT_073]:" & Message_erreur & " your variable name '" & Nom_Variable_a_FIXER & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					End if
				End if

				' Maintenant qu'on a le nom de variable recupere, on recupere ce qu'il y a apres '='
				Donnees_Variables_de_FIX = MID(Param, PosEgale + 1)
				
				' S'il y a 1 espace, alors le conderer comme un espacement sur la syntaxe
				'  le 2eme sera pris en compte s'il est aussi present
				IF MID(Donnees_Variables_de_FIX, 1, 1) = " " THEN Donnees_Variables_de_FIX = MID(Donnees_Variables_de_FIX, 2)
					
				IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0Then
					
					Dim PremierNombre as Integer
					Dim DeuxiemeNombre as Integer
					Dim NombreBoucle as integer
					
					Dim Crochet_1 as integer = INSTR(Nom_Variable_a_FIXER, "[")
					Dim Crochet_2 as integer = INSTRREV(Nom_Variable_a_FIXER, "]")
					
					Dim Jusqu_A as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " A ")
					Dim Jusqu_TO as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " TO ")
					Dim Jusqu_3PTS as integer = INSTR(UCASE(Nom_Variable_a_FIXER), "..")
					
					IF Jusqu_A > 0 Then
						' En enlevant les espaces et tab
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_A - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_A+2 + 1, Crochet_2 - (Jusqu_A+2 + 1)), chr(09))), chr(09))))
						
					ElseIf Jusqu_TO > 0 Then
						
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_TO - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_TO+3 + 1, Crochet_2 - (Jusqu_TO+3 + 1)), chr(09))), chr(09))))
					ElseIf Jusqu_3PTS > 0 Then
						
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_3PTS - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_3PTS+1 + 1, Crochet_2 - (Jusqu_3PTS+1 + 1)), chr(09))), chr(09))))
					
					End if
					
					Nom_Variable_a_FIXER = LTRIM(LTRIM(RTRIM(RTRIM(MID(Nom_Variable_a_FIXER, 1, Crochet_1 - 1)), CHR(09))), CHR(09))
					NombreBoucle = DeuxiemeNombre - PremierNombre
					
					' Si il a mis du genre [5 a 20]
					if NombreBoucle > 0 Then
						For Index_Boucle as integer = PremierNombre to DeuxiemeNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & Index_Boucle & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
						Next Index_Boucle
					
					' Si il a mis du genre [20 a 5]
					Elseif NombreBoucle < 0 Then
						For Index_Boucle as integer = DeuxiemeNombre to PremierNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & PremierNombre-(Index_Boucle-DeuxiemeNombre) & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
						Next Index_Boucle
					Else
							DEBUG("[CpcdosC+] Index array can't be null." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
						exit _scope_CMD, _scope
					End if
					exit _scope_CMD, _scope
				End if
					
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				END IF
				index = Gest_variables_ENREG (Nom_Variable_a_FIXER, Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				END IF
				exit _scope_CMD, _scope
			ELSEIF PosSupprimer > 0 Then
				' Si le Parametre /S est present, on supprime la variable
				' Recuperer le nom de variable
				Nom_Variable_a_FIXER = RTRIM(LTRIM(LTRIM(MID(Param, PosSupprimer + 3)), CHR(09)))
				
				' On supprime d'un element a un autre
				IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0 Then
						
					Dim PremierNombre as Integer
					Dim DeuxiemeNombre as Integer
					Dim NombreBoucle as integer
					
					Dim Crochet_1 as integer = INSTR(Nom_Variable_a_FIXER, "[")
					Dim Crochet_2 as integer = INSTRREV(Nom_Variable_a_FIXER, "]")
					
					Dim Jusqu_A as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " A ")
					Dim Jusqu_TO as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " TO ")
					Dim Jusqu_3PTS as integer = INSTR(UCASE(Nom_Variable_a_FIXER), "..")
					
					IF Jusqu_A > 0 Then
						' En enlevant les espaces et tab
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_A - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_A+2 + 1, Crochet_2 - (Jusqu_A+2 + 1)), chr(09))), chr(09))))
						
					ElseIf Jusqu_TO > 0 Then
						
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_TO - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_TO+3 + 1, Crochet_2 - (Jusqu_TO+3 + 1)), chr(09))), chr(09))))
					ElseIf Jusqu_3PTS > 0 Then
						
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_3PTS - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_3PTS+1 + 1, Crochet_2 - (Jusqu_3PTS+1 + 1)), chr(09))), chr(09))))
					End if
					
					Nom_Variable_a_FIXER = LTRIM(LTRIM(RTRIM(RTRIM(MID(Nom_Variable_a_FIXER, 1, Crochet_1 - 1)), CHR(09))), CHR(09))
					NombreBoucle = DeuxiemeNombre - PremierNombre
					
					Donnees_Variables_de_FIX = "\#NULL"
					
					' Si il a mis du genre [5 a 20]
					if NombreBoucle > 0 Then
						For Index_Boucle as integer = PremierNombre to DeuxiemeNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Deleting variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
							IF Gest_variables_Suppr(Nom_Variable_a_FIXER & "[" & Index_Boucle & "]", NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID) = 0 Then
								Message_erreur = ERRAVT("AVT_008", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Nom_Variable_a_FIXER & CHR(34) & " dans " & CHR(34) & Commande & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							End if
						Next Index_Boucle
					
					' Si il a mis du genre [20 a 5]
					Elseif NombreBoucle < 0 Then
						For Index_Boucle as integer = DeuxiemeNombre to PremierNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Kernel > Deleting variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
							IF Gest_variables_Suppr(Nom_Variable_a_FIXER & "[" & PremierNombre-(Index_Boucle-DeuxiemeNombre) & "]", NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID) = 0 Then
								Message_erreur = ERRAVT("AVT_008", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Nom_Variable_a_FIXER & CHR(34) & " dans " & CHR(34) & Commande & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							End if
						Next Index_Boucle
					Else
							DEBUG("[CpcdosC+] Index array can't be null." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
						exit _scope_CMD, _scope
					End if
					exit _scope_CMD, _scope
				End if
				
				
				IF instr(Nom_Variable_a_FIXER, " ") > 0 Then ' Il y a des espaces!
					Message_erreur = ERRAVT("AVT_049", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				END If
				
								
				' On supprime tout le tableau ---> Il faut connaitre la taille :/ (son debut et sa fin))
				' IF INSTR(Nom_Variable_a_FIXER, "[]") > 0 Then
				
				' Nom de variable recupere, maintenant on la supprime!
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Deleting variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				END IF
				IF Gest_variables_Suppr(Nom_Variable_a_FIXER, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID) = 0 Then
					Message_erreur = ERRAVT("AVT_008", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Nom_Variable_a_FIXER & CHR(34) & " dans " & CHR(34) & Commande & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
			Else
				Nom_Variable_a_FIXER = RTRIM(LTRIM(LTRIM(MID(Param, 1)), CHR(09))) ' Supprimer ESPACES et tabulations
				
				IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0 Then
						
					Dim PremierNombre as Integer
					Dim DeuxiemeNombre as Integer
					Dim NombreBoucle as integer
					
					Dim Crochet_1 as integer = INSTR(Nom_Variable_a_FIXER, "[")
					Dim Crochet_2 as integer = INSTRREV(Nom_Variable_a_FIXER, "]")
					
					Dim Jusqu_A as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " A ")
					Dim Jusqu_TO as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " TO ")
					Dim Jusqu_3PTS as integer = INSTR(UCASE(Nom_Variable_a_FIXER), "..")
					
					IF Jusqu_A > 0 Then
						' En enlevant les espaces et tab
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_A - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_A+2 + 1, Crochet_2 - (Jusqu_A+2 + 1)), chr(09))), chr(09))))
						
					ElseIf Jusqu_TO > 0 Then
						
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_TO - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_TO+3 + 1, Crochet_2 - (Jusqu_TO+3 + 1)), chr(09))), chr(09))))
					ElseIf Jusqu_3PTS > 0 Then
						
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_3PTS - (Crochet_1 + 1)), chr(09))), chr(09))))
						
						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_3PTS+1 + 1, Crochet_2 - (Jusqu_3PTS+1 + 1)), chr(09))), chr(09))))
					End if
					
					Nom_Variable_a_FIXER = LTRIM(LTRIM(RTRIM(RTRIM(MID(Nom_Variable_a_FIXER, 1, Crochet_1 - 1)), CHR(09))), CHR(09))
					NombreBoucle = DeuxiemeNombre - PremierNombre
					
					Donnees_Variables_de_FIX = "\#NULL"
					
					' Si il a mis du genre [5 a 20]
					if NombreBoucle > 0 Then
						For Index_Boucle as integer = PremierNombre to DeuxiemeNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & Index_Boucle & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
						Next Index_Boucle
					
					' Si il a mis du genre [20 a 5]
					Elseif NombreBoucle < 0 Then
						For Index_Boucle as integer = DeuxiemeNombre to PremierNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & PremierNombre-(Index_Boucle-DeuxiemeNombre) & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
						Next Index_Boucle
					Else
							DEBUG("[CpcdosC+] Index array can't be null." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
						exit _scope_CMD, _scope
					End if
					exit _scope_CMD, _scope
				End if
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** FIX/ ****
		
	_end_scope_CMD
	
	
	_scope_CMD
		
		' ===============================================================
		'  Commande pour demarrer un OS
		' ===============================================================
		CommLang(2) = "start/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " start/                     Starting installed operating system(s)"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'START'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch the fist step for starting OS."
					Mess_Aide = Mess_Aide & CRLF & "   Starting process are different beetween OS."
					Mess_Aide = Mess_Aide & CRLF & "   The loader launch in first the file 'OS/OS.CPC'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   It's possible to define OS name to start if there are more that 1 installed."
					Mess_Aide = Mess_Aide & CRLF & "   If the name is not defined, Cpcdos will start the first of the list 'OS.LST'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Start/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Start/ MyOS"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Tester la presence d'au moins 1 OS !
			if CPCDOS_INSTANCE.get_NombreOSPresent <= 0 Then
					DEBUG("[CpcdosC+] Operating system not found.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			
			else
				' Il y a au moins 1 OS present, on demarre le premier
				
				Dim NumeroOS 	as integer = 0
				Dim Retour 		as String
				Dim NomOS 		as String 
				Dim PathOS 		as String
				
				
				Param = Ltrim(Rtrim(Rtrim(Ltrim(Param)), chr(09)), chr(09))
				
				' Tester la presence de L'OS
				IF LEN(Param) > 0 Then
					' Il y a un nom d'OS precise
					NumeroOS = CPCDOS_INSTANCE.test_OSPresent(Param)
					
				Else
					' Si aucun nom precise, alors on recupere le PREMIER OS
					NumeroOS = 0
				End if
									
				' Si l'OS indique est non present
				if NumeroOS < 0 Then
						DEBUG("[CpcdosC+] Operating system '" & Param & "' not found.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
				
				' Recuperer les informations de l'OS
				Retour = CPCDOS_INSTANCE.get_OSPresent(NumeroOS)
				
				' Recuperer le nom de l'OS
				NomOS = MID(Retour, 1, instr(Retour, "PATH:") - 2)
				
				' Et son Path
				PathOS = MID(Retour, instr(Retour, "PATH:") + 5)
				

				Scope
					
					CPCDOS_INSTANCE.SCI_INSTANCE.set_NombreOSenCours(CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() + 1)
					
					doevents(_PAUSE_CRT + 200) ' Pause CRT CPinticore
				
					' On genere une nouvelle cle mais avec NumeroOS ce  va permettre par la 
					'  suite de separer les espaces memoires par OS
					_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)
					
					CPCDOS_INSTANCE.SCI_INSTANCE.set_OSid(NumeroOS)
				
						DEBUG("[CpcdosC+] Starting operating system '" & NomOS & "' [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
	
					CpcdosCP_SHELL = "SWITCH:OS_ID=" & NomOS
					
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("exe/ " & PathOS & "\OS.CPC", _CLE_, 5, 330, RetourVAR)
					
						DEBUG("[CpcdosC+] Operating system '" & NomOS & "' finished loading ! [Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				End scope
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** DEMARRER/ ****
		
	_end_scope_CMD
	
	
	
	_scope_CMD
		' ===============================================================
		'  Commande pour executer l'IUG
		' ===============================================================
		CommLang(2) = "gui/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0

		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " gui/                       Launch cpcdos graphic user interface"
			
		END IF
		
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande

			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Graphic User Interface'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch graphic interface"
					Mess_Aide = Mess_Aide & CRLF & "    And stop boot screen"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   gui/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display the GUI from another OS in execution. Example with 'Toto'" 
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /OS:Toto"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Reduce GUI (Open console)"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /LC     or    /CONSOLE"
					Mess_Aide = Mess_Aide & CRLF 
					Mess_Aide = Mess_Aide & CRLF & "  Open GUI console"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /LC+    or    /CONSOLE+"
					Mess_Aide = Mess_Aide & CRLF 
					Mess_Aide = Mess_Aide & CRLF & "  Display black list functions events not found"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /display-blacklist-events"
					Mess_Aide = Mess_Aide & CRLF 
					Mess_Aide = Mess_Aide & CRLF & "  Back to zero, black list functions events not found"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /reset-blacklist-events"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display the without OS GUI (the blank kernel gui)"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /WITHOUTOS"
					Mess_Aide = Mess_Aide & CRLF 
					Mess_Aide = Mess_Aide & CRLF & "   Blitting flux for all picturebox"
					Mess_Aide = Mess_Aide & CRLF & "    gui/ /MULTI-PICTUREBOX"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)

			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF

			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			SCOPE
			' ====================================================================
			Dim NumeroOS as Integer = Auth_OS
			
			if CPCDOS_INSTANCE.Thread_BootScreen > 0 Then
				CPCDOS_INSTANCE.Fermer_Thread(CPCDOS_INSTANCE.SYSTEME_INSTANCE._MAIN_PROCESSUS, CPCDOS_INSTANCE.Thread_BootScreen, false)
				CPCDOS_INSTANCE.Thread_BootScreen = 0
					DEBUG("[CpcdosC+] Closing thread 'Thread_bootscreen' ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				
			
				' Attendre fermeture thread
				doevents(500000)
			End if
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Launching graphic interface (OSid:" & NumeroOS & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF

			
			
			IF instr(ucase(Param), "/MULTI-PICTUREBOX") > 0 Then
				CPCDOS_INSTANCE.SCI_INSTANCE.MULTI_PICTUREBOX = 1
			else
				CPCDOS_INSTANCE.SCI_INSTANCE.MULTI_PICTUREBOX = 0
			End if
	
			' Sans OS
			IF instr(ucase(Param), "/WITHOUTOS") > 0 OR instr(ucase(Param), "/SANSOS") > 0 Then
				
				DEBUG("Without OS !!!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
				NumeroOS = CPCDOS_INSTANCE._MAX_NOMBRE_OS
				
					DEBUG("[CpcdosC+] Starting without OS GUI [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				
				_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)
				
			End if
			
			' Line Commande / Ligne de Commandes
			IF instr(ucase(Param), "/LC+") > 0 OR instr(ucase(Param), "/CONSOLE+") > 0 Then
				Param = ""
					DEBUG("[CpcdosC+] Opening GUI console", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("exe/ " & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CONSOLE", 4, _CLE_), _CLE_, NIVEAU_CCP, Param_1, Param_2)
				
				exit _scope_CMD, _scope
			End if
			
			IF instr(ucase(Param), "/LC") > 0 OR instr(ucase(Param), "/CONSOLE") > 0 Then
				Dim SCR_MODE as integer
				
					DEBUG("[CpcdosC+] Going to Console mode...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			
				SCR_MODE = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("SCR_MODE", 4, _CLE_))

				' Resolution en mode console
				CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_Resolution(SCR_MODE)
				exit _scope_CMD, _scope
			End if
			
			if instr(ucase(Param), "/DISPLAY-BLACKLIST-EVENTS") > 0 Then
				' Reset la black list des evenements not found
				
					DEBUG("[CpcdosC+] List of not found graphic event functions :", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				dim List_noire as string = CPCDOS_INSTANCE.SCI_INSTANCE.Event_Liste_Noire
				dim fonction as string = ""
				For b as integer = 1 to 128
					fonction = Mid(List_noire, 1, instr(List_noire, ";") - 1)
					List_noire = Mid(List_noire, instr(List_noire, ";") + 1)
					DEBUG(" [" & b &"] " & fonction, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					if len(List_noire) < 5 Then exit for
				next b
				
					DEBUG("[CpcdosC+] End of list", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				exit _scope_CMD, _scope
			End if
			
			if instr(ucase(Param), "/RESET-BLACKLIST-EVENTS") > 0 Then
				' Reset la black list des evenements not found
				
				CPCDOS_INSTANCE.SCI_INSTANCE.Event_Liste_Noire = ""
				
					DEBUG("[CpcdosC+] Events black list has been emptied.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				exit _scope_CMD, _scope
			End if

			IF instr(ucase(Param), "/IMGUI") > 0 Then
				CPCDOS_INSTANCE.SCI_INSTANCE.IMGUI_mode = true
			end if

			
			IF instr(ucase(Param), "/OS") > 0 Then
				Dim NomOS as String = Mid(Ucase(Param), instr(ucase(Param), "/OS") + 4)

				IF NOT NomOS = "" Then
					NomOS = Ltrim(Rtrim(Rtrim(Ltrim(NomOS)), chr(09)), chr(09))
					NumeroOS = CPCDOS_INSTANCE.test_OSPresent(ucase(NomOS))
		

					IF NumeroOS <> -1 Then
					
						_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)

							DEBUG("[CpcdosC+] Starting '" & NomOS & "' GUI [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
					End if
				Else
					Message_erreur = ERRAVT("ERR_049", 0)
						DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". No OS name specified from '/OS' argument", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
			Else
				
				NumeroOS = Auth_OS
				
				IF CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() > 1 Then
					' S'il y a plusieurs OS, et que le nom n'a pas ete specifie, alors on prend la cle courant
						DEBUG("[CpcdosC+] " & CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() & " OS in execution, starting current OS GUI [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				Else
					_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)
					
						DEBUG("[CpcdosC+] No OS in execution, starting empty OS GUI [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				End if
			End if
			
			
			
			DEBUG("[CpcdosC+] [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			if NumeroOS < 0 Then
				Message_erreur = ERRAVT("ERR_049", 0)
					DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". No existing OS name specified from '/OS' argument", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			else
			
				if CPCDOS_INSTANCE.SCI_INSTANCE.IMGUI_mode = true Then
					if CPCDOS_INSTANCE.SCI_INSTANCE.Initialiser_GUI__ImGUI(0, RetourVAR, _CLE_) = 1 then
							DEBUG("[CpcdosC+] ImGUI graphic interface initialised!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					else

						Message_erreur = ERRAVT("ERR_049", 0)
							DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". Unable to initialise the ImGUI", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					End if
				else

					if CPCDOS_INSTANCE.SCI_INSTANCE.Initialiser_GUI(0, RetourVAR, _CLE_) = 1 then
							DEBUG("[CpcdosC+] Graphic interface initialised!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
						
						
					else
						Message_erreur = ERRAVT("ERR_049", 0)
							DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". Unable to initialise the GUI", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					end if
				End if
			End if ' Si numero OS < 0

			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** IUG/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer une fenetre
		' ===============================================================
		CommLang(2) = "window/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " window/                    Create or manage new graphic"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
					Mess_Aide = Mess_Aide & CRLF & "  'Window'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new window instance"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Size up window"
					Mess_Aide = Mess_Aide & CRLF & "   window/ /sizeup My_window"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Sizedown window"
					Mess_Aide = Mess_Aide & CRLF & "   window/ /sizedown My_window"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Reduct window"
					Mess_Aide = Mess_Aide & CRLF & "   window/ /reduct My_window"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Window/ My_window"
					' Mess_Aide = Mess_Aide & CRLF & "   		PID				= " & CHR(34) & "" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Title			= " & CHR(34) & "My first window!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "200" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "150" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters			= " & CHR(34) & "1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.WindowColor		= " & CHR(34) & "200,150,250" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TitleColor 		= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Icon			= " & CHR(34) & "C:\directory\icon.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TitleImg		= " & CHR(34) & "C:\directory\TitleIMG.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Window"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Button/ , Picturebox/ , Textblock/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomFenetre as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			' Agrandir la fenetre
			IF INSTR(UCASE(NomFenetre), "/SIZEUP") > 0 Then
				NomFenetre = ucase(MID(NomFenetre, INSTR(UCASE(NomFenetre), "/SIZEUP") + 8))

				for INDEX_FENETRE as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet.Nom) = NomFenetre Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							CPCDOS_INSTANCE.SCI_INSTANCE.Sizing_window_button(true, index_fenetre)	

							exit for
						end if
					End if
				Next INDEX_FENETRE

			ElseIF INSTR(UCASE(NomFenetre), "/SIZEDOWN") > 0 Then
				NomFenetre = ucase(MID(NomFenetre, INSTR(UCASE(NomFenetre), "/SIZEDOWN") + 10))

				for INDEX_FENETRE as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet.Nom) = NomFenetre Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							CPCDOS_INSTANCE.SCI_INSTANCE.Sizing_window_button(false, index_fenetre)	

							exit for
						end if
					End if
				Next INDEX_FENETRE
			ElseIF INSTR(UCASE(NomFenetre), "/RESTAURE") > 0 Then
				NomFenetre = ucase(MID(NomFenetre, INSTR(UCASE(NomFenetre), "/RESTAURE") + 10))

				for INDEX_FENETRE as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet.Nom) = NomFenetre Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 

								DEBUG("[SCI] Window restauration (" & INDEX_FENETRE & ") " & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet.Nom, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SCI_INSTANCE.RetourVAR)


							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).PROP_TYPE.Reduit = true
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)

						end if
					End if
				next INDEX_FENETRE
			ElseIF INSTR(UCASE(NomFenetre), "/REDUCT") > 0 Then

				NomFenetre = ucase(MID(NomFenetre, INSTR(UCASE(NomFenetre), "/REDUCT") + 8))
					
				for INDEX_FENETRE as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet.Nom) = NomFenetre Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
					
								DEBUG("[SCI] Window minimization (" & INDEX_FENETRE & ") " & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).Identification_Objet.Nom, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SCI_INSTANCE.RetourVAR)
							

							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_FENETRE).PROP_TYPE.Reduit = false
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)
						End if
					End if
				Next INDEX_FENETRE
			
			ElseIF INSTR(UCASE(NomFenetre), "/MODIF") > 0 Then
				NomFenetre = MID(NomFenetre, INSTR(UCASE(NomFenetre), "/MODIF") + 7) & "~MODIF#"
				
					DEBUG("[CpcdosC+] Window edition mode '" & NomFenetre & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				CpcdosCP_SHELL = "IUG:FENETRE_NOM=" & NomFenetre
			Else
					DEBUG("[CpcdosC+] Creating window '" & NomFenetre & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				CpcdosCP_SHELL = "IUG:FENETRE_NOM=" & NomFenetre
			End if
			
			
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** FENETRE/ ****
		
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer une picturebox
		' ===============================================================
		CommLang(2) = "picturebox/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " picturebox/                Create new picturebox instance"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'PictureBox'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new picturebox instance in existing window handle (eg:123456789)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Picturebox/ My_picture_box"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "040,150,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\directory\dog.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Picturebox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Window/ , Button/ , Textblock/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomImageBox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomImageBox), "/MODIF") > 0 Then
				NomImageBox = MID(NomImageBox, INSTR(UCASE(NomImageBox), "/MODIF") + 7) & "~MODIF#"
				
					DEBUG("[CpcdosC+] Picturebox edition mode '" & NomImageBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating picturebox '" & NomImageBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			

			CpcdosCP_SHELL = "IUG:PICTUREBOX_NOM=" & NomImageBox
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** PICTUREBOX/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer un bouton
		' ===============================================================
		CommLang(2) = "button/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " button/                    Create new button instance."
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Button'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new button instance in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Button/ My_picture_box"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.text				= " & CHR(34) & "Click me!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "60" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\directory\button_image.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Button"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , window/ , textblock/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomBouton as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomBouton), "/MODIF") > 0 Then
				NomBouton = MID(NomBouton, INSTR(UCASE(NomBouton), "/MODIF") + 7) & "~MODIF#"

					DEBUG("[CpcdosC+] Button edition mode '" & NomBouton & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating button '" & NomBouton & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
		

			CpcdosCP_SHELL = "IUG:BOUTON_NOM=" & NomBouton
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** BOUTON/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer un textebloc
		' ===============================================================
		CommLang(2) = "textblock/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " textblock/                 Create new textblock instance."
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		
		
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Textblock'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new textblock instance in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Textblock/ My_Text"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Bonjour, voici mon texte%CPC.CRLF%Et hop un retour a la ligne!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Textblock"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF & "  BORD:0	 = (Default) no border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:1	 = Display black border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:2	 = Display textblock with 3D effect"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , bouton/ , window/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomTextebloc as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomTextebloc), "/MODIF") > 0 Then
				NomTextebloc = MID(NomTextebloc, INSTR(UCASE(NomTextebloc), "/MODIF") + 7) & "~MODIF#"

					DEBUG("[CpcdosC+] TextBlock edition mode '" & NomTextebloc & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating TextBlock '" & NomTextebloc & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			CpcdosCP_SHELL = "IUG:TEXTEBLOC_NOM=" & NomTextebloc
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** TexteBloc/ ****
		
		
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer un textebox
		' ===============================================================
		CommLang(2) = "textbox/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " textbox/                   Create new editable text box instance."
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		
		
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Textblock'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new editable text area in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Getting textbox text"
					Mess_Aide = Mess_Aide & CRLF & "   Textbox/ /text My_Textbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Textbox focus"
					Mess_Aide = Mess_Aide & CRLF & "   Textbox/ /focus My_Textbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Textbox/ My_Textbox"
					Mess_Aide = Mess_Aide & CRLF & "   		.Handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "My editable text area" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Textbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF & "  BORD:0	 = No border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:1	 = Display black border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:2	 = (Default) Display textblock with 3D effect"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , bouton/ , window/ textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomTextebox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			' Afficher le texte du textbox
			IF INSTR(UCASE(NomTextebox), "/FOCUS") > 0 Then
				NomTextebox = ucase(MID(NomTextebox, INSTR(UCASE(NomTextebox), "/FOCUS") + 7))
				
				for INDEX_Textbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom) = NomTextebox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							' Display !

							DEBUG("[CpcdosC+] FOCUS Textbox(" & INDEX_Textbox & ") '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom & " KeyID " & _cle_win_Auth_Kernel, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
							dim _INDEX_FENETRE_ as integer = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Index_FNT_PARENT
							
							' On indique qu'on FOCUS un Textbox
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).OBJET_FOCUS_TYPE = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox
							
							' Avec son index
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).OBJET_FOCUS_INDEX = INDEX_Textbox

							' Derni�re position
							CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).PROP_TYPE.UserEdit_Pos = Len(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte)
						

							
							exit for
						end if
					End if
				Next INDEX_Textbox
			' Afficher le texte du textbox
			ElseIF INSTR(UCASE(NomTextebox), "/TEXT") > 0 Then
				NomTextebox = ucase(MID(NomTextebox, INSTR(UCASE(NomTextebox), "/TEXT") + 6))
				
				for INDEX_Textbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Identification_Objet.Nom) = NomTextebox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_Textbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 
							' Display !
							DEBUG(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(INDEX_Textbox).Texte, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
							exit for
						end if
					End if
				Next INDEX_Textbox

			ElseIF INSTR(UCASE(NomTextebox), "/MODIF") > 0 Then
				NomTextebox = MID(NomTextebox, INSTR(UCASE(NomTextebox), "/MODIF") + 7) & "~MODIF#"

					DEBUG("[CpcdosC+] TextBox edition mode '" & NomTextebox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				CpcdosCP_SHELL = "IUG:TEXTEBOX_NOM=" & NomTextebox
			Else
					DEBUG("[CpcdosC+] Creating TextBox '" & NomTextebox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				CpcdosCP_SHELL = "IUG:TEXTEBOX_NOM=" & NomTextebox
			End if
			
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** TexteBox/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer une barre de progression
		' ===============================================================
		
		CommLang(2) = "progressbar/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " ProgressBar/               Create new progress bar instance"
			
		END IF
		
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'ProgressBar'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new progress bar instance in existing window handle (eg:123456789)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   ProgressBar/ MyProgressBar"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "400" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "040,150,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Value				= " & CHR(34) & "40" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Text				= " & CHR(34) & "Progression 40%" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "barimage.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ ProgressBar"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) No stretching during progression"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y object size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to stretching source image during progression"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Window/ , Button/ , Textblock/ , textbox/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomProgressBar as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomProgressBar), "/MODIF") > 0 Then
				NomProgressBar = MID(NomProgressBar, INSTR(UCASE(NomProgressBar), "/MODIF") + 7) & "~MODIF#"
				
					DEBUG("[CpcdosC+] Progress bar edition mode '" & NomProgressBar & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating progress bar '" & NomProgressBar & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if

			CpcdosCP_SHELL = "IUG:PROGRESSBAR_NOM=" & NomProgressBar
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** ProgressBar/ ****
		
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer un checkbox
		' ===============================================================
		CommLang(2) = "checkbox/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " checkbox/                  Create new check box instance"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'ProgressBar'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new check box instance in existing window handle (eg:123456789)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   CheckBox/ MyCheckbox"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "COL:0 IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "0" & CHR(34) & "    -> managed by 'IMGAUTO:1'"
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "0" & CHR(34) & "    -> managed by 'IMGAUTO:1'"
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "040,150,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Value				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Text				= " & CHR(34) & "Check me!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ CheckBox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  COL:0     = (By default) No drawing back color"
					Mess_Aide = Mess_Aide & CRLF & "  COL:1     = Draw the back color from '.BackColor' property"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = Use TX and TY dimentions"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Use the text length"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Window/ , Button/ , Textblock/ , textbox/ , ProgressBar/"
					Mess_Aide = Mess_Aide & CRLF
				

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomCheckBox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomCheckBox), "/MODIF") > 0 Then
				NomCheckBox = MID(NomCheckBox, INSTR(UCASE(NomCheckBox), "/MODIF") + 7) & "~MODIF#"
				
					DEBUG("[CpcdosC+] Checkbox edition mode '" & NomCheckBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating checkbox '" & NomCheckBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if

			CpcdosCP_SHELL = "IUG:CHECKBOX_NOM=" & NomCheckBox
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** CheckBox/ ****
		
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer un explorateur de fichiers
		' ===============================================================
		CommLang(2) = "explorer/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " explorer/                  Create new explorer instance."
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Explorer'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new file explorer instance in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Explorer/ my_explorer"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.text				= " & CHR(34) & "c:\folder" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "80" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\folder\background.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Explorer"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , window/ , textblock/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomExplorer as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomExplorer), "/MODIF") > 0 Then
				NomExplorer = MID(NomExplorer, INSTR(UCASE(NomExplorer), "/MODIF") + 7) & "~MODIF#"

					DEBUG("[CpcdosC+] Explorer edition mode '" & NomExplorer & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating explorer '" & NomExplorer & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
		

			CpcdosCP_SHELL = "IUG:EXPLORER_NOM=" & NomExplorer
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** EXPLORER/ ****
	
	_end_scope_CMD

	_scope_CMD
	
		' ===============================================================
		'  Commande pour creer un explorateur de fichiers
		' ===============================================================
		CommLang(2) = "listbox/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " listbox/                  Create new listbox instance."
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Listbox'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create listbox instance in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Getting selected item name"
					Mess_Aide = Mess_Aide & CRLF & "   listbox/ /selected_name My_listbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Getting selected item index"
					Mess_Aide = Mess_Aide & CRLF & "   listbox/ /selected_index My_listbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   listbox/ my_listbox"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.text				= " & CHR(34) & "item 1;item2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "80" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\folder\background.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ listbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , window/ , textblock/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Enlever les espaces et mettre tout en majuscules
			Dim NomListbox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF INSTR(UCASE(NomListbox), "/SELECTED_INDEX") > 0 Then
				NomListbox = ucase(MID(NomListbox, INSTR(UCASE(NomListbox), "/SELECTED_INDEX") + 16))
				
				for INDEX_listbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(INDEX_listbox).Identification_Objet.Nom) = NomListbox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_listbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_listbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_listbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 

							' Afficher l'index de l'item
							DEBUG(str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(INDEX_listbox).SELECTIONNE_index - 1), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit for

						end if
					End if
				Next INDEX_listbox
			Elseif INSTR(UCASE(NomListbox), "/SELECTED_NAME") > 0 Then
				NomListbox = ucase(MID(NomListbox, INSTR(UCASE(NomListbox), "/SELECTED_NAME") + 15))
				
				for INDEX_listbox as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX

					if ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(INDEX_listbox).Identification_Objet.Nom) = NomListbox Then

						Dim _cle_win_Auth_Kernel			as uinteger = CPCDOS_INSTANCE.get_id_kernel		(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_listbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_OS				as uinteger = CPCDOS_INSTANCE.get_id_OS			(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_listbox).Identification_Objet._CLE_)
						Dim _cle_win_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(INDEX_listbox).Identification_Objet._CLE_)

						if _cle_win_Auth_Kernel = Auth_Kernel AND _cle_win_Auth_OS = Auth_OS AND _cle_win_Auth_Utilisateur = Auth_Utilisateur Then 

							' Afficher le nom de l'item
							DEBUG(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(INDEX_listbox).SELECTIONNE_str, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit for

						end if
					End if
				Next INDEX_listbox

			elseif INSTR(UCASE(NomListbox), "/MODIF") > 0 Then
				NomListbox = MID(NomListbox, INSTR(UCASE(NomListbox), "/MODIF") + 7) & "~MODIF#"

					DEBUG("[CpcdosC+] Listbox edition mode '" & NomListbox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			Else
					DEBUG("[CpcdosC+] Creating listbox '" & NomListbox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
		

			CpcdosCP_SHELL = "IUG:LISTBOX_NOM=" & NomListbox
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** Listbox/ ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande pour rafraichir un objet ou une fenetre
		' ===============================================================
		CommLang(2) = "refresh/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " refresh/                   Refresh an GUI object, window or background"
			
		END IF
		
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Refresh'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to refresh graphically an object in a window, or window, or"
					Mess_Aide = Mess_Aide & CRLF & "    background interface"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   This command is useful in the case monor modification on gui object"
					Mess_Aide = Mess_Aide & CRLF & "    or graphic background. Or .. patch eventual problem."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :" 
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh window from property name"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ my_window"
					Mess_Aide = Mess_Aide & CRLF & "   or from his handle number"
					Mess_Aide = Mess_Aide & CRLF & "'    refresh/ /handle 01234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh graphic object from his name"
					Mess_Aide = Mess_Aide & CRLF & "     /!\ Seulement si la commande se trouve dans le meme TID/PID"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ My_Textbox"
					Mess_Aide = Mess_Aide & CRLF & "   Otherwise, you must to use his handle number."
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /handle 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh ALL windows"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /window"
					Mess_Aide = Mess_Aide & CRLF & "   or"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /windows"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh only NO FOCUS windows (in the background)"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /window /nofocus "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh only FOCUS windows (in foreground)"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /window /focus"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh background image (wallpaper)"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /image"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh ALL !"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /all"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : close/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Dim TypeOjetNOM		as String
			Dim Numero_INDEX	as integer = 0
			Dim TypeObjet		as integer = 0
			DIM Numero_Handle 	as integer = 0

			
			Dim PosNUMhandle as integer = instr(UCASE(Param), "/HANDLE") ' Handle
			Dim PosFenetre as integer = instr(UCASE(Param), "/FENETRE") ' Fenetres
			Dim PosWindow as integer = instr(UCASE(Param), "/WINDOW") ' Fenetres
			Dim PosFocus as integer = instr(UCASE(Param), "/FOCUS") ' Fenetre focus
			Dim PosNonFocus as integer = instr(UCASE(Param), "/NONFOCUS") ' Fenetres non focus
			Dim PosNoFocus as integer = instr(UCASE(Param), "/NOFOCUS") ' Fenetres non focus
			Dim PosImage as integer = instr(UCASE(Param), "/IMAGE") ' Wallpaper
			Dim PosTOUT as integer = instr(UCASE(Param), "/TOUT") ' TOUT
			Dim PosALL as integer = instr(UCASE(Param), "/ALL") ' TOUT
			
			if PosFenetre > 0 OR PosWindow > 0 Then
				if PosFocus > 0 Then ' Actualiser uniquement la fenetre focus
					' Recuperer l'index de la fenetre focus actuel
					Numero_INDEX = CPCDOS_INSTANCE.SCI_INSTANCE.Fenetre_FOCUS(0)
					TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre
					
				elseif PosNonFocus > 0 OR PosNoFocus Then
					' Actualiser tout sauf celui focus
					Numero_INDEX =  CPCDOS_INSTANCE.SCI_INSTANCE.Fenetre_FOCUS(0) 
					TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TOUT
					
				Else
					' Actualiser toutes les fenetres
					
					Numero_INDEX = 99999
					TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre
				End if
			ElseIF PosImage > 0 Then 
				' Actualiser l'arriere plan
				
				Numero_INDEX = 99999
				TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Wallpaper
			
			ElseIF PosTOUT > 0 OR PosALL > 0 Then 
				' Actualiser absolument Tout
				
				Numero_INDEX = 99999
				TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TOUT


			' ===== Numero Handle =====
			ElseIF PosNumHandle > 0 Then ' Numero de handle
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_Handle = Val("&h" & MID(Param, PosNumHandle + 8))
				else
					' Nombre decimal
					Numero_Handle = Val(MID(Param, PosNumHandle + 8))
				End if
			End if
			

			If Numero_Handle > 0 Then
				' Supprimer l'objet correspondant au handle
				
				TypeObjet = 0
		
				' Chercher les fenetres
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Handle = Numero_Handle Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				
				if TypeObjet = 0 Then
				
					' Chercher les boutons
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les picturebox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les textbloc
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les TextBox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les checkbox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les Progressbar
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				End if
				
				
				if TypeObjet = 0 Then
				
					' Chercher les Explorer
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_EXPLORER
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if

				if TypeObjet = 0 Then
				
					' Chercher les listbox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_Listbox
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Listbox
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
			
			Else

				IF NOT Param = "" Then
					Dim Trouve as boolean = false
	
					' Si les parametres ont quelque chose on cherche par le nom
					
					' Nettoyer
					Param = Ucase(RTRIM(RTRIM(LTRIM(LTRIM(Param, chr(09))), chr(09))))
					
					' Chercher les fenetres
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Nom = Param Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre
							
							' Et son numero d'index
							Numero_INDEX = boucle

							Trouve = true

							
							exit for
						End if
					Next boucle
					
				
				
					if Trouve = false Then
						' Chercher les boutons
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if Trouve = false Then
						' Chercher les picturebox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if Trouve = false Then
						' Chercher les textbloc
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if Trouve = false Then
						' Chercher les TextBox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if Trouve = false Then
						' Chercher les checkbox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if Trouve = false Then
						' Chercher les Progressbar
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
					
					if Trouve = false Then
						' Chercher les explorer
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_EXPLORER
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if

					if Trouve = false Then
						' Chercher les listbox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Listbox
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if

				Else
				
					' L'utilisateur n'a rien indique
					Message_erreur = ERRAVT("AVT_078", 0)
						DEBUG("[CpcdosC+] AVT_078 : " & Message_erreur & ". Please put name or parameter.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
			End if
			
			' Si on a trouve quelque chose
			if Numero_INDEX > 0 Then


				IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then

					If TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TOUT Then
						' Si l'interface graphique est executee


						IF Numero_INDEX = 99999 Then
							' Actualiser absolument TOUT !
							Flip 3, 2 ' + Ajouter desktop background si possible

							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)
							
						Else
							' Actualiser TOUT SAUF UNE fenetre
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(2, Numero_INDEX)
						End if
					
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.WALLPAPER Then
						' Actualiser l'arriere plan
						CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(3, 0)
						
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre Then
						' Si l'interface graphique est executee
						IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then
						
						
							IF Numero_INDEX = 99999 Then
								' Actualiser TOUTES les fenetres
								
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										DEBUG("[CpcdosC+] Refreshing all graphic window ...'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									
								End if

								CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, Numero_INDEX)
							Else
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										DEBUG("[CpcdosC+] Refreshing window graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									
								End if
								
								' Actualiser une fenetre
								CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, Numero_INDEX)
							End if
						End if
						
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing button graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_Bouton(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PictureBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing picturebox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_Picturebox(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)
						
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBlock Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing textbloc graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBlock(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)
					
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing textbox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBox(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)
					
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing progressbar graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_ProgressBar(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)
					
					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing checkbox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_CheckBox(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing explorer graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_Explorer(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ListBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Refreshing listbox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
						
						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_Listbox(Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)
					End if
					
				End if
			Else
				' Si on n'a pas trouve quelque chose
				Message_erreur = ERRAVT("AVT_077", 0)
					DEBUG("[CpcdosC+] AVT_077 : " & Message_erreur & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
	
			' ===================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** Actualiser/ ****
		
	_end_scope_CMD
	
	_scope_CMD
		' ===============================================================
		'  Commande de decompression
		' ===============================================================
		CommLang(2) = "decompress/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " decompress/                Decompress an ZIP file"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'Decompress'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to decompress ZIP, gz ... files"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   decompress/ MyFile.zip   (By default in the TEMP folder)"
					Mess_Aide = Mess_Aide & CRLF & "   decompress/ MyFile.zip MyFolder"
					Mess_Aide = Mess_Aide & CRLF & "   decompress/ MyFolder/MyFile.zip MyFolder/temp"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			
			SCOPE
			' ====================================================================
			Dim Resultat as integer
			
			
			Dim Source 		as String
			Dim Destination as String
			
			
			
			Param = Rtrim(Param)
			
			
			IF INSTR(Param, ", ") > 0 Then 
				Source 		= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, ", ") - 1)), CHR(09))), CHR(09))
				Destination	= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, ", ") + 2)), CHR(09))), CHR(09))
			else
				IF INSTR(Param, " ") > 0 Then 
					Source 		= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, " ") - 1)), CHR(09))), CHR(09))
					Destination	= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, " ") + 1)), CHR(09))), CHR(09))
				else
					Source 		= Rtrim(Rtrim(Ltrim(Ltrim(Param)), CHR(09)), CHR(09))
					Destination = "temp"
				End if
			End if

			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] File uncompressing '" & Source & "' to '" & Destination & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF
			

			Resultat = CPCDOS_INSTANCE.Fichier_decompress(Source, Destination) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS
			
			If Resultat < 1 Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
					DEBUG("[CpcdosC+] The file '" & Param & "' has been uncompressed!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)

			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** UNCOMPRESS/ ****
	
	_end_scope_CMD	
	
	
	' =======================================================================================
	'  	*******************                  Propriete GUI             ********************  
	' =======================================================================================
	
	_scope_CMD
	
		CommLang(2) = ".title"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> Title              Put title on Window"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
					Mess_Aide = Mess_Aide & CRLF & "  '.Title'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, as window"
					Mess_Aide = Mess_Aide & CRLF & "    allow to name title bar of window"
					Mess_Aide = Mess_Aide & CRLF 
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TITRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .TITRE ****

	_end_scope_CMD
		
	
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".name"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> name               Process / Object name"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.Title'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to name"
					Mess_Aide = Mess_Aide & CRLF & "    your process if it's a window, and instance name if it's an object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_NOM=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .NOM ****
	
	_end_scope_CMD
	
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".text"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> text               Graphic text object"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.Text'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to include"
					Mess_Aide = Mess_Aide & CRLF & "    text in your graphical object who support this."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TEXTE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .TEXTE ****

	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".pid"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> pid                Parent/host process number"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.ProcessIDentification'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to select"
					Mess_Aide = Mess_Aide & CRLF & "    parent process. This allow you to hosting your window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is NULL"
					Mess_Aide = Mess_Aide & CRLF & "   - For a window, it takes executive thread PID parent number."
					Mess_Aide = Mess_Aide & CRLF & "   - For an object, IDEM, but only if handle number match with window handle."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)  
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_PID=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .PID ****
		
	_end_scope_CMD
		
	_scope_CMD
		
		' =======================================================================
		CommLang(2) = ".handle"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> handle             Parent/host process number"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.Handle'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to select"
					Mess_Aide = Mess_Aide & CRLF & "    handle window (for hosting objects). Works only if handle number match with a window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is NULL"
					Mess_Aide = Mess_Aide & CRLF & "   - For a window, her will hosted on desktop handle."
					Mess_Aide = Mess_Aide & CRLF & "   - For an object, an error will occur. An object must hosted on window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_HANDLE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .HANDLE ****
		
	_end_scope_CMD
		
	_scope_CMD
		
		' =======================================================================
		CommLang(2) = ".value"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> Value              Expected object value"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.Value'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to put"
					Mess_Aide = Mess_Aide & CRLF & "    an expected value"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is NULL, the value will be to '0'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'ProgressBar/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/ , button/ , window/ "
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:VALEUR=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .VALEUR ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".parameters"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> type               Graphic window type"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.Parameters'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    parameters for object or window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  This is type of window."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:1 : Normal window (BY DEFAULT)"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:2 : Window without visible contener."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:3 : Window without bitmap tible visible."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:4 : Window without visible contener and visible bitmap."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:5 : Window without title bar."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:6 : Window without title bar and without visible contener."
					Mess_Aide = Mess_Aide & CRLF & "   - BORD:1    : Border arround window. (BY DEFAULT)"
					Mess_Aide = Mess_Aide & CRLF & "   - BORD:0    : Without border arround window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  For a picturebox"
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:0 : Normal displaying (BY DEFAULT)"
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:1 : Displaying with picturebox dimentions who adapts with image dimentions."
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:2 : Displaying with image dimentions who adapts with picturebox dimentions."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TYPE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .PARAMETRES ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".windowcolor"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> windowcolor        Window color"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.WindowColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    a general window color in RGB."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be gray/white color. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   WindowColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURFENETRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURFENETRE ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' =======================================================================
		CommLang(2) = ".backcolor"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> windowcolor        Window container color"
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.WindowColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    The color of the window of container."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be gray color. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   WindowColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURFOND=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURFOND ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".titlecolor"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> windowcolor        Color of title of the windows"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.TitleColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the color of title in window title bar."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be black. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   TitleColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURTITRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURTITRE ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' =======================================================================
		CommLang(2) = ".textcolor"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> textcolor          Color of title of the windows"
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.TitleColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the color of text in gui object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be black. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   TextColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURTEXTE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURTEXTE ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".icon"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> icon               Window icon"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.ICON'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the icon of your window. PNG, JPG and BMP formats are accepted! The recommanded"
					Mess_Aide = Mess_Aide & CRLF & "    resolution is 16x16. If this resolution is not respected, Cpcdos will"
					Mess_Aide = Mess_Aide & CRLF & "    re-work automatically for adapting your icon."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, your window will use default icon ICO_DEF.PNG"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:ICONE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .ICONE ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".titleimg"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> titleimg           background image of title"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.TITLEIMG'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the image background of your title bar of you window."
					Mess_Aide = Mess_Aide & CRLF & "    PNG, JPG and BMP formats are accepted!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, the title bar will be transparently"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour 
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:IMGTITRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .IMGTITRE ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".image"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> image              Container image" 
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.IMAGE'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the image in your container for your objects or your window"
					Mess_Aide = Mess_Aide & CRLF & "    PNG, JPG and BMP formats are accepted!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, container remains neutral."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:IMAGE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** .IMAGE ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' =======================================================================
		CommLang(2) = ".opacity"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> opacity            Window/object opacity" 
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.OPACITY'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    transparency of your window or gui elements"
					Mess_Aide = Mess_Aide & CRLF & "     Values 0:Transparent <--> 255:Opaque"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, the default value is 255"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_ALPHA=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .OPACITE ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".px"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> px                 Horizontal position"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.PositionX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the horizontal position of your window in horizontal screen area"
					Mess_Aide = Mess_Aide & CRLF & "    or an object position in the horizontal area of the window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be positioned in a recursive position."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_PX=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .PX ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".py"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> py                 Vertical position"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.PositionX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the vertical position of your window in vertical screen area"
					Mess_Aide = Mess_Aide & CRLF & "    or an object position in the vertical area of the window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be positioned in a recursive position."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_PY=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .PY ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = ".sx"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> sx                 Horizontal size"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.SizeX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the horizontal size of your window or your object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be sized at '100' pixels"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TX=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .TX ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' =======================================================================
		CommLang(2) = ".sy"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> sy                 Vertical size"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.SizeY'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the vertical size of your window, or object"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be sized at '150' pixels"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TY=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** TY ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' =======================================================================
		CommLang(2) = ".event"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> event              File with events functions"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  '.Event'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to define"
					Mess_Aide = Mess_Aide & CRLF & "    source file, with event content function."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  An event is a graphic ou automatic interaction between objects and user. Example"
					Mess_Aide = Mess_Aide & CRLF & "   when user clic on a button called 'MyButton' with .EVENT propertie defined to 'MyFile.cpc',"
					Mess_Aide = Mess_Aide & CRLF & "   he search this line 'FUNCTION/ MyButton.CLIC()' in 'MyFile.cpc'."
					Mess_Aide = Mess_Aide & CRLF & "   If this file is not found, program continue execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this propertie is not specified, no event will be possible! "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param) 
 			if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_EVENEMENT=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .EVENEMENT ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' =======================================================================
		CommLang(2) = "create/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & "  GUI -> create/            Create initialised window or object"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'CREATE/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to create"
					Mess_Aide = Mess_Aide & CRLF & "    your initialised window or object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Can't be used after 'END/'. Her must be used during properties initialization."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			IF Instr(Param, "/#RENVOIDEBUG:") > 0 Then 
				DEBUG(MID(Param, Instr(Param, "/#RENVOIDEBUG:") + 14), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				CpcdosCP_SHELL = "IUG:CREER!"
			End if
			
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CREER/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		REM ' ===============================================================
		REM '  Commande conditionnelle
		REM ' ===============================================================
		CommLang(2) = "if/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		REM 'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " if/                        Condition with two expressions"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'IF'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to execute code under condition only"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Avaiable conditions :"
					Mess_Aide = Mess_Aide & CRLF & "   =  (Equal)                 N=  ou  !=  (Not equal)"
					Mess_Aide = Mess_Aide & CRLF & "   >  (upper)                 N>  ou  !>  (Not upper)"
					Mess_Aide = Mess_Aide & CRLF & "   <  (lower)                 N<  ou  !<  (Not lower)"
					Mess_Aide = Mess_Aide & CRLF & "   >= (upper ou equal)        N>= ou  !>= (Not upper ou equal)"
					Mess_Aide = Mess_Aide & CRLF & "   <= (lower ou equal)        N<= ou  !<= (Not lower ou equal)"
					Mess_Aide = Mess_Aide & CRLF & "   ~= (Content)			  	  N~= ou  !~= (Not content)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  1.Example (Mono ligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then: txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  2.Simple example (Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "5" & CHR(34) & " = " & CHR(34) & "%Value2%" & CHR(34) & " then:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3.Example (Monoligne with else):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then: txt/ Ok! else:txt/ Faux!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  4.Example (Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "5" & CHR(34) & " = " & CHR(34) & "%Value2%" & CHR(34) & " then:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   else:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Faux!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ pas bien!"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  5.Example (Multiligne/mono):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   else: txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  6.Example (Mono ligne/Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then:txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "   else:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Okai"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			
			' AJOUTER : <> Different de


			Dim SI_ResultatCondition		as integer = 0 ' VRAIS / FAUX
			Dim SI_NonVAL					as integer
			Dim SI_RecupASCII_1 			as integer
			Dim SI_RecupASCII_2 			as integer

			Dim LA_Condition				as integer
			Dim Taille_Condition			as integer

			Dim SI_PosEgale 				as integer ' x = y
			Dim SI_PosPasEgale 				as integer ' x N= y
			Dim SI_PosPasEgaleN				as integer ' x != y
			
			Dim SI_PosContient 				as integer ' x ~= y
			Dim SI_PosContientPas			as integer ' x N~= y

			Dim SI_PosSuperieur				as integer ' x > y
			Dim SI_PosInferieur				as integer ' x < x

			Dim SI_PosEgaleSuperieur		as integer ' x => x
			Dim SI_PosEgaleInferieur		as integer ' x =< x

			Dim SI_PosPasSuperieur			as integer ' x N> x
			Dim SI_PosPasInferieur			as integer ' x N< x

			Dim SI_PosPasEgaleSuperieur		as integer ' x N=> x  ou
			Dim SI_PosPasEgaleInferieur		as integer ' x N=< x  ou

			Dim SI_PosAlors					as integer ' alors:   ou   then:
			Dim SI_PosAlorsREV				as integer ' alors:   ou   then:
			Dim SI_Alors_T					as integer
			Dim SI_PosSinon					as integer ' sinon:   ou   else:
			Dim SI_Sinon_T					as integer

			Dim SI_POSGuil_EXP_1			as integer
			Dim SI_POSGuil_EXP_2			as integer

			Dim SI_Expression_1				as string ' x
			Dim SI_Expression_2				as string ' y

			SI_PosAlors = Instr(UCASE(Param), "ALORS:") : SI_Alors_T = 5
			if NOT SI_PosAlors > 0 then SI_PosAlors = Instr(UCASE(Param), "THEN:") : SI_Alors_T = 4

			SI_PosAlorsREV = InstrREV(UCASE(Param), "ALORS:")
			if NOT SI_PosAlorsREV > 0 then SI_PosAlorsREV = InstrREV(UCASE(Param), "THEN:")
			IF SI_PosAlors = SI_PosAlorsREV then
				' Si il y a que 1 seul ALORS:, alors on s'approprie le SINON: si present
				'  Sinon il sera reserve pour le prochain SI/
				SI_PosSinon = Instr(UCASE(Param), "SINON:") : SI_Sinon_T = 5
				if NOT SI_PosSinon > 0 then SI_PosSinon = Instr(UCASE(Param), "ELSE:") : SI_Sinon_T = 4
			End if

			SI_PosEgale 	= Instr(Param, " = ")
			if SI_PosEgale = 0 Then SI_PosEgale = Instr(Param, " == ")
			
			SI_PosPasEgale 	= Instr(Param, " N= ")
			IF NOT SI_PosPasEgale > 0 then SI_PosPasEgale = Instr(Param, " != ") ' Nouveau

			SI_PosSuperieur = Instr(Param, " > ")
			SI_PosInferieur = Instr(Param, " < ")
			SI_PosEgaleSuperieur = Instr(Param, " >= ")
			SI_PosEgaleInferieur = Instr(Param, " <= ")
			
			SI_PosContient = Instr(Param, " ~= ")
			SI_PosContientPas = Instr(Param, " N~= ")
			IF NOT SI_PosContientPas > 0 Then SI_PosContientPas = Instr(Param, " !~= ") ' Nouveau
			
			SI_PosPasSuperieur = Instr(Param, " N> ") ' Ancien
			IF NOT SI_PosPasSuperieur > 0 Then SI_PosPasSuperieur = Instr(Param, " !> ") ' Nouveau

			SI_PosPasInferieur = Instr(Param, " N< ") ' Ancien
			IF NOT SI_PosPasInferieur > 0 Then SI_PosPasInferieur = Instr(Param, " !< ") ' Nouveau

			SI_PosPasEgaleSuperieur = Instr(Param, " N>= ") ' Ancien
			IF NOT SI_PosPasEgaleSuperieur > 0 Then SI_PosPasEgaleSuperieur = Instr(Param, " !>= ") ' Nouvea

			SI_PosPasEgaleInferieur = Instr(Param, " N<= ") ' Ancien
			IF NOT SI_PosPasEgaleInferieur > 0 then SI_PosPasEgaleInferieur = Instr(Param, " !<= ") ' Nouveau

			' Si un autre condition est presente apres le alors:
			if SI_PosAlors > 0 then
				if SI_PosAlors < SI_PosEgale 				then SI_PosEgale = 0
				if SI_PosAlors < SI_PosPasEgale 			then SI_PosPasEgale = 0
				if SI_PosAlors < SI_PosContient 			then SI_PosContient = 0
				if SI_PosAlors < SI_PosContientPas 			then SI_PosContientPas = 0
				if SI_PosAlors < SI_PosSuperieur 			then SI_PosSuperieur = 0
				if SI_PosAlors < SI_PosInferieur 			then SI_PosInferieur = 0
				if SI_PosAlors < SI_PosEgaleSuperieur 		then SI_PosEgaleSuperieur = 0
				if SI_PosAlors < SI_PosEgaleInferieur 		then SI_PosEgaleInferieur = 0
				if SI_PosAlors < SI_PosPasSuperieur 		then SI_PosPasSuperieur = 0
				if SI_PosAlors < SI_PosPasInferieur 		then SI_PosPasInferieur = 0
				if SI_PosAlors < SI_PosPasEgaleSuperieur 	then SI_PosPasEgaleSuperieur = 0
				if SI_PosAlors < SI_PosPasEgaleInferieur 	then SI_PosPasEgaleInferieur = 0
			End if

			IF SI_PosContientPas > 0 Then ' !~=
				LA_Condition = SI_PosContientPas
				Taille_Condition = 5
			elseif SI_PosPasEgaleInferieur > 0 Then ' !<=
				LA_Condition = SI_PosPasEgaleInferieur
				Taille_Condition = 5
			elseif SI_PosPasEgaleSuperieur > 0 Then ' !>=
				LA_Condition = SI_PosPasEgaleSuperieur
				Taille_Condition = 5
			elseif SI_PosPasSuperieur > 0 Then ' !>
				LA_Condition = SI_PosPasSuperieur
				Taille_Condition = 4
			elseif SI_PosPasInferieur > 0 Then ' !<
				LA_Condition = SI_PosPasInferieur
				Taille_Condition = 4
			elseif SI_PosContient > 0 Then ' ~=
				LA_Condition = SI_PosContient
				Taille_Condition = 3
			elseif SI_PosSuperieur > 0 Then ' >
				LA_Condition = SI_PosSuperieur
				Taille_Condition = 3
			elseif SI_PosInferieur > 0 Then ' <
				LA_Condition = SI_PosInferieur
				Taille_Condition = 3
			elseif SI_PosEgaleInferieur > 0 Then ' <=
				LA_Condition = SI_PosEgaleInferieur
				Taille_Condition = 3
			elseif SI_PosEgaleSuperieur > 0 Then ' >=
				LA_Condition = SI_PosEgaleSuperieur
				Taille_Condition = 3
			elseif SI_PosEgale > 0 Then ' =
				LA_Condition = SI_PosEgale
				Taille_Condition = 3
			elseif SI_PosPasEgale > 0 Then ' !=
				LA_Condition = SI_PosPasEgale
				Taille_Condition = 4
			Else
				Message_erreur = ERRAVT("AVT_018", 0)
				DEBUG("CpcdosC+ :" & Message_erreur & ". --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			end if

			' Recuperer les expressions entre le debut , '=' puis 'alors:'
			SI_Expression_1 = MID(Param, 1, LA_Condition - 1)
			SI_Expression_2 = MID(Param, LA_Condition + Taille_Condition, SI_PosAlors - (LA_Condition + Taille_Condition))

			' On recupere la position du premier " et le deuxi�me " pour la PREMIERE expression
			SI_POSGuil_EXP_1 = Instr(SI_Expression_1, CHR(34)) ' guillemet de gauche
			SI_POSGuil_EXP_2 = InstrRev(SI_Expression_1, CHR(34)) ' guillemet de droit

			if SI_POSGuil_EXP_1 < 0 OR _
				SI_POSGuil_EXP_2 < 0 OR _
				SI_POSGuil_EXP_1 = SI_POSGuil_EXP_2 OR _
				SI_POSGuil_EXP_1 > SI_POSGuil_EXP_2 Then
				
				' Erreur de guillemets
				Message_erreur = ERRAVT("AVT_017", 0)
				DEBUG("CpcdosC+ :" & Message_erreur & ". --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
				
			End if

			' *** Recuperer la premiere expression finale ***
			SI_Expression_1 = MID(SI_Expression_1, SI_POSGuil_EXP_1 + 1, (SI_POSGuil_EXP_2 - SI_POSGuil_EXP_1) - 1)


			' On recupere la position du premier " et le deuxi�me " pour la DEUXIEME expression
			SI_POSGuil_EXP_1 =  Instr(SI_Expression_2, CHR(34)) ' guillemet de gauche
			SI_POSGuil_EXP_2 =  Instrrev(SI_Expression_2, CHR(34)) ' guillemet de droit

			' *** Recuperer la deuxieme expression finale ***
			SI_Expression_2 = MID(SI_Expression_2, SI_POSGuil_EXP_1 + 1, (SI_POSGuil_EXP_2 - SI_POSGuil_EXP_1) - 1)

			
			SI_NonVAL = 0
			' Chercher la presence d'une chaine de caractere (et/ou avec exp numerique) ou d'un expression numerique seulement
			for SI_BoucleNB as integer = 1 to Len(SI_Expression_1)
				SI_RecupASCII_1 = ASC(MID(SI_Expression_1, SI_BoucleNB, 1)) ' Recuperer 1 caractere par 1
				IF SI_RecupASCII_1 < 48 Then ' Si plus petit que zero en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				ElseIF SI_RecupASCII_1 > 57 then ' Si plus grand que 9 en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				End if
			next SI_BoucleNB
			
			for SI_BoucleNB as integer = 1 to Len(SI_Expression_2)
				SI_RecupASCII_2 = ASC(MID(SI_Expression_2, SI_BoucleNB, 1)) ' Recuperer 1 caractere par 1

				IF SI_RecupASCII_2 < 48 Then ' Si plus petit que zero en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				ElseIF SI_RecupASCII_2 > 57 then ' Si plus grand que 9 en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				End if
			next SI_BoucleNB
			
			' Tests conditionnels
			IF SI_PosContient > 0 Then
				IF INSTR(SI_Expression_1, SI_Expression_2) > 0 then ' ~=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosContientPas > 0 Then
				IF INSTR(SI_Expression_1, SI_Expression_2) > 0 then ' ~=
					SI_ResultatCondition = 0
				Else
					SI_ResultatCondition = 1
				End if		
			elseif SI_PosPasEgaleInferieur > 0 Then
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF NOT Val(SI_Expression_1) <= val(SI_Expression_2) Then ' !<=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosPasEgaleSuperieur > 0 Then
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF NOT Val(SI_Expression_1) >= val(SI_Expression_2) Then ' !>=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosPasSuperieur > 0 Then
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF NOT Val(SI_Expression_1) > val(SI_Expression_2) Then ' !>
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosPasInferieur > 0 Then
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF NOT Val(SI_Expression_1) < val(SI_Expression_2) Then ' !<
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosSuperieur > 0 Then
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF Val(SI_Expression_1) > val(SI_Expression_2) Then ' >
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosInferieur > 0 Then
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF Val(SI_Expression_1) < val(SI_Expression_2) Then ' <
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosEgaleInferieur > 0 Then '
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF Val(SI_Expression_1) <= val(SI_Expression_2) Then ' <=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosEgaleSuperieur > 0 Then ' >=
				IF SI_NonVAL = 1 then
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				IF Val(SI_Expression_1) >= val(SI_Expression_2) Then ' >=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosEgale > 0 Then ' =

				if SI_NonVAL = 1 then ' Si il a pas que des chiffres
					IF SI_Expression_1 = SI_Expression_2 Then ' Chaine
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				Else ' Si il y a que des chiffres numeriques
					IF Val(SI_Expression_1) = val(SI_Expression_2) Then ' Valeur
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				End if
			elseif SI_PosPasEgale > 0 Then ' !=
				if SI_NonVAL = 1 then ' Si il a pas que des chiffres
					IF NOT SI_Expression_1 = SI_Expression_2 Then ' Chaine
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				Else ' Si il y a que des chiffres numeriques
					IF NOT Val(SI_Expression_1) = val(SI_Expression_2) Then ' Valeur
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				End if
			Else
				Message_erreur = ERRAVT("AVT_018", 0)
				DEBUG("CpcdosC+ :" & Message_erreur & ". --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			end if
			
			' Si le 'alors:' ou 'then:' est manquant alors on renvoie la valeur de la condition
			if NOT SI_PosAlors > 0 then
				DEBUG(str(SI_ResultatCondition), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			End if

			' Test final
			IF SI_ResultatCondition = 1 then
				' La condition est VRAIE
				Dim Commande_A_Executer as string
				if SI_PosSinon > 0 then ' Si le ALORS: ou THEN: et SINON: ou ELSE: sont present sur la meme ligne
					Commande_A_Executer = MID(Param, (SI_PosAlors + SI_Alors_T + 1), SI_PosSinon - (SI_PosAlors + SI_Alors_T + 1))
				Else ' s'il y a seulement ALORS:
					Commande_A_Executer = MID(Param, (SI_PosAlors + SI_Alors_T + 1))
				End if
				IF Len(Commande_A_Executer) > 3 then ' Taille minimale d'une commande
					Dim TestRetouuReuuh as string
					' On execute la commande CCP apres le alors
				
					TestRetouuReuuh = CpcdosCP_SHELL(Commande_A_Executer, _CLE_, NIVEAU_CCP, Param_1, Param_2)
					IF Instr(UCASE(TestRetouuReuuh), "ALLER/ ") > 0 Then
						CpcdosCP_SHELL = TestRetouuReuuh
						exit _scope_CMD, _scope
					End if
				else
					' Sinon on va chercher en mode multiligne
					CpcdosCP_SHELL = "SI:ALORS"
					exit _scope_CMD, _scope
				end if
			ElseIF SI_ResultatCondition = 0 then
				' La condition est FAUSSE

				Dim Commande_A_Executer as string
				IF SI_PosSinon > 0 then ' Si SINON: sur la meme ligne
					Commande_A_Executer = MID(Param, (SI_PosSinon + SI_Sinon_T + 1))
				
					IF Len(Commande_A_Executer) > 3 then ' Taille minimale d'une commande
						' On execute la commande CCP apres le alors
						CpcdosCP_SHELL(Commande_A_Executer, _CLE_, NIVEAU_CCP, Param_1, Param_2)
						
						exit _scope_CMD, _scope
					end if
				else
					' Sinon on va chercher en mode multiligne
					IF len(MID(Param, (SI_PosAlors + SI_Alors_T + 1))) > 3 then 
						CpcdosCP_SHELL = "SI:FAUX"
					else
						CpcdosCP_SHELL = "SI:SINON"
					End if
				End if
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** SI/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Fin d'une fonction
		' ===============================================================
		CommLang(2) = "end/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " end/                       Condition / function delimiter"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'FIN'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow simply to delimit condition or function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   if/ 1 = 1 then:"
					Mess_Aide = Mess_Aide & CRLF & "      Txt/ Vrais"
					Mess_Aide = Mess_Aide & CRLF & "   end/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Function/ Ma_Fonction()"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Coucou!"
					Mess_Aide = Mess_Aide & CRLF & "   end/ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   window/ my_window"
					Mess_Aide = Mess_Aide & CRLF & "     ... {see window/ syntax)"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " See also : Exe/ , IF/ , Function/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					' 3 = On nettoie / Cree la variable avant de le definir comme sortie
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, 0, "") : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite (autorisation d'acces)?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Param = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))
			
			IF Instr(UCASE(Param), "SI") > 0 AND Len(Param) = 2 Then
				CpcdosCP_SHELL = "SI:FIN"
				exit _scope_CMD, _scope
			Elseif Instr(UCASE(Param), "IF") > 0 AND Len(Param) = 2 Then
				CpcdosCP_SHELL = "SI:FIN"
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "FONCTION") > 0 Then
				CpcdosCP_SHELL = "FONCTION:FIN"
				exit _scope_CMD, _scope
			Elseif Instr(UCASE(Param), "FUNCTION") > 0 Then
				CpcdosCP_SHELL = "FONCTION:FIN"
				exit _scope_CMD, _scope
			End if
		
			
			IF Instr(UCASE(Param), "FENETRE") > 0 Then
				CpcdosCP_SHELL = "IUG:FENETRE_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "WINDOW") > 0 Then
				CpcdosCP_SHELL = "IUG:FENETRE_FIN"
				exit _scope_CMD, _scope
			End if
			
			
			IF Instr(UCASE(Param), "BOUTON") > 0 Then
				CpcdosCP_SHELL = "IUG:BOUTON_FIN"
				exit _scope_CMD, _scope
			End if
			IF Instr(UCASE(Param), "BUTTON") > 0 Then
				CpcdosCP_SHELL = "IUG:BOUTON_FIN"
				exit _scope_CMD, _scope
			End if
			
			
			IF Instr(UCASE(Param), "IMAGEBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:PICTUREBOX_FIN"
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "PICTUREBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:PICTUREBOX_FIN"
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "TEXTEBLOC") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBLOC_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "TEXTBLOCK") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBLOC_FIN"
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "TEXTEBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBOX_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "TEXTBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBOX_FIN"
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "BARREPROGRESSION") > 0 Then
				CpcdosCP_SHELL = "IUG:PROGRESSBAR_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "PROGRESSBAR") > 0 Then
				CpcdosCP_SHELL = "IUG:PROGRESSBAR_FIN"
				exit _scope_CMD, _scope
			End if
			
			iF Instr(UCASE(Param), "CHECKBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:CHECKBOX_FIN"
				exit _scope_CMD, _scope
			End if
			
			iF Instr(UCASE(Param), "EXPLORER") > 0 Then
				CpcdosCP_SHELL = "IUG:EXPLORER_FIN"
				exit _scope_CMD, _scope
			End if

			iF Instr(UCASE(Param), "LISTBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:LISTBOX_FIN"
				exit _scope_CMD, _scope
			End if
			
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** FIN/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' ===============================================================
		'  Arreter la lecture d'un fichier CpcdosC+
		' ===============================================================
		CommLang(2) = "stop/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " stop/                      Ending .CPC file"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'STOP'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow simply to stop CpcdosC+ file execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This line will be displayed"
					Mess_Aide = Mess_Aide & CRLF & "   stop/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This line will never be deplayed"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " See also : exe/ , stopk/"
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					' 3 = On nettoie / Cree la variable avant de le definir comme sortie
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, 0, "") : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite (autorisation d'acces)?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			' Param = MID(Commande, CommPosition + TailleComm + 2)
			' ====================================================================
			CpcdosCP_SHELL = "STOP:FIN"
			exit _scope_CMD, _scope
		End if ' **** STOP/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande de positionnement
		' ===============================================================
		CommLang(2) = "loc/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " loc/                       Locate or get GUI or console cursor"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'LOCate'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow locate your console cursor (x / y)"
					Mess_Aide = Mess_Aide & CRLF & "    or your GUI console when it in execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x:10"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ y:5"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ hello"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x:20 y:10"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Dim PosDEFINIR_X as integer
			Dim PosDEFINIR_Y as integer

			Dim PosOBTENIR_X as integer
			Dim PosOBTENIR_Y as integer

			Dim PosFINAL_X as integer
			Dim PosFINAL_Y as integer
			
			Dim as integer Pos_X, Pos_Y, Scroll_Weel, TypeClic, clip 
			
			if Param = "" Then
				IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.cpc_GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)
					
					DEBUG("X:" & Pos_X & " Y:" & Pos_Y, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				else
					DEBUG("X:" & POS(0) & " Y:" & CSRLIN - 1, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				exit _scope_CMD, _scope
			End if
			

			PosDEFINIR_X = instr(UCASE(Param), "X:")
			PosDEFINIR_Y = instr(UCASE(Param), "Y:")

			if PosDEFINIR_X > 0 then ' Si X Present
				if PosDEFINIR_Y > 0 then ' Si Y present
					IF PosDEFINIR_Y > PosDEFINIR_X then ' Si Y > X
						PosFINAL_X = Val(MID(Param, PosDEFINIR_X + 2, Instr(MID(Param, PosDEFINIR_X + 2), " ")-1))
						PosFINAL_Y = Val(MID(Param, PosDEFINIR_Y + 2))
					else ' Si X > Y
						PosFINAL_X = Val(MID(Param, PosDEFINIR_X + 2))
						PosFINAL_Y = Val(MID(Param, PosDEFINIR_Y + 2, Instr(MID(Param, PosDEFINIR_Y + 2), " ")-1))
					end if
				else ' Si Y non present
					PosFINAL_X = Val(MID(Param, PosDEFINIR_X + 2))
				end if
			Elseif PosDEFINIR_Y > 0 then ' Si Y present seulement
				PosFINAL_Y = Val(MID(Param, PosDEFINIR_Y + 2))

			Else' Afficher les positions
				PosDEFINIR_X = instr(UCASE(Param), "X")
				PosDEFINIR_Y = instr(UCASE(Param), "Y")
				if PosDEFINIR_X > 0 Then
					
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.cpc_GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)
						
						DEBUG(str(Pos_X), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG(str(POS(0)), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				end if
				if PosDEFINIR_Y > 0 Then
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.cpc_GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)
						
						DEBUG(str(Pos_Y), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG(str(CSRLIN), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					
				end if
				exit _scope_CMD, _scope
			end if

			if PosFINAL_X > 0 then
				if PosFINAL_Y > 0 Then
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						SetMouse(PosFINAL_X, PosFINAL_Y)
					else
						locate int(PosFINAL_Y), int(PosFINAL_X)
					End if
				else
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						SetMouse(PosFINAL_X, Pos_Y)
					else
						locate CSRLIN, int(PosFINAL_X)
					End if
				end if
			else
				if PosFINAL_Y > 0 Then
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						SetMouse(Pos_X, PosFINAL_Y)
					else
						locate int(PosFINAL_Y), POS(0)
					End if
				else
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.cpc_GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)
						
						DEBUG("X:" & Pos_X & " Y:" & Pos_Y, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG("X:" & POS(0) & " Y:" & CSRLIN - 1, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					
					' Si aucun parametre definir alors on affiche les deux positions sur la meme ligne
					
				end if

			end if
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** POS/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		REM ' ===============================================================
		REM '  Commande pour stopper brusquement l'OS et fermer le kernel (Non conseille)
		REM ' ===============================================================
		CommLang(2) = "stopk/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		REM 'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " stopk/                     Stop kernel."
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'CLear Screen'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to stop Kernel (With urgency)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' On affiche en mode console
			' CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_Resolution(0)
			CpcdosCP_SHELL("SYS/ /DEBUG = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			CpcdosCP_SHELL("SYS/ /DEBUG /CPINTICORE = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			CpcdosCP_SHELL("SYS/ /SCREEB 0", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			doevents(1000)
			
				DEBUG("[CpcdosC+] Stopping cpcdos kernel...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			doevents(500000)
			
				DEBUG("[Cpcdos] Closing file descriptor...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			Reset()
			doevents(2000000)
			
				DEBUG("[Cpcdos] OK, BYE!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			doevents(1000000)
			end
'-------------------------------------------------' CPCDOS_INSTANCE.CPintiCore_INSTANCE.Quitter_CPintiCore() -------------------------------------------------
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** STOPK/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		
		' ===============================================================
		'  Commande pour atteindre un label code
		' ===============================================================
		CommLang(2) = "goto/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " goto/                      Go to at specified label in code in execution"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to go to in a specified label in your code"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello"
					Mess_Aide = Mess_Aide & CRLF & "   aller/ MyLabel"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ How are you?"
					Mess_Aide = Mess_Aide & CRLF & "  :MonLabel:"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Bye!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Results :"
					Mess_Aide = Mess_Aide & CRLF & "   Hello"
					Mess_Aide = Mess_Aide & CRLF & "   Bye!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : exe/ "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'Affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Jump to :" & Param & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if

			CpcdosCP_SHELL = "ALLER/ " & Param ' on renvoie ca a la boucle while de la lecture

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** ALLER/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour declarer une fonction CpcdosC+
		' ===============================================================
		CommLang(2) = "return/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			
				CommandesAide = CommandesAide & CRLF & " return/                    Return value from CpcdosC+ function"
			
		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to declare CpcdosC+ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 :"
					Mess_Aide = Mess_Aide & CRLF & "   Function/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      Return/ Foo!"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Function"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display : Foo!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2 :"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      txt/ I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "      return/ tada!!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "            tada!!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			CpcdosCP_SHELL = "FONCTION-RETOUR:" & Param
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** RETOUR ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour declarer une fonction CpcdosC+
		' ===============================================================
		CommLang(2) = "function/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " function/                  Declare CpcdosC+ function with a level"
			
		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create a function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple:"
					Mess_Aide = Mess_Aide & CRLF & "   Function/ My_Function()"
					Mess_Aide = Mess_Aide & CRLF & "      return/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   end/ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   txt/ /F:My_Function()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Declare/ , exe/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			CpcdosCP_SHELL = "FONCTION:" & PARAM
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** RETOUR ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande pour executer une commande avec ou sans Parametres
		' ===============================================================
		CommLang(2) = "cmd/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " cmd/                       Launch CpcdosC+ command with or without Parameters"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch a CpcdosC+ command"
					Mess_Aide = Mess_Aide & CRLF & "   This is able to launch in another threads or process"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Parametres disponibles :"
					Mess_Aide = Mess_Aide & CRLF & "   /thread       : Launch command in another thread"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MAX]  : Idem, but with MAXimal priority"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[ST+]  : Idem, but with more that STanDard priority"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[STD]  : Idem, but with STanDard priority (Same effect that /thread)"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MI+]  : Idem, but with more that MINimal priority"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MIN]  : Idem, but with MINimal priority"
					Mess_Aide = Mess_Aide & CRLF & "   /pid:123		 : Execute instructions from the '123' process"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ exe/ MyProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ ping/ www.google.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same example in another thread :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread exe/ MyProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread Ping/ www.google.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same example but with priority :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[MIN] txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[STD] exe/ MyProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[MAX] Ping/ www.google.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute server thread in another existing process (Example with 123)"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 server/ /tcp:2316"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute OS loader from another process"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 Start/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute executable file from another process"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 exe/ MyFile.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : exe/ "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
			Dim PosParam1				as Integer
			Dim PosParam2				as Integer
			Dim PosParam3				as Integer
			Dim PosParam4				as Integer
			Dim PosParam5				as Integer
			Dim PosParam6				as Integer
			Dim Thread_MaxStdMin		as Integer

			Dim KEY_ByPrevioudPID		as double = 0
			
			Dim NumeroPID_cmd 		as integer = 0
			Dim NomProcessus_cmd 	as String = ""
			IF Instr(UCASE(Param), "/PID") > 0 Then
				NumeroPID_cmd = VAL(Mid(Param, instr(Ucase(Param), "/PID") + 5))
				Param = Mid(Param, 1, instr(Ucase(Param), "/PID") - 1) & Mid(Param, instr(Instr(ucase(Param), "/PID"), Param, " ") + 1)
				
				KEY_ByPrevioudPID = _CLE_
				' Redonner et regenerer les nouvelle infos du nouveau processus
				Auth_PID = NumeroPID_cmd
				_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
				
			End if
			
			IF NumeroPID_cmd > 0 Then
				NomProcessus_cmd = CPCDOS_INSTANCE.get_Nom_Processus(NumeroPID_cmd)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Definition host process on '" & NomPRocessus_cmd & "' PID:" & NumeroPID_cmd, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
			End if
			
			PosParam1 = Instr(UCASE(Param), "/THREAD ")	  ' 0
			PosParam2 = Instr(UCASE(Param), "/THREAD[MIN] ") ' 1
			PosParam3 = Instr(UCASE(Param), "/THREAD[MI+] ") ' 1
			PosParam4 = Instr(UCASE(Param), "/THREAD[STD] ") ' 2
			PosParam5 = Instr(UCASE(Param), "/THREAD[ST+] ") ' 2
			PosParam6 = Instr(UCASE(Param), "/THREAD[MAX] ") ' 3

			IF PosParam1 > 0 Then
				Param = MID(Param, PosParam1 + 8)
				Thread_MaxStdMin = 2 ' Standard
			ElseIf PosParam2 > 0 Then
				Param = MID(Param, PosParam2 + 13)
				Thread_MaxStdMin = 1 ' Minimum
			ElseIf PosParam3 > 0 Then
				Param = MID(Param, PosParam3 + 13)
				Thread_MaxStdMin = 2 ' Minimum +
			ElseIf PosParam4 > 0 Then
				Param = MID(Param, PosParam4 + 13)
				Thread_MaxStdMin = 3 ' Standard
			ElseIf PosParam5 > 0 Then
				Param = MID(Param, PosParam4 + 13)
				Thread_MaxStdMin = 4 ' Standard+
			ElseIf PosParam6 > 0 Then
				Param = MID(Param, PosParam4 + 13)
				Thread_MaxStdMin = 5 ' Maximum
			Else
				Thread_MaxStdMin = 0 ' pas de thread

			End if

			
			' Verifier s'il y a une execution interactive d'une fonction
			'  Car si elle est executee dans un autre thread il ne trouvera jamais la fonction
			'  Du coup il faut re-preciser le fichier source
			IF Instr(UCASE(Param), "/F:") > 0 AND Instr(UCASE(Param), "(") > Instr(UCASE(Param), "/F:") AND Instr(UCASE(Param), ")") > Instr(UCASE(Param), "(") Then 
				Dim NomFichier_correction as string

				
				if KEY_ByPrevioudPID > 0 then
					' Si on a utilise /PID /THREAD
					NomFichier_correction = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("_EXE_PATH_", 2, KEY_ByPrevioudPID))
				Else
					' Si on a utilise uniquement /THREAD
					NomFichier_correction = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("_EXE_PATH_", 2, _CLE_))
				End if

				Param = "EXE/ " & NomFichier_correction & " /FN:" & mid(Param, instr(Param, "/F:") + 3) & ") ->"
				Param = MID(Param, 1, Instr(Param, ") ->") - 1) & "->" & _CLE_
				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Function detected! Entry arguments correction : " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
			End if
			
			IF Thread_MaxStdMin = 0 Then ' Execution normal, sur le meme thread
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] BEGIN Interactive command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				' Execution de la commande
				CpcdosCP_SHELL(Param, _CLE_, NIVEAU_CCP, Param_1, Param_2)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					
						DEBUG("[CpcdosC+] END interactive command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				exit _scope_CMD, _scope
			End if
			IF Thread_MaxStdMin > 0 Then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("Kernel > Creating asynchrome execution CCP process...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if

				' Si > 0 Alors c'est qu'on doit creer un nouveau thread
				SCOPE

					Dim TidRetour as uinteger
					' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
					Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
					INSTANCE_STRUCT_THREAD.Nom 		= "_CPCDOSCP_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_)
					INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Shell_THREAD) 		' PTR
					INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID							' PID uint
					INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS							' ID de l'OS
					INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur					' ID de l'user
					INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel
					
					INSTANCE_STRUCT_THREAD.ARG_1 = malloc(sizeof(Param))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @Param), sizeof(Param))
					INSTANCE_STRUCT_THREAD.ARG_2 = NULL ' CLE
					INSTANCE_STRUCT_THREAD.ARG_3 = cast(any ptr, NIVEAU_CCP)
					INSTANCE_STRUCT_THREAD.ARG_4 = cast(any ptr, Param_1)
					INSTANCE_STRUCT_THREAD.ARG_5 = malloc(sizeof(Param_2))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_5, cast(any ptr, @Param_2), sizeof(Param_2))

					
					'' 25-01-2017 A FAIRE : Gerer les priorites
					If Thread_MaxStdMin = 1 Then ' Execution dans un thread de priorite minimale
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] BEGIN Minimal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_TRES_FAIBLE
						
						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					ElseIf Thread_MaxStdMin = 2 Then ' Execution dans un thread de priorite minimale+
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] BEGIN Normal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_FAIBLE
						
						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
	
					ElseIf Thread_MaxStdMin = 3 Then ' Execution dans un thread de priorite normale
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							
								DEBUG("[CpcdosC+] BEGIN Normal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
						
						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
					
					ElseIf Thread_MaxStdMin = 4 Then ' Execution dans un thread de priorite normale
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] BEGIN Normal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
						
						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					ElseIf Thread_MaxStdMin = 5 Then ' Execution dans un thread de priorite normale+
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] BEGIN Hight priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_ASSEZ_HAUTE
						
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
					End if
					
					if TidRetour > 0 Then
						' on cree le nouveau thread
						
						
						DEBUG("" & TidRetour, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Validation, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					Else
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] ERROR TID is null, thread '" & INSTANCE_STRUCT_THREAD.Nom & "' can't be created ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
					End if
				END SCOPE
			End if
				
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CMD/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande pour ouvrir directement/simplement un fichier
		' ===============================================================
		CommLang(2) = "open/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " open/                      Read only file content"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allows simply to read a file content and get data and display"
					Mess_Aide = Mess_Aide & CRLF & "    this to screen or in another direction '@#, @$ .. '"
					Mess_Aide = Mess_Aide & CRLF & "   This command is also pratical, because, he open, reads, and closes files automatically."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  1st example simple (Displaying on console) :"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ index.htm"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ Directory\Text.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ C:\Temp\Results.log"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  2th exemple (Getting data -> Variable)"
					Mess_Aide = Mess_Aide & CRLF & "   @#MyText Open/ C:\Redaction.txt"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This is the file content : %MyText%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3th example (Getting data -> Other file)"
					Mess_Aide = Mess_Aide & CRLF & "   @$C:\Copy.txt Open/ C:\Redaction.txt"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Redaction.txt has been copied!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  4th example (Getting 4th line) :"
					Mess_Aide = Mess_Aide & CRLF & "   Open/ text.txt /line:4 "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  5th example (Lire la ligne qui contient 'foo') :"
					Mess_Aide = Mess_Aide & CRLF & "   Open/ text.txt /text:foo"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : write/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = LTRIM(LTRIM(RTRIM(RTRIM(MID(Commande, CommPosition + TailleComm + 2), CHR(09))), CHR(09)))
			SCOPE
			' ===================================================================
			
			Dim Numero_Ligne as integer = -2
			Dim Text_Recherche as String = ""
			Dim PosParam as integer = 0
			Dim TailleParam as integer = 0
			if instr(UCASE(Param), "/LIGNE:") > 0 Then
				PosParam = instr(UCASE(Param), "/LIGNE:")
				Numero_Ligne = -1
				TailleParam = 7
			elseif instr(UCASE(Param), "/LINE:") > 0 Then
				PosParam = instr(UCASE(Param), "/LINE:")
				Numero_Ligne = -1
				TailleParam = 6
			elseif instr(UCASE(Param), "/TEXTE:") > 0 Then
				PosParam = instr(UCASE(Param), "/TEXTE:")
				TailleParam = 7
			elseif instr(UCASE(Param), "/TEXT:") > 0 Then
				PosParam = instr(UCASE(Param), "/TEXT:")
				TailleParam = 6
			end if
			
			if PosParam > 0 Then
				if Numero_Ligne = -1 then ' Numero de ligne
					Numero_Ligne = val(Mid(Param, PosParam + TailleParam, 8)) ' Limite a 8 digits
				elseif Numero_Ligne = -2 Then ' Texte
					Text_Recherche = Mid(Param, PosParam + TailleParam, 24) ' Limite 24 caracteres
				end if
				
				Param = Mid(Param, 1, PosParam - 1)
			End if
			
			
			' Tester l'existence du fichier
			If CPCDOS_INSTANCE.Fichier_Existe(Param) = TRUE then
				Dim TailleRetourCHR as integer
				

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] OK, opening of '" & Param & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				'doevents(_PAUSE_CRT) ' Pause CRT CPinticore

				' Lire le contenu depuis CPinti core
				Dim Buffer_CCP as String = CPCDOS_INSTANCE.Lire_fichier_complet(Param)
				
				' Cuter le contenu si le numero de ligne a ete demande
				if Numero_Ligne > -1 Then 
					dim Decoupage as integer = 1
					for boucle as integer = 0 to Len(Buffer_CCP)
						
						if Decoupage > 1 Then
							' S'il y a un CRLF, alors on cut !
							if Instr(Buffer_CCP, CRLF) > 0 Then
								Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CRLF) + 2)
								
							' Ou... s'il y a un CR
							Elseif Instr(Buffer_CCP, CR) > 0 Then
								Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CR) + 2)
							
							' Ou... s'il y a un LF
							Elseif Instr(Buffer_CCP, LF) > 0 Then
								Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, LF) + 2)
							end if
						End if
						
						' Jusqu'a qu'on atteingne le nombre de ligne
						if Decoupage > Numero_Ligne-1 Then exit for
				
						' Nombre de lignes cutes
						Decoupage += 1
					next boucle
				
					' Puis on cute les autres lignes!
					if Instr(Buffer_CCP, CRLF) > 0 Then
						Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CRLF) - 1)
					Elseif Instr(Buffer_CCP, CR) > 0 Then
						Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CR) - 1)
					Elseif Instr(Buffer_CCP, LF) > 0 Then
						Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, LF) - 1)
					end if
					
				' Cuter le contenu a partir de la ligne souhaite ou le texte apparait
				ElseIf Numero_Ligne = -2 Then
					dim Decoupage as integer = 1
					if len(Text_Recherche) > 0 Then
						for boucle as integer = 0 to Len(Buffer_CCP)
							
							if Decoupage > 1 Then
								' S'il y a un CRLF, alors on cut !
								if Instr(Buffer_CCP, CRLF) > 0 Then
									Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CRLF) + 2)
									
								' Ou... s'il y a un CR
								Elseif Instr(Buffer_CCP, CR) > 0 Then
									Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CR) + 1)
								
								' Ou... s'il y a un LF
								Elseif Instr(Buffer_CCP, LF) > 0 Then
									Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, LF) +1 )
								end if
							End if
							
							' Des qu'il y a le texte recherche!
							if Instr(Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CRLF) - 1), Text_Recherche) > 0 Then Exit for
							if Instr(Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CR) - 1), Text_Recherche) > 0 Then Exit for
							if Instr(Mid(Buffer_CCP, 1, Instr(Buffer_CCP, LF) - 1), Text_Recherche) > 0 Then Exit for
								
							' Jusqu'a qu'on atteingne le nombre de ligne
							if Decoupage > Len(Buffer_CCP) Then exit for
							
							' Nombre de lignes cutes
							Decoupage += 1
							
						next boucle
					
						' Puis on cute les autres lignes!
						if Instr(Buffer_CCP, CRLF) > 0 Then
							Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CRLF) - 1)
						Elseif Instr(Buffer_CCP, CR) > 0 Then
							Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CR) - 1)
						Elseif Instr(Buffer_CCP, LF) > 0 Then
							Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, LF) - 1)
						end if
					End if
				End if
				
				' Recuperer la taille d fichier
				Dim Taille_Du_Fichier as uinteger = Len(Buffer_CCP)
				
				

				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Size " & Taille_Du_Fichier & " bytes ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				' Verifier si CPintiCore nous a communique une erreur
				IF Taille_Du_Fichier = 0 then
					' ca sert a rien de continuer si le fichier est vide
					exit _scope_CMD, _scope
				Else
					' Fichier OK !
					DEBUG(Buffer_CCP, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						
							DEBUG("[CpcdosC+] End reading " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if


				End if ' l'erreur interne
			else 
				' Ah bah fichier indisponible
				Message_erreur = ERRAVT("ERR_015", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Param & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			' Fin
			
			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** OUVRIR/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour ecrire directement/simplement un fichier
		' ===============================================================
		CommLang(2) = "write/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " write/                     Write in file"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allows write in a file."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Avaiable parameters:"
					Mess_Aide = Mess_Aide & CRLF & "   /BIN : Writing in BINary mode"
					Mess_Aide = Mess_Aide & CRLF & "   /APP : Writing in APPending mode"
					Mess_Aide = Mess_Aide & CRLF & "   /APPBIN  or  /BINAPP :"
					Mess_Aide = Mess_Aide & CRLF & "          Writing in BINary and APPending mode"
					Mess_Aide = Mess_Aide & CRLF & "   Without parameters : Normal writing"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 1 :"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ foo.txt = Hello everyone!"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ /APP foo.txt = how are you?"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 2 (Add 1 jump line) :"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ foo.txt = Hello %CPC.CRLF%how are you?"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 3 (From variable) :"
					Mess_Aide = Mess_Aide & CRLF & "   SET/ My_Content = This is the file content"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ foo.txt = %My_Content% the end!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 4 (Copy the file content for another)"
					Mess_Aide = Mess_Aide & CRLF & "   @#Data Open/ Source.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ Destination.txt = %Data%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Others informations :"
					Mess_Aide = Mess_Aide & CRLF & "  In binary mode, the CRLF is not included on each lines"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : open/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+][CPinti] Creating new CPinti instance for writing " & Param & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if

			
			Dim FLAG as integer = 0 ' Par defaut (ca ecrase tout)
			
			Dim PosEgECR as integer = 0 ' 0 par defaut = ecrase tout
			Dim PosParamFLAG(0 to 3) as integer
			
			Dim Donnees as string
			Dim Nom_Fichier as String
			PosEgECR = Instr(Ucase(Param), "=")
			if PosEgECR > 0 then ' Tant que les parametres serons derriere le '='
			
				PosParamFLAG(0) = instr(ucase(Param), "/BIN ") ' Mode binaire
				PosParamFLAG(1) = instr(ucase(Param), "/APP ") ' Mode appending
				PosParamFLAG(2) = instr(ucase(Param), "/BINAPP ") ' Mode binaire appending
				PosParamFLAG(3) = instr(ucase(Param), "/APPBIN ") ' Mode binaire appending

				if PosParamFLAG(3) > 0 and PosParamFLAG(3) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(3) + 8)
					FLAG = 3 ' Mode binaire + appending 
				elseif PosParamFLAG(2) > 0  and PosParamFLAG(2) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(2) + 8)
					FLAG = 3 ' Mode binaire + appending 
				elseif PosParamFLAG(1) > 0  and PosParamFLAG(1) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(1) + 5)
					FLAG = 2 ' Mode appending
				elseif PosParamFLAG(0) > 0  and PosParamFLAG(0) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(0) +5)
					FLAG = 1 ' Mode binaire
				end if
			end if
			

			PosEgECR = Instr(Ucase(Param), "=")
			
			' Si le signe '=' est present
			if PosEgECR > 0 then
				Nom_Fichier = LTRIM(RTRIM(LTRIM(Mid(Param, 1, PosEgECR - 1))), CHR(09)) ' Recuperer le nom enlevant TAB, et espaces avant et apres
				
				Donnees = Mid(Param, PosEgECR + 1)
				
				' Si ca commence par un espace alors on le compte pas, le 2eme oui
				if MID(Donnees, 1, 1) = " " Then Donnees = MID(Donnees, 2)
				
				' Si c'est PAS en binaire, alors on ajoute le CRLF
				IF FLAG = 0 OR FLAG = 2 Then
					if NOT Donnees = "" Then
						Donnees = Donnees & CRLF
					End if
				END IF
			else
				' Pas de "=" on cree simplement le fichier
				Nom_Fichier = LTRIM(RTRIM(LTRIM(Mid(Param, 1, PosEgECR - 1))), CHR(09)) ' Recuperer le nom enlevant TAB, et espaces avant et apres
				Donnees = ""
				FLAG = 0
			end if
			
			if Nom_Fichier = "" then 
				' Avertissment 
					DEBUG("[CpcdosC+] Please enter correct name file", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				exit _scope_CMD, _scope
			end if
			
			
			' Ecrire les donnees depuis CPinti Core
			if CPCDOS_INSTANCE.Ecrire_fichier_complet(Nom_Fichier, Donnees, FLAG) >= 0 then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Writting is finish", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
			else
				' erreur
				Message_erreur = ERRAVT("ERR_053", 0) ' Erreur lors de l'ecriture du fichier
				
					DEBUG("[CpcdosC+] ERR_053:" & Message_erreur & " Please verify access path and his disponibilities.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			end if
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** ECRIRE/ ****	
		
	_end_scope_CMD
		
	_scope_CMD


		' ===============================================================
		'  Commande pour pinger une machine
		' ===============================================================
		CommLang(2) = "ping/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " ping/                      Test a network machine"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to test a network machine with ICMP request"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Simple exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ 192.168.1.1"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ www.google.fr"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ cpcdos.fr.nf"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : server/ "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
			
			Dim AdresseIP 	as String
			Dim TestPing	as Integer
			Dim TempsPris	as Integer

' --------------------- if 1 = 1 then ''if Demarrage_OK = 1 then ----------------------------------------
			if 1 = 1 then
				IF Param <> "" Then
					If Param <> " " Then
						AdresseIP = Param
					End if
				End if

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Sending ICMP request to " & AdresseIP & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if

				' Appeler la fonction pour envoyer la requete ping
				TestPing = CPCDOS_INSTANCE.RESEAU_INSTANCE.Ping(AdresseIP, _CLE_)
				
				if TestPing >= 0 then ' La machine a repondu a la requete ICMP
						DEBUG("[CPinti] Network Ping: Reponse from " & AdresseIP & "! (" & TestPing & " ms)" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
				elseif TestPing < -1 then
					' Probleme reseau
						DEBUG("[CPinti] Network Ping: (" & AdresseIP & ") Network error...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				else
					' La machine n'a pas repondu..
						DEBUG("[CPinti] Network Ping: No reponse from " & AdresseIP & " ..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				end if
			Else ' Aucun pilote reseau ou mode DOSBOX
				IF CPCDOS_INSTANCE.DosBox = True Then
					Message_erreur = ERRAVT("AVT_055", 0)
						DEBUG("[CPinti] Network Ping: (" & AdresseIP & ") " & Message_erreur & ". Unable to ping machine", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				ELSE
					Message_erreur = ERRAVT("AVT_023", 0)
						DEBUG("[CPinti] Network Ping: (" & AdresseIP & ") " & Message_erreur & ". Unable to ping machine", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				END IF
			end if

			if TestPing >= 0 Then 
				' Si ca ping

				' Carte dispo
				CPCDOS_INSTANCE.NETWORK_DRIVERCARD 	= true
				if NOT INSTR(AdresseIP, "127.0.0") > 0 Then 
					CPCDOS_INSTANCE.NETWORK_LOCAL 	= true
				End if

			else
				' Si adresse loopback
				if INSTR(AdresseIP, "127.0.0") > 0 Then 
					' Et ca ping pas LAISSE BET' ET CASSE TOI FDP NETWORK TU ES MAUUUUVAIS WILLY, TU EST MAUUUVAIS
					CPCDOS_INSTANCE.NETWORK_DRIVERCARD 			= false
					CPCDOS_INSTANCE.NETWORK_LOCAL 				= false
					CPCDOS_INSTANCE.NETWORK_ROUTER				= false
					CPCDOS_INSTANCE.NETWORK_INTERNET			= false
					CPCDOS_INSTANCE.NETWORK_INTERNET_AND_DNS	= false
				End if
			End if
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** PING/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande pour telecharger un fichier en http
		' ===============================================================
		CommLang(2) = "download/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " download/                  Download HTTP file"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to download a HTTP file"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://www.google.com/"
					Mess_Aide = Mess_Aide & CRLF & "   download/ http://192.168.1.1/index.html"
					Mess_Aide = Mess_Aide & CRLF & "   download/ http://myWebSite/directory/file.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://myWebSite/images/picture.png"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recieve only server informations (HEAD command)"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ /SRVINFO http://MyWebSite.com/foo.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recieve server informations + file data"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ /+SRVINFO http://MyWebSite.com/foo.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Choice manually directory destination :"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://monsite.com/toto.html /Temp:c:\MyDirectory"
					Mess_Aide = Mess_Aide & CRLF & "  Choice the name file :"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://monsite.com/toto.html /Temp:c:\MyDirectory\MyFile.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  You can get pourcentage during downloading from another thread with level 5 variable :"			
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Progression:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "      --> And during downloading, variable %MyVariable% content the % of donwload"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same thing with bytes :"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Bytes:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Count of bytes by seconds :"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /BytesBySec:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Get socket number : "
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Socket:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Or more parametrers in same time"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Progression:Var1 /Bytes:Var2 /BytesBySec:Var3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : server/ , ping/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
			
			' === A FAIRE ===
			' Telecharger du HTTP avec nom du fichier dans l'URI. Si nom de fichier URI non present, alors index.htm
			' Telecharger uniquement le HEAD
			' Telecharer AVEC le HEAD
			' Telecharger avec comme destination l'ecran ou dossier TEMP
			' Telecharger avec un port perso
			' === A FAIRE ===

			
			if 1 = 1 then ''if Demarrage_OK = 1 then
				Dim DossierTemp_NET 		as string = UCASE(CCP_Lire_Variable("CPC_TEMP.NET", 5, _CLE_))
				Dim Adresse_Serveur 		as string = "255.255.255.255"
				Dim Adresse_URI				as String
				Dim Commande_HTTP 			as string = "    "
				Dim Redirection				as string = ""
				Dim Redirection_REPERTOIRE	as string = ""
				Dim Redirection_MANUEL		as String
				
				Dim POS_http				as Integer
				Dim POS_https				as Integer
				Dim POS_ftp					as integer
				
				Dim POS_SRVINFO				as integer
				Dim POS_PlusSRVINFO			as integer
				
				Dim POS_Temp				as integer
				Dim POS_Temp_Relatif		as integer
				
				Dim PosOctets 			as integer
				
				
				Dim PosBytes 			as integer
				
				Dim PosOctetsParSec		as integer
				Dim PosBytesBySec		as integer

				
				Dim Var_Progression 	as String
				Dim Var_Octets 			as String
				Dim Var_OctetsParSec 	as String
				Dim VAR_Socket			as String
				
				Dim PosProgress as integer = Instr(Ucase(Param), " /PROGRESSION:")
				
				
				' Supprimer les espaces et tabulations
				Param = RTRIM(LTRIM(LTRIM(Param), chr(09)))
				
				if PosProgress > 0 Then
					IF PosProgress > Instr(Param, ",") Then
						Var_Progression = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosProgress + 14, Instr(PosProgress + 14, Param & " ", " ") - (PosProgress + 14)), CHR(09))), CHR(09)))
						
						Param = Param & " "
						
						' Supprimer le progress
						Param = Mid(Param, 1, PosProgress - 1) & " " & Mid(Param, Instr(PosProgress + 14, Param & " ", " ") + 1)

					Else
							DEBUG("[CpcdosC+] Please put '/PROGRESSION' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
						exit _scope_CMD, _scope
					End if
				End if
				
				Dim PosSocket as integer = Instr(Ucase(Param), " /SOCKET:")
				
				
				' Supprimer les espaces et tabulations
				Param = RTRIM(LTRIM(LTRIM(Param), chr(09)))
				
				if PosSocket > 0 Then
					IF PosSocket > Instr(Param, ",") Then
						VAR_Socket = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosSocket + 9, Instr(PosSocket + 9, Param & " ", " ") - (PosProgress + 14)), CHR(09))), CHR(09)))
						
						Param = Param & " "
						
						' Supprimer le progress
						Param = Mid(Param, 1, PosSocket - 1) & " " & Mid(Param, Instr(PosSocket + 9, Param & " ", " ") + 1)

					Else
							DEBUG("[CpcdosC+] Please put '/SOCKET' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
						exit _scope_CMD, _scope
					End if
				End if
			
				PosOctets = Instr(Ucase(Param), " /OCTETS:")
				PosBytes  = Instr(Ucase(Param), " /BYTES:")

				if PosOctets > 0 OR PosBytes > 0 Then
					IF PosOctets > Instr(Param, ",") Then
						Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctets + 9, Instr(PosOctets + 9, Param & " ", " ") - (PosOctets + 9)), CHR(09))), CHR(09)))
						
						Param = Param & " "
						
						' Supprimer le octets
						Param = Mid(Param, 1, PosOctets - 1) & " " & Mid(Param, Instr(PosOctets + 9, Param & " ", " ") + 1)
						
					ElseIf PosBytes > Instr(Param, ",") Then
						Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytes + 8, Instr(PosBytes + 8, Param & " ", " ") - (PosBytes + 8)), CHR(09))), CHR(09)))
						
						Param = Param & " "
						
						' Supprimer le bytes
						Param = Mid(Param, 1, PosBytes - 1) & " " & Mid(Param, Instr(PosBytes + 8, Param & " ", " ") + 1)
						
					Else
							DEBUG("[CpcdosC+] Please put '/OCTETS' or '/BYTES' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
						exit _scope_CMD, _scope
					End if
				End if
				
				PosOctetsParSec	= Instr(Ucase(Param), " /OCTETSPARSEC:")
				PosBytesBySec 	= Instr(Ucase(Param), " /BYTESBYSEC:")
				
				if PosOctetsParSec > 0 OR PosBytesBySec > 0 Then
					IF PosOctetsParSec > Instr(Param, ",") Then
						Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctetsParSec + 15, Instr(PosOctetsParSec + 15, Param & " ", " ") - (PosOctetsParSec + 15)), CHR(09))), CHR(09)))
						
						Param = Param & " "

						' Supprimer le OctetsParSec
						Param = Mid(Param, 1, PosOctetsParSec - 1) & " " & Mid(Param, Instr(PosOctetsParSec + 15, Param & " ", " "))
						
					ElseIf PosBytesBySec > Instr(Param, ",") Then
						Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytesBySec + 13, Instr(PosBytesBySec + 13, Param & " ", " ") - (PosBytesBySec + 13)), CHR(09))), CHR(09)))
						
						Param = Param & " "
						
						' Supprimer le bytesBySec
						Param = Mid(Param, 1, PosBytesBySec - 1) & " " & Mid(Param, Instr(PosBytesBySec + 13, Param & " ", " ") + 1)
						
					Else
							DEBUG("[CpcdosC+] Please put '/OctetsParSec' or '/BytesBySec' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
						exit _scope_CMD, _scope
					End if
				End if
				
				if len(Var_Progression) > 0 or len(Var_OctetsParSec) > 0 or len(Var_Octets) > 0 Then
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Downloading with : Progression '" & Var_Progression & "' Speed '" & Var_OctetsParSec & "' Reveive '" & Var_Octets & "' like indicator ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					END IF
				END IF
				
				
				' Uniquement l'entete
				POS_SRVINFO = INSTR(Ucase(Param), "/SRVINFO")
				
				' Avec l'entete
				POS_PlusSRVINFO = INSTR(Ucase(Param), "/+SRVINFO")
				
				' On veut la HEAD
				IF POS_SRVINFO > 0 Then
					' Enlever l'argument
					Param = MID(Param, 1, POS_SRVINFO - 1) & MID(Param, POS_SRVINFO + LEN("/SRVINFO") + 1)
					Commande_HTTP = "HEAD"
					
				' On veut la HEAD + la requete
				ElseIf POS_PlusSRVINFO > 0 Then
					' Enlever l'argument
					Param = MID(Param, 1, POS_PlusSRVINFO - 1) & MID(Param, POS_PlusSRVINFO + LEN("/+SRVINFO") + 1)
					Commande_HTTP = "GET"
				Else
					' Get normal ;)
					Commande_HTTP = "GET"
				End if
				
				' Dossier tempoaire absolue
				POS_Temp = INSTR(Ucase(Param), "/TEMP:")
				
				' Dossier temporaire relatif a l'emplacement du fichier sur le serveur WEB
				POS_Temp_Relatif = INSTR(Ucase(Param), "/TEMPR:")
				
				' on change de dossier temporaire
				IF POS_Temp > 0 Then
				
					' Recuperer le chemin
					Redirection_MANUEL = MID(Param, (POS_Temp + LEN("/TEMP:")), INSTR(POS_Temp, Param, " ") - (POS_Temp + LEN("/TEMP:")))
					
					' Enlever l'argument jusqu'au prochain espace
					Param = MID(Param, 1, POS_Temp - 1) & MID(Param, INSTR(POS_Temp, Param, " ") + 1)

				' On veut la HEAD + la requete
				ElseIf POS_Temp_Relatif > 0 Then
				
					' Recuperer le chemin et modifier le dossier temporaire directement
					DossierTemp_NET = MID(Param, (POS_Temp_Relatif + LEN("/TEMPR:")), INSTR(POS_Temp_Relatif, Param, " ") - (POS_Temp_Relatif + LEN("/TEMPR:")))

					' Enlever l'argument jusqu'au prochain espace
					Param = MID(Param, 1, POS_Temp_Relatif - 1) & MID(Param, INSTR(POS_Temp_Relatif, Param, " ") + 1)
				Else
					' Get normal ;)
					' Commande_HTTP = "GET"
				End if

				' Recuperer la position de 'HTTP://'
				POS_http = INSTR(Ucase(Param), "HTTP://")
				
				' Recuperer la position de 'HTTPS://'
				POS_https = INSTR(Ucase(Param), "HTTPS://")
				
				' Recuperer la position de 'FTP://'
				POS_ftp = INSTR(Ucase(Param), "FTP://")
				
				
				
				' C'est le protocole HTTP
				IF POS_http > 0 Then
					
					Dim URL				as String
					DIM Fichier_http	as String
					Dim PosPremierSLASH as Integer
					
					URL = MID(Param, LEN("HTTP://") + 1)
					
					' Rechercher le premier '/' 
					PosPremierSLASH = INSTR(URL, "/")
					
					IF PosPremierSLASH >  0 Then
						' Pour recuperer le nom du serveur avant l'URI (http://Serveur/blabla)
						Adresse_Serveur = MID(URL, 1, PosPremierSLASH - 1)
					
						' Recuperer le reste apres le premier '/'. Il est problable qu'il y a rien (http://serveur/)
						Adresse_URI = MID(URL, PosPremierSLASH + 1)
						
						' Si le dernier caractere se finit par '/'
						If MID(Adresse_URI, LEN(Adresse_URI)) = "/" Then
							Adresse_URI = MID(Adresse_URI, 1, LEN(Adresse_URI) - 1) ' On supprime le caractere
						End if
						
						' Recuperer le dernier element du URI
						Fichier_http = MID(Adresse_URI, INSTRREV(Adresse_URI, "/") + 1)
						
						' Verifier s'il finit par "?"
						IF INSTR(Fichier_http, "?") > 0 Then ' le nom de fichier avant "?"
					
							' Si oui, on recupere ce qu'il y a AVANT
							Fichier_http = MID(Fichier_http, 1, INSTR(Fichier_http, "?") - 1)  ' Recuperer avant "?"
						End if
					Else
						' S'il y a pas de '/' c'est qu'il y a uniquement le nom du serveur
						Adresse_Serveur = URL
					End if

					' Si y'a aucun fichier
					IF Adresse_URI = "" Then
						Adresse_URI = "/"
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\index.htm"
					Else
						' Remplacer les '/' par '\' pour l'inscrire dans un fichier
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\" & CPCDOS_INSTANCE.remplacer_Caractere(Adresse_URI, "/", "\")

						
						
						' Recuperer ce qu'il y a avant "?"
						' Verifier s'il finit par "?"
						IF INSTR(Redirection, "?") > 0 Then ' le nom de fichier avant "?"
							' Si oui, on recupere ce qu'il y a AVANT
							
							
							Redirection = MID(Redirection, 1, INSTR(Redirection, "?") - 1)  ' Recuperer avant "?"
							
							
							
						End if
					End if
					
					' Recuperer seulement le repertoire
					Redirection_REPERTOIRE = Mid(Redirection, 1, InstrREV(Redirection, "\") - 1)

					' On check les caracteres interdits (< > ? ....)
					Redirection_REPERTOIRE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Redirection_REPERTOIRE, TRUE, TRUE, FALSE)
					
					
					
					
					IF NOT Redirection_MANUEL = "" Then 					
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_MANUEL, "")
					Else					
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_REPERTOIRE, "")
					End if
					

				' C'est le protocole HTTPS
				ElseIF POS_https > 0 Then
					Dim URL				as String
					DIM Fichier_http	as String
					Dim PosPremierSLASH as Integer
					
					URL = MID(Param, LEN("HTTPS://") + 1)
					
					' Rechercher le premier '/' 
					PosPremierSLASH = INSTR(URL, "/")
					
					IF PosPremierSLASH >  0 Then
						' Pour recuperer le nom du serveur avant l'URI (http://Serveur/blabla)
						Adresse_Serveur = MID(URL, 1, PosPremierSLASH - 1)
					
						' Recuperer le reste apres le premier '/'. Il est problable qu'il y a rien (http://serveur/)
						Adresse_URI = MID(URL, PosPremierSLASH + 1)
						
						' Si le dernier caractere se finit par '/'
						If MID(Adresse_URI, LEN(Adresse_URI)) = "/" Then
							Adresse_URI = MID(Adresse_URI, 1, LEN(Adresse_URI) - 1) ' On supprime le caractere
						End if
						
						' Recuperer le dernier element du URI
						Fichier_http = MID(Adresse_URI, INSTRREV(Adresse_URI, "/") + 1)
						
						' Verifier s'il finit par "?"
						IF INSTR(Fichier_http, "?") > 0 Then ' le nom de fichier avant "?"
					
							' Si oui, on recupere ce qu'il y a AVANT
							Fichier_http = MID(Fichier_http, 1, INSTR(Fichier_http, "?") - 1)  ' Recuperer avant "?"
						End if
					Else
						' S'il y a pas de '/' c'est qu'il y a uniquement le nom du serveur
						Adresse_Serveur = URL
					End if
	
					
					' Si y'a aucun fichier
					IF Adresse_URI = "" Then
						Adresse_URI = "/"
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\index.htm"
					Else
						' Remplacer les '/' par '\' pour l'inscrire dans un fichier
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\" & CPCDOS_INSTANCE.remplacer_Caractere(Adresse_URI, "/", "\")
						
						' Recuperer ce qu'il y a avant "?"
						' Verifier s'il finit par "?"
						IF INSTR(Redirection, "?") > 0 Then ' le nom de fichier avant "?"
							' Si oui, on recupere ce qu'il y a AVANT
							Redirection = MID(Redirection, 1, INSTR(Redirection, "?") - 1)  ' Recuperer avant "?"

						End if
					End if
					
					' Recuperer seulement le repertoire
					Redirection_REPERTOIRE = Mid(Redirection, 1, InstrREV(Redirection, "\") - 1)
					
					
					' On check les caracteres interdits (< > ? ....)
					Redirection_REPERTOIRE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Redirection_REPERTOIRE, TRUE, TRUE, FALSE)

					
					IF NOT Redirection_MANUEL = "" Then 
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_MANUEL, "")
					Else
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_REPERTOIRE, "")
					End if
					
				' C'est le protocole FTP
				ElseIF POS_ftp > 0 Then
					Dim URL				as String
					DIM Fichier_http	as String
					Dim PosPremierSLASH as Integer
					
					URL = MID(Param, LEN("FTP://") + 1)
					
					' Rechercher le premier '/' 
					PosPremierSLASH = INSTR(URL, "/")
					
					IF PosPremierSLASH >  0 Then
						' Pour recuperer le nom du serveur avant l'URI (http://Serveur/blabla)
						Adresse_Serveur = MID(URL, 1, PosPremierSLASH - 1)
					
						' Recuperer le reste apres le premier '/'. Il est problable qu'il y a rien (http://serveur/)
						Adresse_URI = MID(URL, PosPremierSLASH + 1)
						
						' Si le dernier caractere se finit par '/'
						If MID(Adresse_URI, LEN(Adresse_URI)) = "/" Then
							Adresse_URI = MID(Adresse_URI, 1, LEN(Adresse_URI) - 1) ' On supprime le caractere
						End if
						
						' Recuperer le dernier element du URI
						Fichier_http = MID(Adresse_URI, INSTRREV(Adresse_URI, "/") + 1)
						
						' Verifier s'il finit par "?"
						IF INSTR(Fichier_http, "?") > 0 Then ' le nom de fichier avant "?"
					
							' Si oui, on recupere ce qu'il y a AVANT
							Fichier_http = MID(Fichier_http, 1, INSTR(Fichier_http, "?") - 1)  ' Recuperer avant "?"
						End if
					Else
						' S'il y a pas de '/' c'est qu'il y a uniquement le nom du serveur
						Adresse_Serveur = URL
					End if

					' Si y'a aucun fichier
					IF Adresse_URI = "" Then
						Adresse_URI = "/"
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\index.htm"
					Else
						' Remplacer les '/' par '\' pour l'inscrire dans un fichier
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\" & CPCDOS_INSTANCE.remplacer_Caractere(Adresse_URI, "/", "\")
						
						' Recuperer ce qu'il y a avant "?"
						' Verifier s'il finit par "?"
						IF INSTR(Redirection, "?") > 0 Then ' le nom de fichier avant "?"
							' Si oui, on recupere ce qu'il y a AVANT
							Redirection = MID(Redirection, 1, INSTR(Redirection, "?") - 1)  ' Recuperer avant "?"
						End if
					End if
					
					' Recuperer seulement le repertoire
					Redirection_REPERTOIRE = Mid(Redirection, 1, InstrREV(Redirection, "\") - 1)
					
					
					' On check les caracteres interdits (< > ? ....)
					Redirection_REPERTOIRE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Redirection_REPERTOIRE, TRUE, TRUE, FALSE)
					
					
					IF NOT Redirection_MANUEL = "" Then 
						' Creer la structure du repertoire					
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_MANUEL, "")
					Else
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_REPERTOIRE, "")
					End if
					
				Else
					' Vous devez specifier un nom de protocole
					Message_erreur = ERRAVT("AVT_061", 0)
						DEBUG("[CpcdosC+] : " & Message_erreur & ". (http, ftp) Unable download.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End If
				
				' Si c'est une redirection du dossier temporaire manuel, alors on suppime le chemin d'acces 
				'  du debut pour le remplacer par le nouvea, tout en gardant uniquement le nom du fichier
				IF NOT Redirection_MANUEL = "" Then
					Redirection = Redirection_MANUEL & "\" & MID(Redirection, INSTRREV(Redirection, "\") + 1)
				End if

				Redirection = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Redirection, CHR(09)), CR), LF)), CHR(09)))
				
				IF NOT Commande_HTTP = "" Then
					
					if Commande_HTTP = "GET" then
						IF POS_PlusSRVINFO > 0 Then
							' Telecharger le FICHIER + INFO
							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] : Downloading file + server informations header .", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
							
							
							CPCDOS_INSTANCE.RESEAU_INSTANCE.get_http(Adresse_Serveur, 80, Adresse_URI, Redirection, TRUE, _CLE_, RetourVAR, Var_Progression, Var_OctetsParSec, Var_Octets, VAR_Socket)
						Else
							' Telecharger le FICHIER uniquement
							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] : Downloading file only.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
							CPCDOS_INSTANCE.RESEAU_INSTANCE.get_http(Adresse_Serveur, 80, Adresse_URI, Redirection, FALSE, _CLE_, RetourVAR, Var_Progression, Var_OctetsParSec, Var_Octets, VAR_Socket)
						End if
					ElseIF Commande_HTTP = "HEAD" Then
						' Telecharger l'entete seulement
						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] : Downloading server informatons only.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						CPCDOS_INSTANCE.RESEAU_INSTANCE.head_http(Adresse_Serveur, 80, Adresse_URI, Redirection, _CLE_, RetourVAR)
					End if
				End if
				
				
				IF 1 = 2 Then
					
				End if
			END IF
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** TELECHARGER ****	
		
	_end_scope_CMD
		
	_scope_CMD


		' ===============================================================
		'  Commande pour configurer le CpcdosC+
		' ===============================================================
		CommLang(2) = "ccp/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " ccp/                       CpcdosC+ configuration"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to configure CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /set.level"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to configure variable level (privacity level)"
					Mess_Aide = Mess_Aide & CRLF & "       Private sub&fonction     --> ccp/ /fix.niveau = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Private Application      --> ccp/ /fix.niveau = 2"
					Mess_Aide = Mess_Aide & CRLF & "       Public  User             --> ccp/ /fix.niveau = 3"
					Mess_Aide = Mess_Aide & CRLF & "       Public  OS               --> ccp/ /fix.niveau = 4"
					Mess_Aide = Mess_Aide & CRLF & "       Public  Kernel           --> ccp/ /fix.niveau = 5"
					Mess_Aide = Mess_Aide & CRLF & "      And all variable created will be affected by the level configured"
					Mess_Aide = Mess_Aide & CRLF & "      So, you can re-define origin level, for not affect others"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /lang"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to define system language"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "       Retourn actual language [FR] or [EN]"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang"
					Mess_Aide = Mess_Aide & CRLF & "       Define in French language (Langue Francaise)"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang = FR"
					Mess_Aide = Mess_Aide & CRLF & "       Define in English language (Langue Anglaise)"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang = EN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /change:My_Variable"
					Mess_Aide = Mess_Aide & CRLF & "     This allow to block current thread and deblock if 'My_Variable'"
					Mess_Aide = Mess_Aide & CRLF & "      change the content"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /pause"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to pause current thread (Program) for a specified time"
					Mess_Aide = Mess_Aide & CRLF & "      in milliseconds"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "     Exemples:"
					Mess_Aide = Mess_Aide & CRLF & "      Pause for 500ms"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 500"
					Mess_Aide = Mess_Aide & CRLF & "      Pause for 1 seconds and 200 microseconds"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 1200"
					Mess_Aide = Mess_Aide & CRLF & "      For 25 micro seconds"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 0.025"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /optimization"
					Mess_Aide = Mess_Aide & CRLF & "       Enable optimizing programs, before execution"
					Mess_Aide = Mess_Aide & CRLF & "        for check an eventual optimizing"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "     Examples:"
					Mess_Aide = Mess_Aide & CRLF & "      Enable optimization"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimization = 1"
					Mess_Aide = Mess_Aide & CRLF & "      Disable optimization"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimization = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /test"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to test kernel and CPinti core with differents levels"
					Mess_Aide = Mess_Aide & CRLF & "      Simple test     : ccp/ /test   ou  ccp/ /test1"
					Mess_Aide = Mess_Aide & CRLF & "      Difficult test  : ccp/ /test2"
					Mess_Aide = Mess_Aide & CRLF & "      Very hard test  : ccp/ /test3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /begin_critical_section"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to blocking all interrupts and threads, to make it"
					Mess_Aide = Mess_Aide & CRLF & "       PRIORITY the execution of CpcdosC+ code."
					Mess_Aide = Mess_Aide & CRLF & "       This cause betters perforances, but, this can freeze your screen"
					Mess_Aide = Mess_Aide & CRLF & "       and others, until the end of critical section (see below)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /end_critical_section"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to unblocking all interrupts and threads, in order to"
					Mess_Aide = Mess_Aide & CRLF & "       run your CpcdosC+ code normally."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DISCRETION = 1"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to execute instruction without influence hourglass."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DISCRETION = 0"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to influence hourglass when during execution code."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : sys/ "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
			Dim privaciteDefinition as String = ""
							
			' Configurer le niveau de privacite des variables
			IF Instr(UCASE(Param), "/SET.") > 0 OR Instr(UCASE(Param), "/FIX.") > 0 Then
				IF Instr(UCASE(Param), ".LEVEL") > 0 OR Instr(UCASE(Param), ".NIVEAU") > 0 Then 
					IF Instr(UCASE(Param), " = 1") > 0 Then 
						privaciteDefinition = "FIX_NIVEAU1"
					ElseIF Instr(UCASE(Param), " = 2") > 0 Then 
						privaciteDefinition = "FIX_NIVEAU2"
					ElseIF Instr(UCASE(Param), " = 3") > 0 Then 
						privaciteDefinition = "FIX_NIVEAU3"
					ElseIF Instr(UCASE(Param), " = 4") > 0 Then 
						privaciteDefinition = "FIX_NIVEAU4"
					ElseIF Instr(UCASE(Param), " = 5") > 0 Then 
						privaciteDefinition = "FIX_NIVEAU5"
					ElseIF Instr(UCASE(Param), " = ") > 0 Then
						Message_erreur = ERRAVT("AVT_051", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						CpcdosCP_SHELL = "#STOP_ERREUR#"
						exit _scope_CMD, _scope
					End if
					
					' Afficher le niveau en cours
					IF privaciteDefinition = "" Then
						DEBUG(str(NIVEAU_CCP), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if

					CpcdosCP_SHELL = privaciteDefinition
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Private level defined at " & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
					exit _scope_CMD, _scope
				END IF
			End if

			IF Instr(UCASE(Param), "/LANG") > 0 OR Instr(UCASE(Param), "/LANGAGE") > 0 OR Instr(UCASE(Param), "/LANGUAGE") > 0  Then 
				Dim Langgg_tmp 	as String
				
				IF Instr(UCASE(Param), " = FR") > 0 Then CPCDOS_INSTANCE.Utilisateur_Langage = 0 : DEBUG(" [FR] Bienvenue dans la langue Francaise! :-)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR) : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = EN") > 0 Then CPCDOS_INSTANCE.Utilisateur_Langage = 1 : DEBUG(" [EN] Welcome to English language! :-)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR) : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = ") > 0 Then
					Message_erreur = ERRAVT("AVT_051", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					CpcdosCP_SHELL = "#STOP_ERREUR#"
					exit _scope_CMD, _scope
				End if
				
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then Langgg_tmp = "FR"
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 1 Then Langgg_tmp = "EN"
				DEBUG(Langgg_tmp, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			END IF

			' Mettre en pause le thread (Peut sauver la vie du kernel)
			IF Instr(UCASE(Param), "/PAUSE") > 0 Then
				Dim positionPause as integer
				Dim ValeurPause as integer = 0
				positionPause = Instr(UCASE(Param), "/PAUSE") + 7
				ValeurPause = val(MID(Param, positionPause)) * 10^3
				if ValeurPause < 1 then
						DEBUG("[CpcdosC+] Number equal or greater forbidden!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
				doevents(ValeurPause)
				exit _scope_CMD, _scope
			End if

			' Attendre le changement d'une variable en bloquant le thread
			IF Instr(UCASE(Param), "/CHANGE:") > 0 Then
				Dim PositionCHANGE as integer
				Dim VariableAttendre as string
				Dim VariableContenuAV as string, VariableContenuAP as string

				PositionCHANGE = Instr(UCASE(Param), "/CHANGE:")
				VariableAttendre = MID(Param, PositionCHANGE + 8)
				VariableContenuAV = Gest_variables_LIRE(VariableAttendre, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
				VariableContenuAP = VariableContenuAV

				' On bloque le thread tant que FIXQuestion n'est pas null
				while(VariableContenuAP = VariableContenuAV)
					doevents( 52803)
					VariableContenuAP = Gest_variables_LIRE(VariableAttendre, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
					if UCASE(VariableContenuAP) = "#NULL" then VariableContenuAP = VariableContenuAV
				Wend
				exit _scope_CMD, _scope
			end if

			' Optimiser le Cc+
			IF Instr(UCASE(Param), "/OPTIMISATION") > 0 OR Instr(UCASE(Param), "/OPTIMIZATION") > 0 Then
				IF Instr(UCASE(Param), " = 0") > 0 Then this.Cpcdos_Optimisation = 0 : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = 1") > 0 Then this.Cpcdos_Optimisation = 1 : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = 2") > 0 Then this.Cpcdos_Optimisation = 2 : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = ") > 0 Then
					Message_erreur = ERRAVT("AVT_051", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					CpcdosCP_SHELL = "#STOP_ERREUR#"
					exit _scope_CMD, _scope
				End if
				DEBUG(Str(this.Cpcdos_Optimisation), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			END IF
			
			IF Instr(UCASE(Param), "/TEST") > 0 Then
				' Tests de Cpcdos CPinti Core
				IF Instr(UCASE(Param), "/TEST2") > 0 Then
					' Test difficile

					DEBUG("Test tres difficile en developpement" & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				IF Instr(UCASE(Param), "/TEST3") > 0 Then
					' Test tres hard

					DEBUG("Test tres difficile en developpement" & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				' Simple test
				'  Tester en liberant simplement le thread en cours pour executer tous les autres
				doevents(1)
				DEBUG("OK!" & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "/DEBUT_SECTION_CRITIQUE") > 0 OR Instr(UCASE(Param), "/BEGIN_CRITICAL_SECTION") > 0 Then
				' Permet de rendre l'ex�cution d'un morceau de code PRIORITAIRE sans autres interruptions
				this.SECTION_CRITIQUE = TRUE
				
					DEBUG("[CpcdosC+] Begining critical section. All interrupts and thread are blocked during execution of PID:" & Auth_PID & " TID:" & Auth_TID & " -> [0x" & Hex(Val(Auth_PID & Auth_TID)) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
				
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "/FIN_SECTION_CRITIQUE") > 0 OR Instr(UCASE(Param), "/END_CRITICAL_SECTION") > 0 Then
				' Permet de reprendre l'execution normale du code CpcdosC+
				this.SECTION_CRITIQUE = FALSE
				
					DEBUG("[CpcdosC+] Ending critical section for PID:" & Auth_PID & " TID:" & Auth_TID & " -> [0x" & Hex(Val(Auth_PID & Auth_TID)) & "]. All interrupts and thread are in normal execution.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
				
				exit _scope_CMD, _scope
			End if
			
			' Configurer la langue du noyau
			IF Instr(UCASE(Param), "/DISCRETION") > 0 Then
																		
				IF Instr(UCASE(Param), " = 0") > 0 Then CpcdosCP_SHELL = "#DISCRETION:0" : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = 1") > 0 Then CpcdosCP_SHELL = "#DISCRETION:1" : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = ") > 0 Then
					Message_erreur = ERRAVT("AVT_051", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					CpcdosCP_SHELL = "#STOP_ERREUR#"
					exit _scope_CMD, _scope
				End if
				exit _scope_CMD, _scope
			END IF

				DEBUG("[CpcdosC+] Please enter an avaiable parameter. (Type HELP/ CCP/). '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CCP/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
			
		' ===============================================================
		'  Commande pour executer un fichier CpcdosC+
		' ===============================================================
		CommLang(2) = "exe/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle

		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " exe/                       Launch a CpcdosC+ file"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to execute a CpcdosC+ file"
					Mess_Aide = Mess_Aide & CRLF & "    or PE executable (Experimental!!)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3 exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ Program.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ os\prog\Program.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ C:\directry\Program.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Launch an PE windows executable :"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /pe Program.exe"
					Mess_Aide = Mess_Aide & CRLF & "    or"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /win32 Program.exe"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute IR/LLVM program (BC or LL format)"
					Mess_Aide = Mess_Aide & CRLF & "   from code generated by CLANG 3.8 compiler."
					Mess_Aide = Mess_Aide & CRLF & "   (LLVM:Low-Level-Virtual-Machine)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /llvm Programme.ll"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /llvm Programme.bc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Voir aussi: "
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition )
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			Dim CCP_discretion		as boolean = false
			
			Dim CCP_Fonction_ARGS_N 	as Integer
			Dim CCP_Fonction_ARGS		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as String
			Dim CCP_Fonction_ARGS_2		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as String
			Dim CCP_Fonction_DATA		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as String
			Dim CCP_Fonction_CLE		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as double
			
			Dim Nom_Fichier 			as String
			Dim NomLblAAtteindre		as String
			Dim LabelAChercher 			as String
			Dim CCP_Fonction_EXEC		as String
			Dim NumeroDeLigneAChercher	as Integer = 0
			Dim PosLabelLigneExec		as Integer = 0
			
			Dim PosFonctExec			as Integer = 0
			Dim PosLabelExec			as Integer = 0
			
			Dim Position_DEBUT 			as Integer = 0
			Dim Position_FIN 			as Integer = 0
			
			Dim ExecMultiTHREAD 		as Integer = 0
			
			Dim PosETCommerciale 		as Integer = 0
			
			'doevents(_PAUSE_CRT) ' Pause CRT CPinticore
			
			IF INSTR(Ucase(Param), "/LLVM ") > 0 Then
				IF INSTR(Ucase(Param), "/LLVM ") < 5 Then
					Dim POS_LLVM as integer = INSTR(Ucase(Param), "/LLVM ")
					DIM Fichier_LLVM as string = MID(Param, POS_LLVM + 6)
						
					dim FunctionID_RET 		as integer = 0
					dim FUNCTION_ID__ 		as integer = CPCDOS_INSTANCE._FUNCTIONID__LLVM
					
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("Kernel > Creating LLVM virtual machine asynchrome thread, attempted execution of " & LTRIM(Fichier_LLVM) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
					
					' A MODIFIER !! Sinon instance de la console bloque! 
					
					IF CPCDOS_INSTANCE.get_Nom_Thread(Auth_TID) = "THREAD_CONSOLE" Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("Execution from 'THREAD_CONSOLE'  --> Creating new thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("The parent PID process is equal at '0' --> Creating new thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if

						scope
							Fichier_LLVM = LTRIM(Fichier_LLVM)
							' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
							Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
							INSTANCE_STRUCT_THREAD.Nom = "_LLVM_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & "~" & LTRIM(Fichier_LLVM)
							INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Wrapper_THREAD)
							INSTANCE_STRUCT_THREAD.PROC_ID = Auth_PID
							INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS		' ID de l'OS
							INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur	' ID de l'user
							INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel
							
							INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
							
							INSTANCE_STRUCT_THREAD.ARG_CP 	= cast(any ptr, FUNCTION_ID__)
							
							INSTANCE_STRUCT_THREAD.ARG_1 	= malloc(sizeof(Fichier_LLVM))
							memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @Fichier_LLVM), sizeof(Fichier_LLVM))
							
							INSTANCE_STRUCT_THREAD.ARG_2 = NULL
							INSTANCE_STRUCT_THREAD.ARG_3 = NULL
							INSTANCE_STRUCT_THREAD.ARG_4 = NULL
							INSTANCE_STRUCT_THREAD.ARG_5 = NULL
							
							CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("Kernel > Thread " & INSTANCE_STRUCT_THREAD.Nom & " was created!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
						End scope
					else
						' Execution du LLVM via le wrapper Cpcdos/CpintiCore
						FunctionID_RET = Exec_WRAPPER(FUNCTION_ID__, _CLE_, LTRIM(Fichier_LLVM), 0, NULL, NULL, NULL)
						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("Kernel > Creating LLVM virtual machine asynchrome thread, attempted execution of " & LTRIM(Fichier_LLVM) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
					End if
					exit _scope_CMD, _scope
				end if
			End if
			
			
			IF INSTR(Ucase(Param), "/PE ") > 0 OR INSTR(Ucase(Param), "/WIN32 ") > 0 Then
				if INSTR(Ucase(Param), "/PE ") < 5 OR INSTR(Ucase(Param), "/WIN32 ") < 8 then
					Dim POS_PE as integer = INSTR(Ucase(Param), "/PE ")
					DIM Fichier_PE as string = MID(Param, POS_PE + 4)
					Dim POS_Win32 as integer = INSTR(Ucase(Param), "/WIN32 ")
					DIM Fichier_Win32 as string = MID(Param, POS_Win32 + 7)
					
					if POS_PE = 0 Then
						if len(POS_Win32) > 0 Then Fichier_PE = Fichier_Win32
					End if
					
					dim FunctionID_RET 		as integer = 0
					dim FUNCTION_ID__		as integer = CPCDOS_INSTANCE._FUNCTIONID__EXELOADER
			
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("Kernel > Executing PortableExecutable file '" & LTRIM(Fichier_PE) & "' PID:" & Auth_PID & " TID:" & Auth_TID & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
					' A MODIFIER !! Sinon instance de la console bloque! 
					' Execution du ExeLoader via le wrapper Cpcdos/CpintiCore
					
					IF CPCDOS_INSTANCE.get_Nom_Thread(Auth_TID) = "THREAD_CONSOLE" Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("Execution from 'THREAD_CONSOLE'  --> Creating new thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						Scope
							Fichier_PE = LTRIM(Fichier_PE)
							' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
							Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
							INSTANCE_STRUCT_THREAD.Nom 		= "_WIN32PE_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & "~" & LTRIM(Fichier_PE)
							INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Wrapper_THREAD)
							INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID
							INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS		' ID de l'OS
							INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur	' ID de l'user
							INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel
							
							INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
							INSTANCE_STRUCT_THREAD.ARG_CP 	= cast(any ptr, FUNCTION_ID__)
							
							INSTANCE_STRUCT_THREAD.ARG_1 	= malloc(sizeof(Fichier_PE))
							memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @Fichier_PE), sizeof(Fichier_PE))
							
							INSTANCE_STRUCT_THREAD.ARG_2 = NULL
							INSTANCE_STRUCT_THREAD.ARG_3 = NULL
							INSTANCE_STRUCT_THREAD.ARG_4 = NULL
							INSTANCE_STRUCT_THREAD.ARG_5 = NULL
							
							CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("Kernel > Thread " & INSTANCE_STRUCT_THREAD.Nom & " was created!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
						End scope
					Else
						' Execution du LLVM via le wrapper Cpcdos/CpintiCore
						FunctionID_RET = Exec_WRAPPER(FUNCTION_ID__, _CLE_, LTRIM(Fichier_PE), 0, NULL, NULL, NULL)
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("Kernel > Creating Win32 executable asynchrome thread, attempted execution of " & LTRIM(Fichier_PE) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if		
					end if
					exit _scope_CMD, _scope
				End if
			End if
			
			Dim ErreurAVT_053 as Boolean = false
			PosETCommerciale = INSTR(Param, "&")
			ExecMultiTHREAD = 0
			IF INSTR(Param, "&") > 0 Then
				IF INSTR(Param, " &") > 0 Then
					IF INSTR(Param, " &") < PosETCommerciale Then
						ErreurAVT_053 = TRUE
					ELSE
						IF INSTR(Param, " & ") > 0 Then
							IF INSTR(Param, " & ") < PosETCommerciale Then
								Param = MID(Param, PosETCommerciale + 2)
								CpcdosCP_SHELL = "&RETOUR"
							Else
								ErreurAVT_053 = TRUE
							END IF
						ELSE
							IF INSTR(Param, " &+ ") > 0 Then
								IF INSTR(Param, " &+ ") < PosETCommerciale Then
									Param = MID(Param, PosETCommerciale + 3)
									ExecMultiTHREAD = 1
								Else
									ErreurAVT_053 = TRUE
								END IF
							ELSE
								ErreurAVT_053 = TRUE
							End if
						End if

					END IF
				ELSE
					IF INSTR(Param, "& ") = PosETCommerciale Then
						Param = MID(Param, PosETCommerciale + 2)
						CpcdosCP_SHELL = "&RETOUR"
					ELSE
						IF INSTR(Param, "&+ ") = PosETCommerciale Then
							Param = MID(Param, PosETCommerciale + 3)
							ExecMultiTHREAD = 1
						ELSE
							ErreurAVT_053 = TRUE
						End if
					END IF
				End if
			ELSE
				CpcdosCP_SHELL = "&NONRETOUR"
			End if
			
			IF ErreurAVT_053 = TRUE Then
				Message_erreur = ERRAVT("AVT_053", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				CpcdosCP_SHELL = "&NONRETOUR"
				exit _scope_CMD, _scope
			End if

			IF ExecMultiTHREAD = 1 Then
				' Executer un fichier CpcdosC+ dans un autre thread avec celui cifi�
				' de maniere "ascynchrome"
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("Kernel > Creating asynchrome execution CCP process...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if

				scope
					Dim ExeParamsc as String = "Exe/ " & Param
					' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
					Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
					INSTANCE_STRUCT_THREAD.Nom 		= "_CPCDOSCP_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_)
					INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Shell_THREAD)
					INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID
					INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS		' ID de l'OS
					INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur	' ID de l'user
					INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel
					
					INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
					INSTANCE_STRUCT_THREAD.ARG_1 	= malloc(sizeof(ExeParamsc))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @ExeParamsc), sizeof(ExeParamsc))
					INSTANCE_STRUCT_THREAD.ARG_2 	= NULL ' CLE
					INSTANCE_STRUCT_THREAD.ARG_3 	= cast(any ptr, NIVEAU_CCP)
					INSTANCE_STRUCT_THREAD.ARG_4 	= cast(any ptr, Param_1)
					
					INSTANCE_STRUCT_THREAD.ARG_5 = malloc(sizeof(Param_2))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_5, cast(any ptr, @Param_2), sizeof(Param_2))

					
					CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
					
					doevents(100000)
					
				End scope
				exit _scope_CMD, _scope
			End if

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Creating execution CCP process...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
			Dim Si_Non_EXE_FONCT as integer = 0
			' Ici on cherche un nouvel emplacement memoire pour creer une nouveau processus

			NomLblAAtteindre = ""
			
			' Si le parametre "/FN:" {Fonction} est present
			PosFonctExec = Instr(UCASE(Param), "/FN:")
			
			' Etre sur que ces attributs publiques sont vides
			CCP_Fonction_EXEC = ""
			CCP_Fonction_ARGS_N = 0
			For b as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS : CCP_Fonction_ARGS(b) = "" : CCP_Fonction_DATA(b) = "" : CCP_Fonction_CLE(b) = 0 : next b
			
			Dim Arguments_CCP_FONCT_exec as string
			
			IF PosFonctExec > 0 Then
				
				' Declarer les attributs qui vont permettre la recherche
				Dim Pos_Virgule_DEBUT 		as integer = 0
				Dim Pos_Virgule_FIN 		as integer = 0
				
				Dim NomFonctExec 			as String = MID(Param, PosFonctExec + 4)
				Dim Position_1erParenthese 	as integer = Instr(NomFonctExec, "(")
				Dim Position_2emParenthese	as integer = InstrREV(NomFonctExec, ")")
				Dim NomFonction 			as string = Mid(NomFonctExec, 1, (Position_1erParenthese) - 1)
				Dim Arguments 				as string = Mid(NomFonctExec, Position_1erParenthese + 1, Position_2emParenthese - (Position_1erParenthese + 1))
				Dim Cle_CALLER_stack		as double = VAL(Mid(NomFonctExec, Instr(NomFonctExec, "->") + 2))
				
				' CORRECTION de cette PUTAIN FUCKING majuscule DANS les arguments ! 
				
				NomFonction = Ucase(NomFonction)
				NomFonctExec = Ucase(NomFonctExec)
				
				Arguments_CCP_FONCT_exec = Arguments
				
				' Transferer dans un attribut publique
				CCP_Fonction_EXEC = NomFonction
				
				
				
				
				' Recuperer les arguments pour les placer dans un tableau
				IF Position_1erParenthese = Position_2emParenthese - 1 then
					' S'il s'agit d'une fonction sans arguments
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Function without arguments.",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
				else

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Function with argument(s).",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
					' Une fonction avec 1 ou plusieurs arguments
					For Boucle_ARGS 		as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
						' Recuperer les positions
						Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
						Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

						' Verifier la presence d'une vigule
						IF Pos_Virgule_FIN > 0 Then
							'  Virgule presente!
							CCP_Fonction_ARGS(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Pos_Virgule_FIN) - Pos_Virgule_DEBUT))
						else
							' Hop on recupere le dernier argument avant la parenthese
							CCP_Fonction_ARGS(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Position_2emParenthese) - Pos_Virgule_DEBUT))
							
							' Ah .. C'est finis mon gros ;)
							CCP_Fonction_ARGS_N = Boucle_ARGS
							exit for
						End if
						
					Next Boucle_ARGS
				End if

				IF CCP_Fonction_ARGS_N > 0 Then
					' On recupere si possible les donnees des variables
					For boucle_rempl as integer = 0 to CCP_Fonction_ARGS_N
					
						Dim Test_Remplace as string
						
						' Si c'est une variable
						If InstrREV(Commande, "%") > Instr(Commande, "%") THEN
							
							' Recuperer les ID des variables en argument depuis le Stack de celui qui a appele la fonction.
							Dim tmp_Auth_Kernel				as uinteger = CPCDOS_INSTANCE.get_id_kernel		(Cle_CALLER_stack)
							Dim tmp_Auth_OS					as uinteger = CPCDOS_INSTANCE.get_id_OS			(Cle_CALLER_stack)
							Dim tmp_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(Cle_CALLER_stack)
							Dim tmp_Auth_PID				as uinteger = CPCDOS_INSTANCE.get_id_PID		(Cle_CALLER_stack)
							Dim tmp_Auth_TID				as uinteger = CPCDOS_INSTANCE.get_id_TID		(Cle_CALLER_stack)
	

							' Retrouver toutes les variables en memoire depuis la precedente stack
							Test_Remplace = CCP_Rempl_VAR(CCP_Fonction_ARGS(boucle_rempl), NIVEAU_CCP, tmp_Auth_Kernel, tmp_Auth_OS, tmp_Auth_Utilisateur, tmp_Auth_PID, tmp_Auth_TID, RetourVAR)
							
							' Si ce n'est pas une variable, alors se sont des donnees brutes ?
							IF NOT Test_Remplace = CPCDOS_INSTANCE._CONTENU_IMPROPABLE then
								' On recupere les donnees
								CCP_Fonction_DATA(boucle_rempl) = Test_Remplace
							Else
								Message_erreur = ERRAVT("AVT_008", 0)
									DEBUG("[CpcdosC+] AVT_008:" & Message_erreur & " --> '" & CCP_Fonction_ARGS(boucle_rempl) & "' from calling function " & CCP_Fonction_EXEC & ". (KRNL_ID:" & tmp_Auth_Kernel & " OS:" & tmp_Auth_OS & " USER:" & tmp_Auth_Utilisateur & " PID:" & tmp_Auth_PID & " TID:" & tmp_Auth_TID & ") CleID: &" & Cle_CALLER_stack & " [&B" & Bin(Cle_CALLER_stack, 36) & "] -> 0x" & hex(Cle_CALLER_stack, 10), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
							End if
						Else
							CCP_Fonction_DATA(boucle_rempl) = CCP_Fonction_ARGS(boucle_rempl)
							
						End if
					Next boucle_rempl
				End if
				
				
				' Enlever le '/FN:'
				Param = MID(Param, 1, PosFonctExec - 2)
				
				
				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						' DEBUG("[CpcdosC+] Redefinition de la cle d'identification", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' Else
						' DEBUG("[CpcdosC+] Redefinition key ID", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' End If
				' End if	
				
				' ' Redefinition des cle d'identifications
				' Auth_TID = int(Auth_TID + CPCDOS_INSTANCE.Generer_RND(1, 99))
				' _CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
				
				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' DEBUG("[OK] --> CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & " (TID:" & Auth_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				' End if	

				Si_Non_EXE_FONCT = 1
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Calling function '" & CCP_Fonction_EXEC & "()'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if	

						
			End if

			' Si le parametre "/L:{Nom du label}" ou "/L:#{Numero de ligne}" est present
			PosLabelExec = Instr(UCASE(Param), "/L:")
			IF PosLabelExec > 0 Then

				' On se positionne a partir du premier "/"
				NomLblAAtteindre = MID(Param, PosLabelExec)

				' On verifie si il y a pas le "#" a cote
				PosLabelLigneExec = Instr(UCASE(Param), "/L:#")
				IF PosLabelLigneExec > 0 Then
					' Si oui, on Recupere le NUMERO DE LIGNE
					NumeroDeLigneAChercher = Val(MID(Param, PosLabelLigneExec + 4))
					NomLblAAtteindre = ""
					' Puis releve le /L:# pour recuperer le nom de fihcier uniquement
					Param = MID(Param, 1, PosLabelLigneExec - 2)
				Else
					' Si non, on Recupere le NOM DE LABEL
					NomLblAAtteindre = UCASE(MID(Param, PosLabelExec + 3))

					' Puis releve le /L: pour recuperer le nom de fihcier uniquement
					Param = MID(Param, 1, PosLabelExec - 2)
				End if
			End if

			Nom_Fichier = UCASE(Param)
			IF Instr(MID(Nom_Fichier, 1, 1), " ") > 0 Then Nom_Fichier = MID(Nom_Fichier, 2)
			
			' Tester si la nouvelle instance d'objet a reussi
			IF 1 = 1 Then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+][CPinti] OK, Testing existence '" & Nom_Fichier & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				Nom_Fichier_DBG = Nom_Fichier
				' Tester l'existence du fichier
				If CPCDOS_INSTANCE.Fichier_Existe(Nom_Fichier) = TRUE then				
					
					Dim Taille_Du_Fichier 	as uinteger = 0
					Dim Buffer_CCP 			as String = ""
					' exe/
					Dim RetourCCP 			as String = ""
					
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] OK, opening of '" & Param & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
					'doevents(_PAUSE_CRT) ' Pause CRT CPinticore
					
					if CPCDOS_INSTANCE.Fichier_Existe(Nom_Fichier) = true Then
						' Lire le contenu depuis CPinti core
						Buffer_CCP = CPCDOS_INSTANCE.Lire_fichier_complet(Nom_Fichier)
					End if
					
					' Recuperer la taille d fichier
					Taille_Du_Fichier = Len(Buffer_CCP)
					
					' ENTRER_SectionCritique()
					' Print "Contenu fichier : " & Buffer_CCP & "."
					' print "Taille final : " & Taille_Du_Fichier & "."
					' dim touche as string
					' SORTIR_SectionCritique()
					
					' while(true)
						' touche = inkey
						' if touche = "1" then exit while
					' wend
					
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Size " & Taille_Du_Fichier & " bytes ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if

					' Verifier si CPintiCore nous a communique une erreur
					IF Taille_Du_Fichier = 0 then
						' ca sert a rien de continuer si le fichier est vide
						exit _scope_CMD, _scope
					Else
						
						Dim FinDuFichier		as Integer = 0
						Dim Passage				as Integer = 0
						Dim TestALLER 			as Integer = 0
						
						DIM PILE_SI(0 to 64) 	as integer
						DIM Execute_SI		 	as integer = 0
						
						DIM PILE_SI_NB			as integer = 0
						DIM NB_Si_Non_Exe		as integer = 0
						DIM SI_CEST_FONCTION	as integer = 0
						Dim Empl_1 				as integer = 0
						Dim ModeAnalyse			as integer = 0
						if this.Cpcdos_Optimisation > 0 Then ModeAnalyse = 1
						
						Dim Index_Label			as integer = 0
						
						Dim Temp_exe 				as Integer
						
						Dim EmplacementLabel	(0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1) 	as integer
						Dim NoLigneLabel		(0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1)		as integer
						Dim NomLabel_Emplace	(0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1) 	as String
						
						' Forcer la memoire vide 6 octets
						for nom_boucle as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1
							NomLabel_Emplace(nom_boucle) = chr(0) & chr(0) & chr(0) & chr(0) & chr(0) & chr(0)
							NomLabel_Emplace(nom_boucle) = ""
						next nom_boucle
						
						Dim Nouvelle_TID 			as uinteger 
						Dim Nouvelle_Cle 			as double 
						Dim Nouvelle_Cle_GUI 		as double 
						Dim Nouvelle_OS_ID	 		as integer = Auth_OS ' OS EN COURS
						
						' IUG
						DIM Modification_IUG		as boolean
						DIM Modification_IUG_TID	as double
						
						Dim _INDEX_FENETRE_ 		as integer = 0
						Dim _INDEX_BOUTON_ 			as integer = 0
						Dim _INDEX_PICTUREBOX_ 		as integer = 0
						Dim _INDEX_TEXTBLOCK_		as integer = 0
						Dim _INDEX_TEXTBOX_			as integer = 0
						Dim _INDEX_PROGRESSBAR_		as integer = 0
						Dim _INDEX_CHECKBOX_		as integer = 0
						Dim _INDEX_EXPLORER_		as integer = 0
						Dim _INDEX_LISTBOX_		as integer = 0
						
						Dim IUG_CREATION_FENETRE 	as string
						Dim IUG_CREATION_BOUTON 	as string
						Dim IUG_CREATION_PICTUREBOX as string
						Dim IUG_CREATION_TEXTEBOX 	as string
						Dim IUG_CREATION_TEXTEBLOCK as string
						Dim IUG_CREATION_PROGRESSBAR as string
						Dim IUG_CREATION_CHECKBOX 	as string
						Dim IUG_CREATION_EXPLORER 	as string
						Dim IUG_CREATION_LISTBOX 	as string
						
						
						Dim Buffer_lecture 			as String
						
						Position_DEBUT	 	= 1
						Position_FIN 	 	= 0
						Buffer_lecture  	= ""
						Numero_de_Ligne 	= 0
						RetourCCP 			= ""
						LabelAChercher		= RTRIM(RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(LTRIM(LTRIM(UCASE(NomLblAAtteindre)), chr(09)), chr(10)), chr(13)), chr(09)), chr(13)), chr(10)))
						TestALLER 			= 0
						Niveau_2			= 2

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG(" - Key id:" & _CLE_, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						
						IF NOT EXEC_FONCTION_FICHIER = "" THEN
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] No redefinition key ID for executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
							' Pas de changements si c'est une fonction car elle c'est deja fait 
							Nouvelle_TID = Auth_TID
							Nouvelle_Cle = _CLE_
						' Elseif Slash_FN_Presend = TRUE Then
							' ' Idem car on le FERA 
							' Nouvelle_TID = Auth_TID
							' Nouvelle_Cle = _CLE_
							
						Else
						
							' On doit conserver l'ID
							if SAME_ID = true Then
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										DEBUG("[CpcdosC+] (SAME_ID) No redefinition key ID for executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									
								End if
								
								Nouvelle_TID = Auth_TID
								Nouvelle_Cle = _CLE_
							Else
						
								' Si c'est pas une fonction, si Same_ID, on regenere une nouvelle cle
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										DEBUG("[CpcdosC+] Redefinition key ID for executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									
								End if
				
								Nouvelle_TID = int(Auth_TID + CPCDOS_INSTANCE.Generer_RND(50, 99))
								Nouvelle_Cle = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
							End if
						End if
						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[OK] --> CleID:" & Nouvelle_Cle & " [&B" & Bin(Nouvelle_Cle, 36) & "] -> 0x" & hex(Nouvelle_Cle, 10) & " (TID:" & Auth_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if	
						Nouvelle_Cle_GUI = Nouvelle_Cle

						
						CpcdosCP_SHELL("SET/ _EXE_PATH_ = " & Param, Nouvelle_Cle, 2, Param_1, Param_2)
						
						dim exe_path_dir_tmp as string 
						if INSTRREV(Param, "\") > 0 then
							if INSTRREV(Param, "/") > 0 Then
								if INSTRREV(Param, "/") > INSTRREV(Param, "\") Then ' Si / et \ son present sur la meme ligne
									exe_path_dir_tmp = Mid(Param, 1, INSTRREV(Param, "/") - 1) ' S'arreter avant le dernier /
								elseif INSTRREV(Param, "/") < INSTRREV(Param, "\") Then
									exe_path_dir_tmp = Mid(Param, 1, INSTRREV(Param, "\") - 1) ' S'arreter avant le dernier \
								End if
							else
								exe_path_dir_tmp = Mid(Param, 1, INSTRREV(Param, "\") - 1) ' S'arreter avant le dernier \
							End if
						elseif INSTRREV(Param, "/") > 0 then

							if INSTRREV(Param, "/") > 0 Then
								if INSTRREV(Param, "/") > INSTRREV(Param, "\") Then ' Si / et \ son present sur la meme ligne
									exe_path_dir_tmp = Mid(Param, 1, INSTRREV(Param, "/") - 1) ' S'arreter avant le dernier /
								elseif INSTRREV(Param, "/") < INSTRREV(Param, "\") Then
									exe_path_dir_tmp = Mid(Param, 1, INSTRREV(Param, "\") - 1) ' S'arreter avant le dernier \
								End if
							else
								exe_path_dir_tmp = Mid(Param, 1, INSTRREV(Param, "/") - 1) ' S'arreter avant le dernier /
							End if

						end if

						CpcdosCP_SHELL("SET/ _EXE_PATH_DIR_ = " & exe_path_dir_tmp, Nouvelle_Cle, 2, Param_1, Param_2)
						
						CpcdosCP_SHELL("SET/ _EXE_PID_ = " & Auth_PID , Nouvelle_Cle, 2, Param_1, Param_2)
						
						CpcdosCP_SHELL("SET/ _EXE_TID_ = " & CPCDOS_INSTANCE.get_ThreadEnCours(), Nouvelle_Cle, 2, Param_1, Param_2)
						
						CpcdosCP_SHELL("SET/ _EXE_DATE_ = " & CPCDOS_INSTANCE.get_Date("AAAA-MM-JJ") & " " & CPCDOS_INSTANCE.get_Heure("HH:MM:SS"), Nouvelle_Cle, 2, Param_1, Param_2)
						
						IF ModeAnalyse = 1 then
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Starting analysis program for possible optimizations...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
						End if

						
					scope
						Dim NumeroOS					as Integer = Auth_OS
						' Proprietes d'identification du Processus hebergeur
						DIM GUI__PROC_PARENT			as String	= CPCDOS_INSTANCE.get_Nom_Processus(Auth_PID)
						DIM GUI__PID_PARENT				as integer	= Auth_PID
						
						' Proprietes d'identification du Thread executif
						DIM GUI__THREAD_PARENT			as String	= CPCDOS_INSTANCE.get_Nom_Thread(Auth_TID)
						DIM GUI__TID_PARENT				as Integer 	= Auth_TID
						
						' Proprietes d'identification d'Objet graphique hebergeur
						'	Dans le cas si on cree une fenetre --> Son hebergeur sera null
						DIM GUI__Fenetre_PARENT			as String 	= ""	' Nom de la fenetre hebergeur
						DIM GUI__Index_FNT_PARENT		as Integer 	= 0 	' Index de la fenetre hebergeur
						DIM GUI__Handle_PARENT			as Integer 	= 0 	' Handle de la fenetre hebergeur

						' Proprietes d'identification de l'Objet concerne
						DIM GUI__Nom					as String	= ""	' Nom de l'objet
						DIM GUI__Index_ENFANT			as integer 	= 0		' Index de l'objet
						DIM GUI__Handle					as integer	= 0		' Numero d'Handle de l'objet
						
						' Proprietes uniques de l'objet concerne
						DIM GUI__PROP_TYPE 				as String 	= ""
						DIM GUI__DEJA_INITIALISE		as boolean = false
						
						DIM GUI__PROP_TITRE 			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE", 3, _CLE_)
						DIM GUI__PROP_TITRE_PX			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_PX", 3, _CLE_))
						DIM GUI__PROP_TITRE_PY			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_PY", 3, _CLE_))
						
						Dim GUI__PROP_TITRE_IMG_ID				as integer = 0
						Dim GUI__PROP_BUFFER_TITRE_IMG_ID		as integer = 0
						Dim GUI__PROP_BUFFER_TITRE_2_IMG_ID		as integer = 0
						Dim GUI__PROP_BUFFER_WIN_IMG_ID			as integer = 0
						Dim GUI__PROP_BUFFER_OMBRE_WIN_IMG_ID	as integer = 0
															
						
						
						DIM GUI__IUG_UPDATER			as integer 	= 100
						DIM GUI__THREAD_OK				as integer 	= 0
						DIM GUI__PROP_TEXTE				as String 	= ""
						DIM GUI__PROP_VALEUR			as Integer 	= 0
						
						DIM GUI__PROP_TYPE_OBJ			as integer 	= 0 ' Fenetre/Objet normal

						Dim GUI__PROP_TYPE_DESKTOPMODE	as boolean = false ' Mode bureau
						
						DIM GUI__PROP_DEPLACABLE		as boolean 	= true
						DIM GUI__PROP_SIZEABLE_ANGL 	as boolean 	= true
						DIM GUI__PROP_PRIORITY			as integer 	= false

						DIM GUI__PROP_MINIMAL_SIZE_X	as Integer 	= 0
						DIM GUI__PROP_MINIMAL_SIZE_Y	as Integer 	= 0

						DIM GUI__PROP_MAXIMAL_SIZE_X	as Integer 	= 0
						DIM GUI__PROP_MAXIMAL_SIZE_Y	as Integer 	= 0

						DIM GUI__PROP_COLLISION 		as boolean 	= true
						DIM GUI__PROP_SIZEABLE 			as boolean 	= true
						DIM GUI__PROP_REDUCTABLE 		as boolean 	= true
						DIM GUI__PROP_FERMABLE 			as boolean 	= true

						Dim GUI__PROP_TASKBAR			as integer = 0
						Dim GUI__PROP_No_TASKBAR		as boolean = false
						
						
						DIM GUI__PROP_TYPE_BORDURE		as integer	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BORD", 3, _CLE_))
						Dim GUI__PROP_TYPE_Ombre		as integer	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW", 3, _CLE_))
						Dim GUI__PROP_TYPE_Editable		as boolean	= TRUE
						Dim GUI__PROP_TYPE_MultiLignes	as boolean	= FALSE
						Dim GUI__PROP_TYPE_Console		as boolean 	= FALSE
						Dim GUI__PROP_TYPE_ContextMenu 	as integer	= 0
						Dim GUI__PROP_TYPE_Ombre_RVB	as String	= CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW_RGB", 3, _CLE_)
						
						Dim GUI__PROP_OMBRE_PX			as integer = Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW_PX", 3, _CLE_))
						Dim GUI__PROP_OMBRE_PY			as integer = Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW_PY", 3, _CLE_))
						
						
						DIM GUI__PROP_COULEURALPHA		as string	= CCP_Lire_Variable("CPC_GUI.WINDOW.ALPHA", 3, _CLE_)
						DIM GUI__PROP_COULEURTITRE 		as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_RGB", 3, _CLE_)
						DIM GUI__PROP_COULEURTEXTE		as String   = CCP_Lire_Variable("CPC_GUI.TEXT_RGB", 3, _CLE_)
						DIM GUI__PROP_COULEURFENETRE 	as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.RGB", 3, _CLE_)
						DIM GUI__PROP_COULEURFOND		as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BACKGROUND_RGB", 3, _CLE_)
						DIM GUI__PROP_COULEUR			as String 	= CCP_Lire_Variable("CPC_GUI.RGB", 3, _CLE_)
						
						DIM GUI__PROP_EditBar			as String 	= CCP_Lire_Variable("CPC_GUI.TEXTBOX.EDITBAR", 3, _CLE_)
						DIM GUI__PROP_EditBar_L			as String 	= CCP_Lire_Variable("CPC_GUI.TEXTBOX.EDITBAR_L", 3, _CLE_)
						
						' APPLICATION ICONE
						DIM GUI__PROP_ICONE				as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.ICO", 3, _CLE_)
						Dim GUI__PROP_ICONE_IMG_ID			as integer 	= 0
						Dim GUI__PROP_ICONE_ORG_IMG_ID		as integer 	= 0
						DIM GUI__PROP_ICONE_PX			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_PX", 3, _CLE_))
						DIM GUI__PROP_ICONE_PY			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_PY", 3, _CLE_))
						DIM GUI__PROP_ICONE_POS			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_POSITION", 3, _CLE_))
						DIM GUI__PROP_ICONE_TX			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_SX", 3, _CLE_))
						DIM GUI__PROP_ICONE_TY			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_SY", 3, _CLE_))
						DIM GUI__PROP_ICONE_T			as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_S", 3, _CLE_)) = 1 Then
							GUI__PROP_ICONE_T = TRUE
						Else
							GUI__PROP_ICONE_T = FALSE
						End if
						
						' APPLICATION FERMETURE
						DIM GUI__PROP_BT_CLOSE			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE", 3, _CLE_)
						
						Dim GUI__PROP_BT_CLOSE_IMG_ID 	as integer = 0
						Dim GUI__PROP_BT_CLOSE_ORG_IMG_ID as integer = 0
						
						DIM GUI__PROP_BT_CLOSE_PX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_PX", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_PY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_PY", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_POS		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_TX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_SX", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_TY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_SY", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_CLOSE_T = TRUE
						Else
							GUI__PROP_BT_CLOSE_T = FALSE
						End if
						
						' APPLICATION AGRANDISSEMENT
						DIM GUI__PROP_BT_SIZEUP		as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP", 3, _CLE_)
						DIM GUI__PROP_BT_SIZEUP_PX	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_PX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_PY	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_PY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_POS	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_TX	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_SX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_TY	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_SY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_SIZEUP_T = TRUE
						Else
							GUI__PROP_BT_SIZEUP_T = FALSE
						End if
						
						' APPLICATION RETRECISSEMENT
						DIM GUI__PROP_BT_SIZEDOWN			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN", 3, _CLE_)
						DIM GUI__PROP_BT_SIZEDOWN_PX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_PX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_PY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_PY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_POS		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_TX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_SX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_TY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_SY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_SIZEDOWN_T = TRUE
						Else
							GUI__PROP_BT_SIZEDOWN_T = FALSE
						End if
						
						' APPLICATION REDUCTION
						DIM GUI__PROP_BT_REDUCT			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT", 3, _CLE_)
						DIM GUI__PROP_BT_REDUCT_PX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_PX", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_PY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_PY", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_POS		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_TX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_SX", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_TY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_SY", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_REDUCT_T = TRUE
						Else
							GUI__PROP_BT_REDUCT_T = FALSE
						End if
						

						DIM GUI__PROP_IMGTITRE			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_IMG", 3, _CLE_)
						
						
						DIM GUI__PROP_IMAGE				as String 	= ""
						DIM GUI__PROP_IMAGE_ANCIEN		as String 	= ""
						
						Dim GUI__PROP_IMAGE_ID			as Integer 	= 0
						Dim GUI__PROP_IMAGE_prog_ID		as Integer 	= 0
						Dim GUI__PROP_IMAGE_fond_ID		as Integer 	= 0
						Dim GUI__PROP_IMAGE_ORG_ID		as Integer 	= 0
						
						Dim GUI__PROP_IMG_BUFFER_ID		as integer = 0	
						Dim GUI__PROP_IMG_SELECTEUR_ID	as integer = 0
						Dim GUI__PROP_IMG_SCROLL_ID		as integer = 0
						Dim GUI__PROP_SCROLLING_Y		as integer = 0
						Dim GUI__PROP_Mode_Affichage	as integer = 0	
						
						

						Dim GUI__PROP_IMAGE_SURVOLE_ID	as Integer 	= 0
						Dim GUI__PROP_IMAGE_SURVOLE_ORG_ID as Integer = 0
						
						
						DIM GUI__PROP_IMAGEPTR			as ANY PTR	= 0
						DIM GUI__PROP_IMAGEPTR_ORG		as ANY PTR	= 0
						DIM GUI__PROP_IMAGEPTR_ANCIEN	as ANY PTR	= 0
						DIM GUI__PROP_BIT_ORG			as integer = 0
						
						
						DIM GUI__PROP_UPDATER			as integer	= 0
						
						DIM GUI__PROP_CONTENEUR_COMPLET as boolean 	= false
						DIM GUI__PROP_ALPHA_MODE 		as integer	= 0
						DIM GUI__PROP_BLURRY_MODE		as integer 	= 0
						Dim GUI__PROP_SURBRILLE			as integer 	= 0
						
						DIM GUI__PROP_FOND_COULEUR		as boolean = TRUE

						DIM GUI__PROP_CTX				as integer = -1
						
						DIM GUI__PROP_AUTOSIZE			as integer	= 0
						
						DIM GUI__PROP_PX 				as Integer 	= 100
						DIM GUI__PROP_PY 				as Integer 	= 100
						DIM GUI__PROP_TX 				as Integer 	= 150
						DIM GUI__PROP_TY 				as Integer 	= 100
						DIM GUI__PROP_TTITRE			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_SY", 3, _CLE_))

						
						
						DIM GUI__PROP_EVENEMENT			as String 	= ""
						DIM GUI__PROP_EVENEMENT_DISPO	as String 	= ""
						
						Dim si_EXE_FIXE_VARIABLES as integer = 0
						Dim si_EXE_FONCTION_NIV_1 as integer = 0
		
						'doevents(_PAUSE_CRT) ' Pause CRT CPinticore
						
						DIM Pourcent_CPU 		as integer
						Dim TailleRetourCHR 	as integer
						Dim Deja_Affiche		as boolean = false
						Dim Buffer_LABEL 		as String
						
						
						CPCDOS_INSTANCE.En_Charge(true)
						while ((LEN(Buffer_CCP)-Position_FIN) > 0) ' Si on est encore a l'interieur

							TailleRetourCHR = 0

							' Recuperer l'emplacement de 13 10
							Position_FIN = Instr(Position_DEBUT, Buffer_CCP, CHR(13) & CHR(10))
							TailleRetourCHR = 2

							' Si ca existe, on capture les 13 10
							IF Position_FIN > 0 Then 
								Position_FIN = Position_FIN + 2
							Else
								' Autrmement on cherche 13
								if Position_FIN = 0 Then Position_FIN = Instr(Position_DEBUT, Buffer_CCP, CHR(13)) : TailleRetourCHR = 1
								
								' Autrmement on cherche 10
								if Position_FIN = 0 Then Position_FIN = Instr(Position_DEBUT, Buffer_CCP, CHR(10)) : TailleRetourCHR = 1
								
								' Si rien n'a ete trouve, alors on est a la fin du fichier
								if Position_FIN = 0 Then Position_FIN = LEN(Buffer_CCP)

							End if

							' On capture du debut de la ligne jusqu'a la fin
							Buffer_lecture = LTRIM(LTRIM(MID(Buffer_CCP, Position_DEBUT, Position_FIN-Position_DEBUT)), chr(09))

							' On se place apres les retour chariot
							Position_DEBUT = Position_FIN ' + TailleRetourCHR - 1

							IF ModeAnalyse = 1 then
							
								If LEN(Buffer_CCP)-Position_FIN > 0 then 
									Buffer_LABEL = ""
									IF TailleRetourCHR > 0 Then
										Empl_1 = 0
										Numero_de_Ligne = Numero_de_Ligne + 1
									End if
									
									If NOT Empl_1 > 0 Then
										Empl_1 = Instr(Buffer_lecture, ":")
									End if
									
									Dim Empl_2 as integer = InstrREV(Buffer_lecture, ":")
				
									IF Empl_1 < Empl_2 Then
										Buffer_LABEL = Ucase(Mid(Buffer_lecture, Empl_1+1, (Empl_2) - (Empl_1+1)))
										
										IF NOT Instr(UCASE(Buffer_LABEL), " ") > 0 Then
											IF NOT Instr(UCASE(Buffer_LABEL), "/") > 0 Then
												IF NOT Instr(UCASE(Buffer_LABEL), "\") > 0 Then
													IF Len(Buffer_LABEL) <= 64 Then ' Taille max des noms de labels
														IF Len(Buffer_LABEL) > 1 Then
															Index_Label = Index_Label + 1
															
														
															if Index_Label < CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL Then
																NoLigneLabel(Index_Label) = Numero_de_Ligne
																EmplacementLabel(Index_Label) = Position_FIN
																NomLabel_Emplace(Index_Label) = Buffer_LABEL
																IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																		DEBUG(" #Optimising " & Index_Label & "/" & Taille_Du_Fichier & " pointing [0x" & Hex(EmplacementLabel(Index_Label), 8) & "]:" & EmplacementLabel(Index_Label), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																	
																End if
															Else
																IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																		DEBUG("Maximum indexing size limit (" & index_label & "). Can't optimize more", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																	
																End if
															End if
															Buffer_LABEL = ""
															Empl_1 = 0
															Empl_2 = 0
														End if
													else
														Empl_1 = 0
													End if
												else
													Empl_1 = 0
												End if
											else
												Empl_1 = 0
											End if
										else
											Empl_1 = 0
										End if
									Else
										' S'il ya rien a optimiser, on quitte l'opti! <--- Correction 12/04/2020 (boucle infinie) - Jordan
										' ModeAnalyse = 2
										' Position_FIN = 0
										' Position_DEBUT = 1
										' Buffer_lecture = ""
										' TestALLER = 0
										' Numero_de_Ligne = 0
										' Empl_1 = 0
										' FinDuFichier = 0
										' Numero_de_Ligne = 0
										' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											' if Index_Label > 0 Then
												' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
													' DEBUG("[CpcdosC+] Fin de l'analyse. Optimisation gagne " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' Else
													' DEBUG("[CpcdosC+] End of analysis. Optimising gained " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' End If
											' Else
												' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
													' DEBUG("[CpcdosC+] Fin de l'analyse. Aucune optimisations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' Else
													' DEBUG("[CpcdosC+] End of analysis. No optimizations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' End If
											' End if
										' End if
									End if
								Else
									ModeAnalyse = 2
									Position_FIN = 0
									Position_DEBUT = 1
									Buffer_lecture = ""
									TestALLER = 0
									Numero_de_Ligne = 0
									Empl_1 = 0
									FinDuFichier = 0
									Numero_de_Ligne = 0
									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										if Index_Label > 0 Then
												DEBUG("[CpcdosC+] End of analysis. Optimising gained " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										Else
												DEBUG("[CpcdosC+] End of analysis. No optimizations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										End if
									End if
								End if
								
								' Goto NoLGNSaut
								Continue while
							End if


							IF NumeroDeLigneAChercher > 0 Then
								IF Numero_de_Ligne > NumeroDeLigneAChercher Then
									' On a atteint le nombre de lignes demande
									NumeroDeLigneAChercher = 0
								Else
									' On saute on execute pas
									Numero_de_Ligne = Numero_de_Ligne + 1
									
									' Goto NoLGNSaut
									Continue while
								End if
							End if

							IF LEN(LabelAChercher) > 0 then ' On recherche un label
								IF ModeAnalyse = 2 then ' Avec le mode optimisation
									IF Deja_Affiche = false then
										Deja_Affiche = true
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
												DEBUG(" #Search in optimised mode", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										End if
									End if
									For BoucleChercherLabelNom as integer = 1 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL ' MEMOIRE_CCP.CpcdosCP_Variable_MAXI
									
										IF (":" & NomLabel_Emplace(BoucleChercherLabelNom) & ":") = (":" & LabelAChercher & ":") Then
											Numero_de_Ligne = NoLigneLabel(BoucleChercherLabelNom)
											Position_FIN = EmplacementLabel(BoucleChercherLabelNom)
											Position_DEBUT = Position_FIN
											LabelAChercher = ""
											exit for
										End if
									Next BoucleChercherLabelNom
								else ' Sans le mode optimisation
									IF Deja_Affiche = false then
										Deja_Affiche = true
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
												DEBUG(" #Search in standard mode --> :" & LabelAChercher & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										End if
									End if
									Numero_de_Ligne = Numero_de_Ligne + 1
									IF Instr(UCASE(Buffer_lecture), ":" & LabelAChercher & ":") > 0 Then ' si ils correspondent
										LabelAChercher = ""
									End if ' Hop on reboucle!
								end if
							Else ' Si aucun label a chercher

								Numero_de_Ligne = Numero_de_Ligne + 1
								IF FinDuFichier = 0 Then
									' Suppression du CRLF si on n'est pas a la fin du fichier
									IF TailleRetourCHR = 2 Then
										Buffer_lecture = MID(Buffer_lecture, 1, LEN(Buffer_lecture) - 2)
									ElseIf TailleRetourCHR = 1 Then
										Buffer_lecture = MID(Buffer_lecture, 1, LEN(Buffer_lecture) - 1)
									End if
								End if
								
								' OPTIMISATION : Si la commande est "REM/" ou // ou ' on quitte la fonction
								Scope
									Dim Test_REM as Integer = Instr(Ucase(Buffer_lecture), "REM/")
									Dim Test_CMD as Integer = 0
									
									' Si elle est presente, on verifie sa syntaxe
									If Test_REM > 0 Then
										IF NOT CCP_Verifier_Syntaxe(Buffer_lecture, Test_REM) > 10 Then Buffer_lecture = ""
									End if
									
									' Si la ligne commence par // ou par ' alors c'est un commentaire
									IF INSTR(Buffer_lecture, "// ") = 1 OR INSTR(Buffer_lecture, "//" & CHR(09)) = 1 OR INSTR(Buffer_lecture, "///") = 1 OR INSTR(Buffer_lecture, "' ") = 1 OR INSTR(Buffer_lecture, "''") = 1 Then Buffer_lecture = ""
								End Scope

								IF LEN(Buffer_lecture) > 0 then
									
									Passage = Passage + 1
									
									' Si la section critique est active, on n'execute PAS le yielding
									IF this.SECTION_CRITIQUE = FALSE THEN
										' Si le CPU est en galere
										' if Passage > 8 Then
											' Pourcent_CPU = CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_cpu_pourcent()
											' if Pourcent_CPU > 80 Then
												' doevents(1000) ' On libere 1ms
												
											' elseif Pourcent_CPU >= 100 Then ' On libere 100ms
												' doevents(100000)
											' End if
										' End if
										
										if this.Cpcdos_Optimisation = 2 then
											IF Passage > 42 then doevents(0) : Passage = 0
										else
											IF Passage > 24 then doevents(0) : Passage = 0
										End if
										
									End if

	_scope_SAUT_COMMANDE
	
									' On verifie si on doit executer une fonction dans le fichier
									IF Si_Non_EXE_FONCT = 1 Then
										IF NOT CCP_Fonction_EXEC = "" Then		
											' On recherche dans la table des fonctions publiques
											'  ( les fameuses fonction externes! )
											Dim Boucle_table as integer
											' On verifie deja si on est pas deja dans le fichier qui contient
											'  sinon ca boucle et ca crash .. lol
											' IF NOT Ucase(this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table)) = Ucase(Nom_Fichier) Then

												For Boucle_table = 1 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
													' Si le nom de la fonction existe
													IF this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table) = CCP_Fonction_EXEC THEN
														IF this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle_table) >= NIVEAU_CCP Then ' Le niveau est correct
															Dim Retour_Fonction_ as string
															' Verifier s'il sagit d'une fonction du noyau
										
															IF Instr(Ucase(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table)), "CPC.") > 0 Then
																' C'est une fonction declare qui appartient au noyau
																IF Arguments_CCP_FONCT_exec = "" Then
																	
																	
																	' Si il n'y a pas d'arguments, on cherche si c'est pas une fonction VAR
																	Retour_Fonction_ = Recherche_Fonction_Var(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Nouvelle_Cle)
																	' Verifier ce qu'il retourne

																		IF Retour_Fonction_ = " #Cpcdos function not avaiable#" Then
																			' Ce n'est pas une fonction interne
																			' Chercher dans les fonctions du noyau Cpcdos
																			Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID, RetourVAR)
																			CpcdosCP_SHELL = "FONCTION-RETOUR:" & Retour_Fonction_
																			Si_Non_EXE_FONCT = 0
																			' Goto _FIN_EXE_CCP_EXE
																			exit while
																		End if
																Else
																	' Chercher dans les fonctions du noyau Cpcdos
																	Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID, RetourVAR)
																	' Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID, RetourVAR)
																	CpcdosCP_SHELL = "FONCTION-RETOUR:" & Retour_Fonction_
																	Si_Non_EXE_FONCT = 0
																	' Goto _FIN_EXE_CCP_EXE
																	exit while
																	
																End if
															Else	
																' Dim Nouvelle_Cle as double = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_PID + CPCDOS_INSTANCE.Generer_RND(100, 999))
																
																' IF NOT this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table) = Nom_Fichier then
																IF NOT PosFonctExec > 0 AND NOT Nom_Fichier = "KRNL\NULL.CPC" Then 
																	' Si le /FN: a ete utilise pas la pene de recommencer!
																	' Autrement ca boucle a l'infinit jusqu'a crash s'en suive..
																	' C'est une fonction ecrit dans un fichier externe																	
																	
																	CpcdosCP_SHELL = CpcdosCP_SHELL("EXE/ " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table) & " /FN:" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table) & "(" & Arguments_CCP_FONCT_exec & ")->" & _CLE_, _CLE_, NIVEAU_CCP, Param_1, Param_2)
																else
																	IF Nom_Fichier = "KRNL\NULL.CPC" then
																		CpcdosCP_SHELL = CpcdosCP_SHELL("EXE/ " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table) & " /FN:" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table) & "(" & Arguments_CCP_FONCT_exec & ")->" & _CLE_, _CLE_, NIVEAU_CCP, Param_1, Param_2)
																		Si_Non_EXE_FONCT = 0
																		
																		' Goto _FIN_EXE_CCP_EXE
																		exit while
																	End if
																	' Goto Saut_Fincp
																	exit for
																End if
															End if
															Si_Non_EXE_FONCT = 0
															' Goto _FIN_EXE_CCP_EXE
															exit while
														End if
													End if
												Next Boucle_table
											' End if
' Saut_Fincp:
											 
											' On verifie si on tombe bien sur la ligne de la syntaxe ou se situe la fonction
											' Dim POSCommFONCTION_FR as integer = Instr(Ucase(Buffer_lecture), this.Liste_CMD_FR(23) & " ") ' FONCTION/
											Dim POSCommFONCTION_EN as integer = Instr(Ucase(Buffer_lecture), this.Liste_CMD_EN(23) & " ") ' FUNCTION/

											IF POSCommFONCTION_EN > 0 Then
												IF Instr(Ucase(Buffer_lecture), CCP_Fonction_EXEC) > 0 Then
													Dim NomFonctExec as String
													Dim testCMD	as integer 
													IF POSCommFONCTION_EN > 0 Then 
														testCMD = CCP_Verifier_Syntaxe(Buffer_lecture, POSCommFONCTION_EN - 1)
														NomFonctExec = UCASE(MID(Buffer_lecture, POSCommFONCTION_EN + LEN(this.Liste_CMD_EN(23)) - 1)) ' MODIF 22-02-2017 : Suppr POSCommFONCTION_EN + 4))
													End if

													
													' Si la commande est bonne
													IF testCMD < 10 Then 
														' On verifie si le nombre d'arguments concordent
														
														Dim Position_1erParenthese 	as integer = Instr(NomFonctExec, "(")
														Dim Position_2emParenthese	as integer = InstrREV(NomFonctExec, ")")
														Dim Arguments 				as string = Mid(NomFonctExec, Position_1erParenthese + 1, Position_2emParenthese - (Position_1erParenthese + 1))
														
														' Declarer les attributs qui vont permettre la recherche
														Dim Pos_Virgule_DEBUT 	as integer = 0
														Dim Pos_Virgule_FIN 	as integer = 0
														Dim Nombre_Arguments	as integer = 0
														
														' Recuperer les arguments pour les placer dans un tableau
														' IF Position_1erParenthese = Position_2emParenthese then

														IF Position_1erParenthese = Position_2emParenthese - 1 then
															' S'il s'agit d'une fonction sans arguments
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] : Function without arguments.",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
														else
														
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] : Function with argument(s).",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															' Une fonction avec 1 ou plusieurs arguments
															For Boucle_ARGS as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
																' Recuperer les positions
																Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
																Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

																' Verifier la presence d'une vigule
																IF Pos_Virgule_FIN > 0 Then
																	'  Virgule presente!
																	CCP_Fonction_ARGS_2(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Pos_Virgule_FIN) - Pos_Virgule_DEBUT))
																else
																	' Hop on recupere le dernier argument avant la parenthese
																	CCP_Fonction_ARGS_2(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Position_2emParenthese) - Pos_Virgule_DEBUT))
																	
																	' Ah .. C'est finis mon gros ;)
																	Nombre_Arguments = Boucle_ARGS 
																	exit for
																End if
															Next Boucle_ARGS
														End if
														
														IF CCP_Fonction_ARGS_N = Nombre_Arguments then
															' Le nom de fonction + le nombre d'arguments concordent, DONC
															'  on active la lecture et on relit la prochaine ligne
															
															Si_Non_EXE_FONCT = 0
															si_EXE_FIXE_VARIABLES = 1
															si_EXE_FONCTION_NIV_1 = 1
															' Le moteur ccp devrai croiser FIN/ FONCTION et arreter la lecture
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														End if
													End if ' testCMD < 10 
												End if ' Instr(Ucase(Buffer_lecture), CCP_Fonction_EXEC) > 0
											End if ' POSCommFONCTION_FR > 0 OR POSCommFONCTION_EN > 0
										End IF
									End IF
									
									' ========== FONCTION ==========
									IF SI_CEST_FONCTION = 1 then
										Dim FonctionPresentFR as integer
										Dim FonctionPresentEN as integer
										Dim FinPresentFR as integer
										Dim FinPresentEN as integer
										Dim RetourPresentFR as integer
										Dim RetourPresentEN as integer
										' Attendre qu'on croise un FIN/ FONCTION
										
										FonctionPresentFR = Instr(UCASE(Buffer_lecture), " FONCTION")
										
										' Verifier si c'est pas plutot un " FONCTION/" au lieu d'un " FONCTION" en EN
										if FonctionPresentFR > 0 Then
											IF INSTR(UCASE(Buffer_lecture), " FONCTION/") = FonctionPresentFR Then
												FonctionPresentFR = 0 ' Ne pas continuer
											End if
										End if
										
										FonctionPresentEN = Instr(UCASE(Buffer_lecture), " FUNCTION")
										
										' Verifier si c'est pas plutot un " FUNCTION/" au lieu d'un " FUNCTION" en EN
										if FonctionPresentEN > 0 Then
											IF INSTR(UCASE(Buffer_lecture), " FUNCTION/") = FonctionPresentEN Then
												FonctionPresentEN = 0 ' Ne pas continuer
											End if
										End if
										
										IF FonctionPresentFR + FonctionPresentEN > 0 Then
											FinPresentFR = Instr(UCASE(Buffer_lecture), "FIN/ ")
											FinPresentEN = Instr(UCASE(Buffer_lecture), "END/ ")
											IF FinPresentFR + FinPresentEN > 0 Then

												' si on le croise, verifier sa syntaxe
												IF FinPresentFR > 0 Then 
													FinPresentFR = CCP_Verifier_Syntaxe(Buffer_lecture, FinPresentFR - 1)
													IF FinPresentEN < 6 then
														' Si sa syntaxe est bonne on execute a nouveau
														SI_CEST_FONCTION = 0
														exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
													end if
												ELSEIF FinPresentEN > 0 Then 
													FinPresentEN = CCP_Verifier_Syntaxe(Buffer_lecture, FinPresentEN - 1)
													IF FinPresentEN < 6 then
														' Si sa syntaxe est bonne on execute a nouveau
														SI_CEST_FONCTION = 0
														exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
													end if
												End if
											end if
										End if
									End if
									' ========== CONDITION ==========
									
									' Verifier si on est dans un SI
									If PILE_SI_NB > 0 Then
										Dim SinonPresent as integer
										Dim SiPresent as integer

										IF PILE_SI(PILE_SI_NB) = 3 Then ' niveau attente fin
											IF Execute_SI = 0 Then
												SiPresent = Instr(UCASE(Buffer_lecture), "SI/ ")
												if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "IF/ ")
												IF SiPresent > 0 Then
													SiPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SiPresent - 1)
													IF SiPresent < 6 Then
														SiPresent = Instr(UCASE(Buffer_lecture), "ALORS:")
														if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "THEN:")
														IF SiPresent > 0 Then ' il y a bien un SI/ avec ALORS:
															IF Len(MID(Buffer_lecture, SiPresent + 5)) < 3 Then
																NB_Si_Non_Exe = NB_Si_Non_Exe + 1
																exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
															End if
														End if
													End if
												End if
											End if
										ElseIF PILE_SI(PILE_SI_NB) = 1 Then ' niveau positif
											' Verifier si on croise un SINON: 
											SinonPresent = Instr(UCASE(Buffer_lecture), "SINON:")
											if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), "ELSE:")
											IF SinonPresent > 0 Then
												' Et que la syntaxe est correcte
												SinonPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SinonPresent - 1)
												IF SinonPresent < 6 THEN
													' Si oui, on execute plus rien jusqu'a FIN/ SI
													Execute_SI = 0
													PILE_SI(PILE_SI_NB) = 3 ' En attente de fin
													exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
												End if
											End if
										ElseIF PILE_SI(PILE_SI_NB) = 2 Then ' niveau negatif
											IF Execute_SI = 0 Then
												SiPresent = Instr(UCASE(Buffer_lecture), "SI/ ")
												if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "IF/ ")
												IF SiPresent > 0 Then
													SiPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SiPresent - 1)
													IF SiPresent < 6 Then
														SiPresent = Instr(UCASE(Buffer_lecture), "ALORS:")
														if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "THEN:")
														IF SiPresent > 0 Then ' il y a bien un SI/ avec ALORS:
															IF Len(MID(Buffer_lecture, SiPresent + 5)) < 3 Then
																NB_Si_Non_Exe = NB_Si_Non_Exe + 1
																exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
															End if
														End if
													End if
												End if
											End if
											IF NB_Si_Non_Exe < 1 Then 
												SinonPresent = Instr(UCASE(Buffer_lecture), "SINON:")
												if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), "ELSE:")
												IF SinonPresent > 0 Then
												' Et que la syntaxe est correcte
													SinonPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SinonPresent - 1)
													IF SinonPresent < 6 THEN
														IF PILE_SI(PILE_SI_NB) = 1 Then
															Execute_SI = 0
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														else
															Execute_SI = 1
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														End if
													End if
												End if
											End if
										End if
									End if
									IF PILE_SI(PILE_SI_NB) > 0 Then 
										IF Execute_SI = 0 Then 
											Dim ExecCMDEXE as Boolean = FALSE
											Dim SinonPresent as integer
											' Attendre qu'on croise un FIN/ SI 
											SinonPresent = Instr(UCASE(Buffer_lecture), " SI")
											if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), " IF")
											IF SinonPresent > 0 Then
												
												SinonPresent = Instr(UCASE(Buffer_lecture), "FIN/ ")
												if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), "END/ ")
												IF SinonPresent > 0 Then
													' si on le croise, verifier sa syntaxe
													SinonPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SinonPresent - 1)
													IF SinonPresent < 6 then
														IF NB_Si_Non_Exe > 0 then 
															NB_Si_Non_Exe = NB_Si_Non_Exe - 1
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														End if
														' Si sa syntaxe est bonne on decend d'un niveau
														ExecCMDEXE = TRUE ' Goto ExecCMDEXE
													end if
												end if
											End if
											IF ExecCMDEXE = False Then exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
										End if
									End if
' ExecCMDEXE:							
									IF NB_Si_Non_Exe > 0 OR Si_Non_EXE_FONCT = 1 Then exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
									' ===============================

									
									Temp_exe = Niveau_2
									
									IF si_EXE_FONCTION_NIV_1 = 1 then
										si_EXE_FONCTION_NIV_1 = 0
										Niveau_2 = 1
									End if
									
									
									
									' Si on lit une fonction de maniere externe
									IF SI_CEST_FONCTION = 1 then exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											DEBUG(" Reading : " & Buffer_lecture, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										
									End if
									
									
									
									IF si_EXE_FIXE_VARIABLES = 1 then
										si_EXE_FIXE_VARIABLES = 0
										For Boucle_FIXER as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
											IF NOT CCP_Fonction_ARGS_2(Boucle_FIXER) = "" THEN
												CpcdosCP_SHELL("SET/ " & CCP_Fonction_ARGS_2(Boucle_FIXER) & " = " & CCP_Fonction_DATA(Boucle_FIXER), Nouvelle_Cle, Niveau_2, Param_1, Param_2)
											End if
										Next Boucle_FIXER
									End if
									
									' Si la commande contient un appel de fonction, on va executer
									'  cette fonction dans une nouvelle instance de CpcdosCP_SHELL() bloquante
									IF Instr(Ucase(Buffer_lecture), "/F:") > 0 Then
										' Pour executer une fonction en local qui se situe dans le meme 'Nom_Fichier'
										Dim Deja_Trouve as integer = 0
										Dim Fonction_a_test as string = Mid(Buffer_lecture, instr(Ucase(Buffer_lecture), "/F:") + 3)
										Fonction_a_test = Mid(Fonction_a_test, 1, Instr(Fonction_a_test, "(") -1)
										
										For Boucle_Cherche as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
											IF Instr(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_Cherche), Ucase(Fonction_a_test)) > 0 AND INSTR(Buffer_lecture, ")") > INSTR(Buffer_lecture, "(") Then
												Buffer_lecture = "##FONCTION=:" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_Cherche) & ":=##" & Ltrim(Ltrim(Buffer_lecture, CHR(09)))
												Deja_Trouve = 1
												Exit for
											End if
										next Boucle_Cherche
										IF Deja_Trouve = 0 then
											Buffer_lecture = "##FONCTION=:" & Nom_Fichier & ":=##" & Ltrim(Ltrim(Buffer_lecture, CHR(09)))
										End if
									End if

									if NOT len(Buffer_lecture) < 2 then
										Dim CleAUtiliser as Double
										
										if Modification_IUG = true Then
											Dim TestTemp as String = Ucase(Buffer_lecture)
											IF CCP_Verifier_Syntaxe(TestTemp, Instr(TestTemp, "CREER/")) > 10 Then 
												CleAUtiliser = Nouvelle_Cle_GUI
											ElseIF CCP_Verifier_Syntaxe(TestTemp, Instr(TestTemp, "CREATE/")) > 10 Then 
												CleAUtiliser = Nouvelle_Cle_GUI
											Else
												CleAUtiliser = Nouvelle_Cle
											End if
										Else
											CleAUtiliser = Nouvelle_Cle
										End if
										
										RetourCCP = CpcdosCP_SHELL(Buffer_lecture, CleAUtiliser, Niveau_2, Param_1, Param_2)
									End if

									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											DEBUG(" Return : " & RetourCCP, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										
									End if
									
									Niveau_2 = Temp_exe
									
									If Instr(RetourCCP, "FIX_NIVEAU") > 0 Then
										IF RetourCCP = "FIX_NIVEAU1" Then 
											Niveau_2 = 1
										ELSEIF RetourCCP = "FIX_NIVEAU2" Then 
											Niveau_2 = 2
										ELSEIF RetourCCP = "FIX_NIVEAU3" Then 
											Niveau_2 = 3
										ELSEIF RetourCCP = "FIX_NIVEAU4" Then 
											Niveau_2 = 4
										ELSEIF RetourCCP = "FIX_NIVEAU5" Then 
											Niveau_2 = 5
										END IF
									END IF
									
									
									if RetourCCP = "ERR_050" Then CpcdosCP_SHELL = RetourCCP
									
									
									if RetourCCP = "#DISCRETION:0" Then
										if CCP_discretion = true then
											CPCDOS_INSTANCE.En_Charge(true)
											CCP_discretion = false
										end if
									elseif RetourCCP = "#DISCRETION:1" Then
										if CCP_discretion = false then
											CPCDOS_INSTANCE.En_Charge(false)
											CCP_discretion = true
										End if
									End if
									
									IF Instr(RetourCCP, "SWITCH:OS_ID=") > 0 Then
										Dim tmpNomOS 		as String = Ltrim(Rtrim(Mid(RetourCCP, Instr(RetourCCP, "SWITCH:OS_ID=") + 13)))
										Dim NumeroOS_tmp 	as integer = CPCDOS_INSTANCE.test_OSPresent(tmpNomOS)
										Dim Ancien_OS 		as String = CPCDOS_INSTANCE.get_OSPresent(NumeroOS)
										
										if Ancien_OS = "" then Ancien_OS = "<null>"

										IF NumeroOS_tmp > -1 Then

												DEBUG("[SHELL] Switching from " & Ancien_OS & " (OSID:" & NumeroOS & ") OSID:" & NumeroOS & " to '" & tmpNomOS & "' (OSID:" & NumeroOS_tmp & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Action, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											
											
											NumeroOS = NumeroOS_tmp
											Nouvelle_Cle = CPCDOS_INSTANCE.Generer_cle(CPCDOS_INSTANCE.get_id_kernel(), NumeroOS, CPCDOS_INSTANCE.get_id_Utilisateur(), Auth_PID, 0)
											
											' Et definit le OS id sans le SCI
											CPCDOS_INSTANCE.SCI_INSTANCE.set_OSid(NumeroOS)
											
												DEBUG("[SHELL] New KeyID:" & _CLE_ & " [0x" & hex(_CLE_, 8) & "]", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Validation, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											
										Else
												DEBUG("[CpcdosC+] Operating system '" & tmpNomOS & "' not found.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											
										ENd if
									End if
									
									
									' Ceci stoppe la lecture du code
									IF RetourCCP = "ERR_010" Then ' Erreur syntaxe
										_COMMANDE_ = Buffer_lecture
										testCMD = 42 ' 32
										EXIT while
									End if
									
									IF RetourCCP = "ERR_009" Then ' Label introuvable
										EXIT while
									End if

									
									' On arrive a la fin de la section de la fonction
									IF RetourCCP = "FONCTION:FIN" Then 
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
												DEBUG("[CpcdosC+] End function", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										END IF
										EXIT while
									End if
									
									' Renvoyer le contenu de la fonction qui envoit un retour
									IF Instr(RetourCCP, "FONCTION-RETOUR:") > 0 Then
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
												DEBUG("[CpcdosC+] Return in function", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										END IF
										CpcdosCP_SHELL = RetourCCP
										EXIT while
									End if
									
									' Arreter l'execution du code CC+
									IF RetourCCP = "STOP:FIN" Then
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
												DEBUG("[CpcdosC+] Ending CpcdosC+ file execution.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											
										END IF
										EXIT while
									End if
									
									IF RetourCCP = "&NONRETOUR" THEN EXIT while
									IF INSTR(RetourCCP, "FONCTION:") > 0 Then SI_CEST_FONCTION = 1
									TestALLER = Instr(UCASE(RetourCCP), "ALLER/ ")
									
	_end_scope_SAUT_COMMANDE
									
' Saut_Commande:
									If TestALLER > 0 Then
										LabelAChercher = RTRIM(RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(UCASE(MID(RetourCCP, TestALLER + 7))), chr(09)), chr(09)), chr(13)), chr(10)))
										TestALLER = 0
										Position_FIN = 1
										FinDuFichier = 0
										Numero_de_Ligne = 0
									ELSE
										IF FinDuFichier = 1 Then FinDuFichier = 0 : Exit while
									END IF
									If Instr(RetourCCP, "SI:") > 0 Then
										IF RetourCCP = "SI:ALORS" Then
											' On monte d'un niveau positif
											PILE_SI_NB = PILE_SI_NB + 1
											PILE_SI(PILE_SI_NB) = 1
											Execute_SI = 1
										ElseIF RetourCCP = "SI:SINON" Then
											' On monte d'un niveau negatif
											PILE_SI_NB = PILE_SI_NB + 1
											PILE_SI(PILE_SI_NB) = 2
											Execute_SI = 0
										ElseIF RetourCCP = "SI:FIN" Then
											' On decend d'un niveau
											PILE_SI(PILE_SI_NB) = 0
											PILE_SI_NB = PILE_SI_NB - 1
											if NB_Si_Non_Exe > 0 then 
												Execute_SI = 0 
											else 
												IF PILE_SI(PILE_SI_NB) = 2 then Execute_SI = 1
												IF PILE_SI(PILE_SI_NB) = 1 then Execute_SI = 1
											End if
										End if
										RetourCCP = ""
									End if
									
									IF Instr(RetourCCP, "IUG:") > 0 Then
										' **** Declarations d'objets graphiques ****
										
										' ICI placer le mode d'edition des objets ! :)
										
										' Si on est en mode edition ou non
										IF Instr(RetourCCP, "~MODIF#") > 0 Then 
											Modification_IUG = true

											IF Instr(ucase(RetourCCP), "/TID") > 0 Then
												Modification_IUG_TID = val(MID(RetourCCP, 1 + 4, Instr(RetourCCP, "~MODIF#") - 1))
											End if
											
											RetourCCP = MID(RetourCCP, 1, Instr(RetourCCP, "~MODIF#") - 1)
											
										End if
										
										' Dans la meme fenetre, il n'est pas possible d'avoir les memes noms d'objets
										'  mais possible dans plusieurs fenetres
										
										IF Instr(RetourCCP, ":FENETRE_NOM=") > 0 Then
											IUG_CREATION_FENETRE = MID(RetourCCP, Instr(RetourCCP, ":FENETRE_NOM=") + 13)
											
											IF Modification_IUG = True Then
												For _INDEX_FENETRE_ = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
													
													IF IUG_CREATION_FENETRE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.NOM Then
													
			
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) Then
															
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Window(" & _INDEX_FENETRE_ & ") edition mode for '" & IUG_CREATION_FENETRE & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Index_ENFANT = _INDEX_FENETRE_
															GUI__Index_ENFANT		= _INDEX_FENETRE_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.handle
															
															
															
															
															' Proprietes uniques de l'objet concerne
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.OS_id
															
															GUI__DEJA_INITIALISE	= TRUE
														
															
															IUG_CREATION_FENETRE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Nom
															
															GUI__PROP_TITRE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).TITRE 
															GUI__PROP_TITRE_PX 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_TITRE_X 
															GUI__PROP_TITRE_PY 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_TITRE_Y 
															
															GUI__PROP_TITRE_IMG_ID				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).TITRE_IMG_ID 
															GUI__PROP_BUFFER_TITRE_IMG_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_TITRE_IMG_ID 
															GUI__PROP_BUFFER_TITRE_2_IMG_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_TITRE_2_IMG_ID 
															GUI__PROP_BUFFER_WIN_IMG_ID			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_WIN_IMG_ID 
															GUI__PROP_BUFFER_OMBRE_WIN_IMG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_OMBRE_WIN_IMG_ID 
															
															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.ContextMenu
															
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_Y
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.LES_TYPES
															
															GUI__PROP_CONTENEUR_COMPLET = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).CONTENEUR_COMPLET
															
															GUI__PROP_ALPHA_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Alpha_Mode
															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Blurry_Mode

															
															GUI__PROP_IMGTITRE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).IMG_TITRE
															
															' Icone application
															GUI__PROP_ICONE 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).ICONE
															
															GUI__PROP_ICONE_IMG_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).ICONE_IMG_ID
															GUI__PROP_ICONE_ORG_IMG_ID 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).ICONE_ORG_IMG_ID
															
															GUI__PROP_ICONE_PX 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_ICONE_X
															GUI__PROP_ICONE_PY 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_ICONE_Y
															GUI__PROP_ICONE_POS				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_ICONE_POS
															GUI__PROP_ICONE_TX 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_ICONE_X
															GUI__PROP_ICONE_TY 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_ICONE_Y
															GUI__PROP_ICONE_T 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_ICONE
															
															
															' Icone bouton fermeture
															GUI__PROP_BT_CLOSE 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_CLOSE 
															
															GUI__PROP_BT_CLOSE_IMG_ID 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_CLOSE_IMG_ID
															GUI__PROP_BT_CLOSE_ORG_IMG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_CLOSE_ORG_IMG_ID
															
															GUI__PROP_BT_CLOSE_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_CLOSE_X
															GUI__PROP_BT_CLOSE_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_CLOSE_Y
															GUI__PROP_BT_CLOSE_POS 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_CLOSE_POS
															GUI__PROP_BT_CLOSE_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_CLOSE_X
															GUI__PROP_BT_CLOSE_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_CLOSE_Y
															GUI__PROP_BT_CLOSE_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_CLOSE
															
															
															' Icone bouton agrandissement
															GUI__PROP_BT_SIZEUP 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_SIZEUP
															GUI__PROP_BT_SIZEUP_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEUP_X
															GUI__PROP_BT_SIZEUP_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEUP_Y
															GUI__PROP_BT_SIZEUP_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEUP_X
															GUI__PROP_BT_SIZEUP_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEUP_Y
															GUI__PROP_BT_SIZEUP_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEUP
															
															' Icone retrecissement
															GUI__PROP_BT_SIZEDOWN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_SIZEDOWN
															GUI__PROP_BT_SIZEDOWN_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEDOWN_X
															GUI__PROP_BT_SIZEDOWN_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEDOWN_Y
															GUI__PROP_BT_SIZEDOWN_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEDOWN_X
															GUI__PROP_BT_SIZEDOWN_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEDOWN_Y
															GUI__PROP_BT_SIZEDOWN_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEDOWN
															
															' Icone reduction
															GUI__PROP_BT_REDUCT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_REDUCT
															GUI__PROP_BT_REDUCT_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_REDUCT_X
															GUI__PROP_BT_REDUCT_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_REDUCT_Y
															GUI__PROP_BT_REDUCT_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_REDUCT_X
															GUI__PROP_BT_REDUCT_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_REDUCT_Y
															GUI__PROP_BT_REDUCT_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_REDUCT
															
															
															GUI__PROP_TTITRE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_TITRE
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du titre de la fenetre  ===> GUI__PROP_COULEURTITRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURTITRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B	
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur de l'ombre sous la fenetre  ===> GUI__PROP_TYPE_Ombre_RVB		
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B < 100 Then
																ADD_NUM_B = "0"
															End if															
															GUI__PROP_TYPE_Ombre_RVB = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B	
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															GUI__PROP_OMBRE_PX 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Ombre_PX
															GUI__PROP_OMBRE_PY 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Ombre_PY
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.TYPE_OBJ
															
															' Fond bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.DESKTOPMODE

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Bordure
															
															' Deplacable
															GUI__PROP_DEPLACABLE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Deplacable
															
															GUI__PROP_REDUCTABLE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Reductable
															GUI__PROP_SIZEABLE		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Sizeable
															GUI__PROP_SIZEABLE_ANGL	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Sizeable_ANGL
															GUI__PROP_PRIORITY 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.IsPriority

															GUI__PROP_MINIMAL_SIZE_X= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Minimal_size_X
															GUI__PROP_MINIMAL_SIZE_Y= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Minimal_size_Y
															GUI__PROP_MAXIMAL_SIZE_X= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Maximal_size_X
															GUI__PROP_MAXIMAL_SIZE_Y= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Maximal_size_Y

															GUI__PROP_COLLISION		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Collision
															GUI__PROP_FERMABLE		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Fermable

															GUI__PROP_TASKBAR		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.TaskBar
															GUI__PROP_No_TASKBAR	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.NoTaskBar
															
															
															' Ombre sous la fenetre
															GUI__PROP_TYPE_Ombre	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Ombre
															
															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Alpha)

															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO = Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Liste_Evenements)
															Exit for
														End if
													End if
												Next _INDEX_FENETRE_
											
											End if
										ElseIF Instr(RetourCCP, ":BOUTON_NOM=") > 0 Then
											IUG_CREATION_BOUTON = MID(RetourCCP, Instr(RetourCCP, ":BOUTON_NOM=") + 12)
											
											
											IF Modification_IUG = True Then
												For _INDEX_BOUTON_ = 0 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
												
													IF IUG_CREATION_BOUTON = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) Then
														
					
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Button(" & _INDEX_BOUTON_ & ") edition mode for '" & IUG_CREATION_BOUTON & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															if GUI__PROP_TYPE_BORDURE >= 1 then GUI__PROP_TYPE_BORDURE = 1 else GUI__PROP_TYPE_BORDURE = 0
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.MENU_CTX = GUI__PROP_CTX
															
															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Index_ENFANT = _INDEX_BOUTON_
															GUI__Index_ENFANT		= _INDEX_BOUTON_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.handle
															
															IUG_CREATION_BOUTON 	= GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.OS_id
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).THREAD_OK 

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.ContextMenu
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).SIZ_Y
															
															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMAGE_ANCIEN
															
															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_ORG_ID
															GUI__PROP_IMAGE_SURVOLE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_SURVOLE_ID
															GUI__PROP_IMAGE_SURVOLE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_SURVOLE_ORG_ID
															
															' GUI__PROP_IMAGEPTR 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_PTR
															' GUI__PROP_IMAGEPTR_ORG	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_PTR_ORG
															' GUI__PROP_IMAGEPTR_ANCIEN	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_PTR_ANCIEN
															
															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).BIT_ORG
															
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).TEXTE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Blurry_Mode
															
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.LES_TYPES
															
															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).DejaSize = FALSE
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.DESKTOPMODE
															
															' Bordure
															if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure >= 1 then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure = 1 else CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure = 0
															
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Alpha)
															
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Liste_Evenements)

															Exit for
														End if
													End if
												Next _INDEX_BOUTON_
											
											End if
										ElseIF Instr(RetourCCP, ":PICTUREBOX_NOM=") > 0 Then
											IUG_CREATION_PICTUREBOX = MID(RetourCCP, Instr(RetourCCP, ":PICTUREBOX_NOM=") + 16)
											
											
											IF Modification_IUG = True Then
												For _INDEX_PICTUREBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
												
													IF IUG_CREATION_PICTUREBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) Then
														
					
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Picturebox(" & _INDEX_PICTUREBOX_ & ") edition mode for '" & IUG_CREATION_PICTUREBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX
															
															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Handle_PARENT
															
															
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Index_ENFANT = _INDEX_PICTUREBOX_
															GUI__Index_ENFANT		= _INDEX_PICTUREBOX_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.handle
															
															IUG_CREATION_PICTUREBOX	= GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.OS_id
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).THREAD_OK 

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.ContextMenu
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).SIZ_Y
															
															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMAGE_ANCIEN
															
															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_ORG_ID
															
															' GUI__PROP_IMAGEPTR 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_PTR
															' GUI__PROP_IMAGEPTR_ORG	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_PTR_ORG
															' GUI__PROP_IMAGEPTR_ANCIEN	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_PTR_ANCIEN
															
															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).BIT_ORG
															
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).TEXTE
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.LES_TYPES

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).DejaSize = FALSE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Blurry_Mode
															
															GUI__PROP_SURBRILLE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Surbrillance
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.DESKTOPMODE
															
															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Liste_Evenements)

															
															
															Exit for
														End if
													End if
												Next _INDEX_PICTUREBOX_
											
											End if
										ElseIF Instr(RetourCCP, ":TEXTEBLOC_NOM=") > 0 Then
											IUG_CREATION_TEXTEBLOCK = MID(RetourCCP, Instr(RetourCCP, ":TEXTEBLOC_NOM=") + 15)
									
											
											IF Modification_IUG = True Then
												For _INDEX_TEXTBLOCK_ = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
												
													IF IUG_CREATION_TEXTEBLOCK = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) Then
														
					
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Textblock(" & _INDEX_TEXTBLOCK_ & ") edition mode for '" & IUG_CREATION_TEXTEBLOCK & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
															
															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR
															
															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Index_ENFANT = _INDEX_TEXTBLOCK_
															GUI__Index_ENFANT		= _INDEX_TEXTBLOCK_
															
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.handle
															
															IUG_CREATION_TEXTEBLOCK	= GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.OS_id
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).THREAD_OK 

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_PICTUREBOX_).PROP_TYPE.ContextMenu
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).SIZ_Y

															
															
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).TEXTE
															

															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.LES_TYPES
															
															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).DejaSize = FALSE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Blurry_Mode
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.DESKTOPMODE
															
															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Fond_Couleur
															
															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.MENU_CTX


															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Liste_Evenements)

															
															Exit for
														End if
													End if
												Next _INDEX_TEXTBLOCK_
											
											End if
										ElseIF Instr(RetourCCP, ":TEXTEBOX_NOM=") > 0 Then
											IUG_CREATION_TEXTEBOX = MID(RetourCCP, Instr(RetourCCP, ":TEXTEBOX_NOM=") + 14)

											IF Modification_IUG = True Then
												For _INDEX_TEXTBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
													
													IF IUG_CREATION_TEXTEBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Nom Then
													
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) Then
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Textbox(" & _INDEX_TEXTBOX_ & ") edition mode for '" & IUG_CREATION_TEXTEBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du textebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
															
															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR
															
															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Index_ENFANT = _INDEX_TEXTBOX_
															GUI__Index_ENFANT		= _INDEX_TEXTBOX_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.handle
															
															IUG_CREATION_TEXTEBOX	= GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.OS_id
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.LES_TYPES
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).THREAD_OK 

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.ContextMenu
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).SIZ_Y

															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).IMG_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).IMG_ORG_ID
												
															' Texte par defaut
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).TEXTE
															
															' Si ce texte est editable
															GUI__PROP_TYPE_Editable	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Editable
															
															GUI__PROP_TYPE_MultiLignes	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Multi_Lignes
															GUI__PROP_TYPE_Console	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Console

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).DejaSize = FALSE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Blurry_Mode
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.DESKTOPMODE
															
															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Fond_Couleur
															
															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Liste_Evenements)

															
															Exit for
														End if
													End if
												Next _INDEX_TEXTBOX_
											
											End if
										ElseIF Instr(RetourCCP, ":PROGRESSBAR_NOM=") > 0 Then
											IUG_CREATION_PROGRESSBAR = MID(RetourCCP, Instr(RetourCCP, ":PROGRESSBAR_NOM=") + 17)
											
											GUI__PROP_AUTOSIZE = 2
											
											IF Modification_IUG = True Then
												For _INDEX_PROGRESSBAR_ = 0 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
													
													IF IUG_CREATION_PROGRESSBAR = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Nom Then
													
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) Then
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
												
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Progress Bar(" & _INDEX_PROGRESSBAR_ & ") edition mode for '" & IUG_CREATION_PROGRESSBAR & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du textebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
															
															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR
															
															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Index_ENFANT = _INDEX_PROGRESSBAR_
															GUI__Index_ENFANT		= _INDEX_PROGRESSBAR_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.handle
															
															IUG_CREATION_PROGRESSBAR = GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.OS_id
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.LES_TYPES
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).THREAD_OK 

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.ContextMenu
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).SIZ_Y

															
															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMAGE_ANCIEN 
															
															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_ID
															GUI__PROP_IMAGE_prog_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_prog_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_ORG_ID
															
															' GUI__PROP_IMAGEPTR 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_PTR	 		' Obtenir le pointeur du context GZE
															' GUI__PROP_IMAGEPTR_ORG	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_PTR_ORG	 	' Obtenir le pointeur du context GZE
															' GUI__PROP_IMAGEPTR_ANCIEN = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_PTR_ANCIEN	' Obtenir le pointeur du context GZE
												
															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).BIT_ORG ' precedent BIT 
															
															' Texte par defaut
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).TEXTE
															
															
															GUI__PROP_VALEUR		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).VALEUR

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Blurry_Mode
															
															' Pour la barre de progression, ne pas passer en dessous de 0% et pas depasser 100%
															IF GUI__PROP_VALEUR > 100 Then 
																GUI__PROP_VALEUR = 100
															ElseIf GUI__PROP_VALEUR < 0 Then
																GUI__PROP_VALEUR = 0
															End if

															
															' Si ce texte est editable
															GUI__PROP_TYPE_Editable	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Editable
															
															GUI__PROP_TYPE_MultiLignes	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Multi_Lignes

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).DejaSize = FALSE
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.DESKTOPMODE
															
															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Fond_Couleur
															
															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Liste_Evenements)

															
															Exit for
														End if
													End if
												Next _INDEX_PROGRESSBAR_
											
											End if
											
										ElseIF Instr(RetourCCP, ":CHECKBOX_NOM=") > 0 Then
											IUG_CREATION_CHECKBOX = MID(RetourCCP, Instr(RetourCCP, ":CHECKBOX_NOM=") + 14)
											
											GUI__PROP_AUTOSIZE = 1
											
											IF Modification_IUG = True Then
												For _INDEX_CHECKBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
													
													IF IUG_CREATION_CHECKBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Nom Then
													
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) Then
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
												
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Check box(" & _INDEX_CHECKBOX_ & ") edition mode for '" & IUG_CREATION_CHECKBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du textebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
															
															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR
															
															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Index_ENFANT = _INDEX_CHECKBOX_
															GUI__Index_ENFANT		= _INDEX_PROGRESSBAR_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.handle
															
															IUG_CREATION_CHECKBOX = GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.OS_id
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.LES_TYPES
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).THREAD_OK 

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.ContextMenu
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).SIZ_Y

															
															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IMG_ID
															GUI__PROP_IMAGE_fond_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IMG_fond_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IMG_ORG_ID
															
															
															' Texte par defaut
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).TEXTE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Blurry_Mode
															
															
															GUI__PROP_VALEUR		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).VALEUR
															
															' Pour la barre de progression, ne pas passer en dessous de 0% et pas depasser 100%
															IF GUI__PROP_VALEUR > 100 Then 
																GUI__PROP_VALEUR = 100
															ElseIf GUI__PROP_VALEUR < 0 Then
																GUI__PROP_VALEUR = 0
															End if

															
															' Si ce texte est editable
															GUI__PROP_TYPE_Editable	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Editable
														
															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).DejaSize = FALSE
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.DESKTOPMODE
															
															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Fond_Couleur
															
															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Liste_Evenements)

															Exit for
														End if
													End if
												Next _INDEX_CHECKBOX_
											
											End if
											
										ElseIF Instr(RetourCCP, ":EXPLORER_NOM=") > 0 Then
											IUG_CREATION_EXPLORER = MID(RetourCCP, Instr(RetourCCP, ":EXPLORER_NOM=") + 14)
											
											
											IF Modification_IUG = True Then
												For _INDEX_EXPLORER_ = 0 to CPCDOS_INSTANCE._MAX_GUI_EXPLORER
												
													IF IUG_CREATION_EXPLORER = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet._CLE_) Then
														
					
															
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Explorer(" & _INDEX_EXPLORER_ & ") edition mode for '" & IUG_CREATION_EXPLORER & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															if GUI__PROP_TYPE_BORDURE >= 1 then GUI__PROP_TYPE_BORDURE = 1 else GUI__PROP_TYPE_BORDURE = 0
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
															
															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.Index_ENFANT = _INDEX_EXPLORER_
															GUI__Index_ENFANT		= _INDEX_EXPLORER_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.handle
															
															IUG_CREATION_EXPLORER 	= GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Identification_Objet.OS_id
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).THREAD_OK

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.ContextMenu 
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).SIZ_Y
															
															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IMAGE_ANCIEN
															
															
															' GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IMG_ORG_ID
															
															
															GUI__PROP_IMG_BUFFER_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IMG_BUFFER_ID
															GUI__PROP_IMG_SELECTEUR_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IMG_SELECTEUR_ID
															GUI__PROP_IMG_SCROLL_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).IMG_SCROLL_ID
															

															GUI__PROP_SCROLLING_Y		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).SCROLLING_Y
															GUI__PROP_Mode_Affichage	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).Mode_Affichage
															
															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).BIT_ORG
															
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).TEXTE
															
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.LES_TYPES
															
															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).DejaSize = FALSE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Blurry_Mode
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURTEXTE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.DESKTOPMODE
															
															' Bordure
															if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Bordure >= 1 then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Bordure = 1 else CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Bordure = 0
															
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(_INDEX_EXPLORER_).PROP_TYPE.Liste_Evenements)

															Exit for
														End if
													End if
												Next _INDEX_EXPLORER_
											
											End if
										
										ElseIF Instr(RetourCCP, ":LISTBOX_NOM=") > 0 Then
											IUG_CREATION_LISTBOX = MID(RetourCCP, Instr(RetourCCP, ":LISTBOX_NOM=") + 13)
											
											
											IF Modification_IUG = True Then
												For _INDEX_LISTBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX
												
													IF IUG_CREATION_LISTBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Nom Then
														
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet._CLE_) Then
															' CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet._CLE_) Then

													
															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] GUI --> Listbox(" & IUG_CREATION_LISTBOX & ") edition mode for '" & IUG_CREATION_LISTBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if
															
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
															
															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
															
															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
															
															' Bordure
															if GUI__PROP_TYPE_BORDURE >= 1 then GUI__PROP_TYPE_BORDURE = 1 else GUI__PROP_TYPE_BORDURE = 0
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
															
															' Menu context
															if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
															
															GUI__DEJA_INITIALISE	= TRUE
															
															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.PID_PARENT 
															
															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.TID_PARENT
															
															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Handle_PARENT
															
															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.Index_ENFANT = _INDEX_LISTBOX_
															GUI__Index_ENFANT		= _INDEX_LISTBOX_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.handle
															
															IUG_CREATION_LISTBOX 	= GUI__Nom
															
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet._CLE_
															
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Identification_Objet.OS_id
															
															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IUG_UPDATER 
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).THREAD_OK

															GUI__PROP_TYPE_ContextMenu = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.ContextMenu 
															
															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).POS_X 
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).POS_Y
															
															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).SIZ_Y
															
															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IMAGE_ANCIEN
															
															
															'GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IMG_ORG_ID
															
															
															GUI__PROP_IMG_BUFFER_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IMG_BUFFER_ID
															GUI__PROP_IMG_SELECTEUR_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IMG_SELECTEUR_ID
															GUI__PROP_IMG_SCROLL_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).IMG_SCROLL_ID
															

															GUI__PROP_SCROLLING_Y		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).SCROLLING_Y
															GUI__PROP_Mode_Affichage	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).Mode_Affichage
															
															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).BIT_ORG
															
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).TEXTE
															
															
															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.LES_TYPES
															
															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.AutoSizeIMG
															
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).DejaSize = FALSE

															GUI__PROP_BLURRY_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Blurry_Mode
															
															
															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURTEXTE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_FNT_B
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if
															
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Couleur_CTN_B															
															
															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""
															
															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.TYPE_OBJ

															' Mode bureau
															GUI__PROP_TYPE_DESKTOPMODE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.DESKTOPMODE
															
															' Bordure
															if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Bordure >= 1 then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Bordure = 1 else CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Bordure = 0
															
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Alpha)
															
															' Menu contextuel
															GUI__PROP_CTX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.MENU_CTX

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(_INDEX_LISTBOX_).PROP_TYPE.Liste_Evenements)

															Exit for
														End if
													End if
												Next _INDEX_LISTBOX_
											
											End if
										
										' Les fins des declaration d'objets
										ELSEIF Instr(RetourCCP, "IUG:FENETRE_FIN") > 0 Then
											IUG_CREATION_FENETRE = ""
										ELSEIF Instr(RetourCCP, "IUG:BOUTON_FIN") > 0 Then
											IUG_CREATION_BOUTON = ""
										ELSEIF Instr(RetourCCP, "IUG:PICTUREBOX_FIN") > 0 Then
											IUG_CREATION_PICTUREBOX = ""
										ELSEIF Instr(RetourCCP, "IUG:TEXTEBLOC_FIN") > 0 Then
											IUG_CREATION_TEXTEBLOCK = ""
										ELSEIF Instr(RetourCCP, "IUG:TEXTBOX_FIN") > 0 Then
											IUG_CREATION_TEXTEBOX = ""
										ELSEIF Instr(RetourCCP, "IUG:PROGRESSBAR_FIN") > 0 Then
											IUG_CREATION_PROGRESSBAR = ""
										ELSEIF Instr(RetourCCP, "IUG:CHECKBOX_FIN") > 0 Then
											IUG_CREATION_CHECKBOX = ""
										ELSEIF Instr(RetourCCP, "IUG:EXPLORER_FIN") > 0 Then
											IUG_CREATION_EXPLORER = ""
										ELSEIF Instr(RetourCCP, "IUG:LISTBOX_FIN") > 0 Then
											IUG_CREATION_LISTBOX = ""
										
										
										' **** Proprietes graphiques ****
										ELSEIF Instr(RetourCCP, "IUG:PROP_TITRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TITRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_TITRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TITRE = MID(RetourCCP, Instr(RetourCCP, ":PROP_TITRE=") + 12)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TEXTE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TEXTE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_TEXTE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TEXTE = MID(RetourCCP, Instr(RetourCCP, ":PROP_TEXTE=") + 12)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_NOM=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__Nom, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__Nom, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__Nom = MID(RetourCCP, Instr(RetourCCP, ":PROP_NOM=") + 10)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_PID=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PID_PARENT, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PID_PARENT), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PID_PARENT = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_PID=") + 10))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_HANDLE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__Handle_PARENT, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__Handle_PARENT), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__Handle_PARENT = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_HANDLE=") + 13))
												' Trouver les derniers elements pour optimiser et corriger certain bugs
												for boucle as integer = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
													if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).identification_objet.handle = GUI__Handle_PARENT Then
														GUI__Index_FNT_PARENT = boucle
														GUI__Fenetre_PARENT = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).identification_objet.nom
														exit for
													end if
												next boucle
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TYPE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TYPE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_TYPE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TYPE = ucase(MID(RetourCCP, Instr(RetourCCP, ":PROP_TYPE=") + 11))
												
												
												
											
												' *** Detection des parametres ***
												
												' UPD=UPDate pour creer un thread qui met a jour constament le contenu
												IF INSTR(GUI__PROP_TYPE, "UPD:0") > 0 Then GUI__PROP_UPDATER = 0
												IF INSTR(GUI__PROP_TYPE, "UPD:1") > 0 Then GUI__PROP_UPDATER = 1
												
												' Afficher barre de titre cliquable
												IF INSTR(GUI__PROP_TYPE, "CTN:0") > 0 Then GUI__PROP_CONTENEUR_COMPLET = FALSE
												IF INSTR(GUI__PROP_TYPE, "CTN:1") > 0 Then GUI__PROP_CONTENEUR_COMPLET = TRUE
												
												
												' Modes d'alpha (0: (defaut) TOUT , 1:Conteneur, 2:Barre de titre)
												IF INSTR(GUI__PROP_TYPE, "ALPHAMODE:0") > 0 Then GUI__PROP_ALPHA_MODE = 0
												IF INSTR(GUI__PROP_TYPE, "ALPHAMODE:1") > 0 Then GUI__PROP_ALPHA_MODE = 1
												IF INSTR(GUI__PROP_TYPE, "ALPHAMODE:2") > 0 Then GUI__PROP_ALPHA_MODE = 2

												IF INSTR(GUI__PROP_TYPE, "BLURRY:0") > 0 Then GUI__PROP_BLURRY_MODE = 0
												IF INSTR(GUI__PROP_TYPE, "BLURRY:1") > 0 Then GUI__PROP_BLURRY_MODE = 1
												IF INSTR(GUI__PROP_TYPE, "BLURRY:2") > 0 Then GUI__PROP_BLURRY_MODE = 2
												IF INSTR(GUI__PROP_TYPE, "BLURRY:3") > 0 Then GUI__PROP_BLURRY_MODE = 3
												IF INSTR(GUI__PROP_TYPE, "BLURRY:4") > 0 Then GUI__PROP_BLURRY_MODE = 4
												IF INSTR(GUI__PROP_TYPE, "BLURRY:5") > 0 Then GUI__PROP_BLURRY_MODE = 5
												IF INSTR(GUI__PROP_TYPE, "BLURRY:6") > 0 Then GUI__PROP_BLURRY_MODE = 6
												IF INSTR(GUI__PROP_TYPE, "BLURRY:7") > 0 Then GUI__PROP_BLURRY_MODE = 7
												IF INSTR(GUI__PROP_TYPE, "BLURRY:8") > 0 Then GUI__PROP_BLURRY_MODE = 8
												IF INSTR(GUI__PROP_TYPE, "BLURRY:9") > 0 Then GUI__PROP_BLURRY_MODE = 9

												IF INSTR(GUI__PROP_TYPE, "SURBRILLE:") > 0 Then GUI__PROP_SURBRILLE = VAL(MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "SURBRILLE:") + 10, 3))
												
												IF INSTR(GUI__PROP_TYPE, "COL:0") > 0 Then GUI__PROP_FOND_COULEUR = FALSE
												IF INSTR(GUI__PROP_TYPE, "COL:1") > 0 Then GUI__PROP_FOND_COULEUR = TRUE

												' Menu contextuel
												IF INSTR(GUI__PROP_TYPE, "CTX:0") > 0 Then GUI__PROP_CTX = 0
												IF INSTR(GUI__PROP_TYPE, "CTX:1") > 0 Then GUI__PROP_CTX = 1
												IF INSTR(GUI__PROP_TYPE, "CTX:2") > 0 Then GUI__PROP_CTX = 2
												
												' Mode d'affichage image
												IF INSTR(GUI__PROP_TYPE, "IMGAUTO:0") > 0 Then GUI__PROP_AUTOSIZE = 0 ' Par defaut
												IF INSTR(GUI__PROP_TYPE, "IMGAUTO:1") > 0 Then GUI__PROP_AUTOSIZE = 1 ' Adapte a l'image
												IF INSTR(GUI__PROP_TYPE, "IMGAUTO:2") > 0 Then GUI__PROP_AUTOSIZE = 2 ' Adapte au picturebox appel les fonctions de resize

												' Mode affichage Explorer
												IF INSTR(GUI__PROP_TYPE, "EXPLOREMODE:0") > 0 Then GUI__PROP_Mode_Affichage = 0 ' Mode petite liste
												IF INSTR(GUI__PROP_TYPE, "EXPLOREMODE:1") > 0 Then GUI__PROP_Mode_Affichage = 1 ' Mode moyenne liste
												IF INSTR(GUI__PROP_TYPE, "EXPLOREMODE:2") > 0 Then GUI__PROP_Mode_Affichage = 2 ' Mode icones

												IF INSTR(GUI__PROP_TYPE, "DESKTOPMODE:1") > 0 Then GUI__PROP_TYPE_DESKTOPMODE = true
												IF INSTR(GUI__PROP_TYPE, "DESKTOPMODE:0") > 0 Then GUI__PROP_TYPE_DESKTOPMODE = false
												
												' Type de fenetre
												IF INSTR(GUI__PROP_TYPE, "TYPE:0") > 0 Then GUI__PROP_TYPE_OBJ = 0
												IF INSTR(GUI__PROP_TYPE, "TYPE:1") > 0 Then GUI__PROP_TYPE_OBJ = 1
												IF INSTR(GUI__PROP_TYPE, "TYPE:2") > 0 Then GUI__PROP_TYPE_OBJ = 2
												IF INSTR(GUI__PROP_TYPE, "TYPE:3") > 0 Then GUI__PROP_TYPE_OBJ = 3
												IF INSTR(GUI__PROP_TYPE, "TYPE:4") > 0 Then GUI__PROP_TYPE_OBJ = 4
												IF INSTR(GUI__PROP_TYPE, "TYPE:5") > 0 Then GUI__PROP_TYPE_OBJ = 5
												IF INSTR(GUI__PROP_TYPE, "TYPE:6") > 0 Then GUI__PROP_TYPE_OBJ = 6
												IF INSTR(GUI__PROP_TYPE, "TYPE:7") > 0 Then GUI__PROP_TYPE_OBJ = 7
												IF INSTR(GUI__PROP_TYPE, "TYPE:8") > 0 Then GUI__PROP_TYPE_OBJ = 8

												
												IF INSTR(GUI__PROP_TYPE, "BORD:0") > 0 Then GUI__PROP_TYPE_BORDURE = 0
												IF INSTR(GUI__PROP_TYPE, "BORD:1") > 0 Then GUI__PROP_TYPE_BORDURE = 1
												IF INSTR(GUI__PROP_TYPE, "BORD:2") > 0 Then GUI__PROP_TYPE_BORDURE = 2
												IF INSTR(GUI__PROP_TYPE, "BORD:3") > 0 Then GUI__PROP_TYPE_BORDURE = 3
												IF INSTR(GUI__PROP_TYPE, "BORD:4") > 0 Then GUI__PROP_TYPE_BORDURE = 4
												IF INSTR(GUI__PROP_TYPE, "BORD:5") > 0 Then GUI__PROP_TYPE_BORDURE = 5

												IF INSTR(GUI__PROP_TYPE, "BORDER:0") > 0 Then GUI__PROP_TYPE_BORDURE = 0
												IF INSTR(GUI__PROP_TYPE, "BORDER:1") > 0 Then GUI__PROP_TYPE_BORDURE = 1
												IF INSTR(GUI__PROP_TYPE, "BORDER:2") > 0 Then GUI__PROP_TYPE_BORDURE = 2
												IF INSTR(GUI__PROP_TYPE, "BORDER:3") > 0 Then GUI__PROP_TYPE_BORDURE = 3
												IF INSTR(GUI__PROP_TYPE, "BORDER:4") > 0 Then GUI__PROP_TYPE_BORDURE = 4
												IF INSTR(GUI__PROP_TYPE, "BORDER:5") > 0 Then GUI__PROP_TYPE_BORDURE = 5
												
												IF INSTR(GUI__PROP_TYPE, "MOVE:0") > 0 Then GUI__PROP_DEPLACABLE = False
												IF INSTR(GUI__PROP_TYPE, "MOVE:1") > 0 Then GUI__PROP_DEPLACABLE = True
												
												IF INSTR(GUI__PROP_TYPE, "SIZ:0") > 0 Then GUI__PROP_SIZEABLE_ANGL = False
												IF INSTR(GUI__PROP_TYPE, "SIZ:1") > 0 Then GUI__PROP_SIZEABLE_ANGL = True

												IF INSTR(GUI__PROP_TYPE, "PRIORITY:0") > 0 Then GUI__PROP_PRIORITY = false
												IF INSTR(GUI__PROP_TYPE, "PRIORITY:1") > 0 Then GUI__PROP_PRIORITY = True

												IF INSTR(GUI__PROP_TYPE, "MINSIZ_X:") > 0 Then 
													Dim temp_var as String = MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "MINSIZ_X:") + 9)
													GUI__PROP_MINIMAL_SIZE_X = VAL(Mid(temp_var, 1, INSTR(temp_var, "P") - 1))
												End if

												IF INSTR(GUI__PROP_TYPE, "MINSIZ_Y:") > 0 Then 
													Dim temp_var as String = MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "MINSIZ_Y:") + 9)
													GUI__PROP_MINIMAL_SIZE_Y = VAL(Mid(temp_var, 1, INSTR(temp_var, "P") - 1))
												End if

												IF INSTR(GUI__PROP_TYPE, "MAXSIZ_X:") > 0 Then 
													Dim temp_var as String = MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "MAXSIZ_X:") + 9)
													GUI__PROP_MAXIMAL_SIZE_X = VAL(Mid(temp_var, 1, INSTR(temp_var, "P") - 1))
												End if

												IF INSTR(GUI__PROP_TYPE, "MAXSIZ_Y:") > 0 Then 
													Dim temp_var as String = MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "MAXSIZ_Y:") + 9)
													GUI__PROP_MAXIMAL_SIZE_Y = VAL(Mid(temp_var, 1, INSTR(temp_var, "P") - 1))
												End if

												IF INSTR(GUI__PROP_TYPE, "COLLISION:0") > 0 Then GUI__PROP_COLLISION = false
												IF INSTR(GUI__PROP_TYPE, "COLLISION:1") > 0 Then GUI__PROP_COLLISION = True

												
												IF INSTR(GUI__PROP_TYPE, "CLOSE:1") > 0 Then GUI__PROP_FERMABLE = True
												IF INSTR(GUI__PROP_TYPE, "CLOSE:0") > 0 Then GUI__PROP_FERMABLE = false

												IF INSTR(GUI__PROP_TYPE, "TASKBAR:0") > 0 Then GUI__PROP_TASKBAR = 0
												IF INSTR(GUI__PROP_TYPE, "TASKBAR:1") > 0 Then GUI__PROP_TASKBAR = 1
												IF INSTR(GUI__PROP_TYPE, "TASKBAR:2") > 0 Then GUI__PROP_TASKBAR = 2
												
												IF INSTR(GUI__PROP_TYPE, "TASKBARHIDE:0") > 0 Then GUI__PROP_No_TASKBAR = false
												IF INSTR(GUI__PROP_TYPE, "TASKBARHIDE:1") > 0 Then GUI__PROP_No_TASKBAR = true

												
												IF INSTR(GUI__PROP_TYPE, "SIZBTN:0") > 0 Then GUI__PROP_SIZEABLE = False
												IF INSTR(GUI__PROP_TYPE, "SIZBTN:1") > 0 Then GUI__PROP_SIZEABLE = True
												
												IF INSTR(GUI__PROP_TYPE, "REDUC:0") > 0 Then GUI__PROP_REDUCTABLE = False
												IF INSTR(GUI__PROP_TYPE, "REDUC:1") > 0 Then GUI__PROP_REDUCTABLE = True
												
												IF INSTR(GUI__PROP_TYPE, "SHADOW:") > 0 Then GUI__PROP_TYPE_Ombre = VAL(MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "SHADOW:") + 7, 3))
												IF INSTR(GUI__PROP_TYPE, "OMBRE:") > 0 Then GUI__PROP_TYPE_Ombre = VAL(MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "OMBRE:") + 6, 3))
												
												IF INSTR(GUI__PROP_TYPE, "EDIT:0") > 0 Then GUI__PROP_TYPE_Editable = FALSE
												IF INSTR(GUI__PROP_TYPE, "EDIT:1") > 0 Then GUI__PROP_TYPE_Editable = TRUE
												
												IF INSTR(GUI__PROP_TYPE, "MODIF:0") > 0 Then GUI__PROP_TYPE_Editable = FALSE
												IF INSTR(GUI__PROP_TYPE, "MODIF:1") > 0 Then GUI__PROP_TYPE_Editable = TRUE
												
												
												IF INSTR(GUI__PROP_TYPE, "MULTILINES:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILINES:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE
												
												IF INSTR(GUI__PROP_TYPE, "MULTILINE:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILINE:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE
												
												IF INSTR(GUI__PROP_TYPE, "MULTILIGNE:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILIGNE:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE
												
												IF INSTR(GUI__PROP_TYPE, "MULTILIGNES:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILIGNES:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE
												
												IF INSTR(GUI__PROP_TYPE, "CONSOLE:0") > 0 Then GUI__PROP_TYPE_Console = FALSE
												IF INSTR(GUI__PROP_TYPE, "CONSOLE:1") > 0 Then GUI__PROP_TYPE_Console = TRUE

												IF INSTR(GUI__PROP_TYPE, "MENUCONTEXT:0") > 0 Then GUI__PROP_TYPE_ContextMenu = 0
												IF INSTR(GUI__PROP_TYPE, "MENUCONTEXT:1") > 0 Then GUI__PROP_TYPE_ContextMenu = 1
												IF INSTR(GUI__PROP_TYPE, "MENUCONTEXT:2") > 0 Then GUI__PROP_TYPE_ContextMenu = 2

											End if

										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURFENETRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURFENETRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURFENETRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURFENETRE = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURFENETRE=") + 21)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURFOND=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURFOND, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURFOND, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURFOND = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURFOND=") + 18)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURTITRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURTITRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURTITRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURTITRE = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURTITRE=") + 19)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURTEXTE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURTEXTE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURTEXTE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURTEXTE = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURTEXTE=") + 19)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_PX=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_PX, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_PX), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_PX = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_PX=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_PY=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_PY, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_PY), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_PY = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_PY=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TX=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TX, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_TX), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TX = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_TX=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TY=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TY, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_TY), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TY = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_TY=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:ICONE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_ICONE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_ICONE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_ICONE = MID(RetourCCP, Instr(RetourCCP, ":ICONE=") + 7)
											End if
										ELSEIF Instr(RetourCCP, "IUG:IMGTITRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_IMGTITRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_IMGTITRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_IMGTITRE = MID(RetourCCP, Instr(RetourCCP, ":IMGTITRE=") + 10)
											End if
										ELSEIF Instr(RetourCCP, "IUG:IMAGE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_IMAGE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_IMAGE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_IMAGE = LTRIM(MID(RetourCCP, Instr(RetourCCP, ":IMAGE=") + 7))
											End if
										ELSEIF Instr(RetourCCP, "IUG:VALEUR=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 

												
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_VALEUR, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_VALEUR), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_VALEUR = val(LTRIM(MID(RetourCCP, Instr(RetourCCP, ":VALEUR=") + 8)))
												
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_ALPHA=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURALPHA, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURALPHA, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURALPHA = LTRIM(MID(RetourCCP, Instr(RetourCCP, ":PROP_ALPHA=") + 12))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_EVENEMENT=") > 0 Then
											
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then 
												CpcdosCP_SHELL("SET/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_EVENEMENT, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_EVENEMENT, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_EVENEMENT = LTRIM(MID(RetourCCP, Instr(RetourCCP, ":PROP_EVENEMENT=") + 16))
												' Si la liste des evenements est indique
												IF Instr(GUI__PROP_EVENEMENT, "=") > 0 Then 
													GUI__PROP_EVENEMENT_DISPO = Ucase(LTRIM(MID(GUI__PROP_EVENEMENT, Instr(GUI__PROP_EVENEMENT, "=") + 1)))
													GUI__PROP_EVENEMENT = LTRIM(MID(GUI__PROP_EVENEMENT, 1, Instr(GUI__PROP_EVENEMENT, "=") - 1))
												Else
													GUI__PROP_EVENEMENT_DISPO = ""
												End if
											End if

										' CREATION GRAPHIQUE FINAL !
										ELSEIF Instr(RetourCCP, "IUG:CREER!") > 0 Then
											IF NOT IUG_CREATION_FENETRE = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet._CLE_ 			= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.Identification_Objet.OS_id 			= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.NOM				= IUG_CREATION_FENETRE	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.TITRE 				= GUI__PROP_TITRE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_TITRE_X		= GUI__PROP_TITRE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_TITRE_Y		= GUI__PROP_TITRE_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.TITRE_IMG_ID 			= GUI__PROP_TITRE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_TITRE_IMG_ID 	= GUI__PROP_BUFFER_TITRE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_TITRE_2_IMG_ID 	= GUI__PROP_BUFFER_TITRE_2_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_WIN_IMG_ID 		= GUI__PROP_BUFFER_WIN_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_OMBRE_WIN_IMG_ID = GUI__PROP_BUFFER_OMBRE_WIN_IMG_ID
															
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.Initialisation_OK 	= GUI__DEJA_INITIALISE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_X				= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_Y				= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_X				= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_Y				= GUI__PROP_TY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.CONTENEUR_COMPLET 	= GUI__PROP_CONTENEUR_COMPLET
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.Alpha_Mode 		= GUI__PROP_ALPHA_MODE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.IMG_TITRE			= GUI__PROP_IMGTITRE
												

												' Icone application
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.ICONE 						= GUI__PROP_ICONE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.ICONE_IMG_ID				= GUI__PROP_ICONE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.ICONE_ORG_IMG_ID			= GUI__PROP_ICONE_ORG_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_ICONE_X 				= GUI__PROP_ICONE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_ICONE_Y 				= GUI__PROP_ICONE_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_ICONE_POS 				= GUI__PROP_ICONE_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_ICONE_X 				= GUI__PROP_ICONE_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_ICONE_Y 				= GUI__PROP_ICONE_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_ICONE 					= GUI__PROP_ICONE_T
												
												' Icone bouton fermeture
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_CLOSE					= GUI__PROP_BT_CLOSE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_CLOSE_IMG_ID 			= GUI__PROP_BT_CLOSE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_CLOSE_ORG_IMG_ID 		= GUI__PROP_BT_CLOSE_ORG_IMG_ID
															
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_CLOSE_X			= GUI__PROP_BT_CLOSE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_CLOSE_Y			= GUI__PROP_BT_CLOSE_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_CLOSE_POS		= GUI__PROP_BT_CLOSE_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_CLOSE_X			= GUI__PROP_BT_CLOSE_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_CLOSE_Y			= GUI__PROP_BT_CLOSE_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_CLOSE			= GUI__PROP_BT_CLOSE_T
												
												' Icone bouton agrandissement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_SIZEUP				= GUI__PROP_BT_SIZEUP
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEUP_X		= GUI__PROP_BT_SIZEUP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEUP_Y		= GUI__PROP_BT_SIZEUP_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEUP_POS		= GUI__PROP_BT_SIZEUP_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEUP_X		= GUI__PROP_BT_SIZEUP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEUP_Y		= GUI__PROP_BT_SIZEUP_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEUP			= GUI__PROP_BT_SIZEUP_T
												
												' Icone application
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_SIZEDOWN			= GUI__PROP_BT_SIZEDOWN
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEDOWN_X 		= GUI__PROP_BT_SIZEDOWN_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEDOWN_Y		= GUI__PROP_BT_SIZEDOWN_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEDOWN_POS 	= GUI__PROP_BT_SIZEDOWN_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEDOWN_X		= GUI__PROP_BT_SIZEDOWN_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEDOWN_Y		= GUI__PROP_BT_SIZEDOWN_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEDOWN		= GUI__PROP_BT_SIZEDOWN_T
												
												' Icone application
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_REDUCT				= GUI__PROP_BT_REDUCT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_REDUCT_X		= GUI__PROP_BT_REDUCT_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_REDUCT_Y		= GUI__PROP_BT_REDUCT_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_REDUCT_POS		= GUI__PROP_BT_REDUCT_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_REDUCT_X		= GUI__PROP_BT_REDUCT_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_REDUCT_Y		= GUI__PROP_BT_REDUCT_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_REDUCT			= GUI__PROP_BT_REDUCT_T
															
												IF GUI__PROP_CONTENEUR_COMPLET = FALSE Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_TITRE		= GUI__PROP_TTITRE
												Else
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_TITRE		= 0
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE
												
												' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_R = val(Mid(GUI__PROP_COULEURFENETRE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_V = val(Mid(GUI__PROP_COULEURFENETRE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_B = val(Mid(GUI__PROP_COULEURFENETRE, 9, 3))
												
												' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur du titre de la fenetre  ===> GUI__PROP_COULEURTITRE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_TITRE_R = val(Mid(GUI__PROP_COULEURTITRE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_TITRE_V = val(Mid(GUI__PROP_COULEURTITRE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_TITRE_B = val(Mid(GUI__PROP_COULEURTITRE, 9, 3))
												
												' Couleur de l'ombre sous la fenetre  ===> GUI__PROP_TYPE_Ombre_RVB
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_OMBRE_R = val(Mid(GUI__PROP_TYPE_Ombre_RVB, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_OMBRE_V = val(Mid(GUI__PROP_TYPE_Ombre_RVB, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_OMBRE_B = val(Mid(GUI__PROP_TYPE_Ombre_RVB, 9, 3))
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Ombre_PX = GUI__PROP_OMBRE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Ombre_PY = GUI__PROP_OMBRE_PY
												
												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												' Deplacable
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Deplacable 		= GUI__PROP_DEPLACABLE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Reductable 		= GUI__PROP_REDUCTABLE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Sizeable 		= GUI__PROP_SIZEABLE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Sizeable_ANGL 	= GUI__PROP_SIZEABLE_ANGL

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.IsPriority 		= GUI__PROP_PRIORITY

												

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Minimal_size_X 	= GUI__PROP_MINIMAL_SIZE_X
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Minimal_size_Y 	= GUI__PROP_MINIMAL_SIZE_Y
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Maximal_size_X 	= GUI__PROP_MAXIMAL_SIZE_X
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Maximal_size_Y 	= GUI__PROP_MAXIMAL_SIZE_Y

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Collision	 	= GUI__PROP_COLLISION
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Fermable 		= GUI__PROP_FERMABLE

												' Barre des taches (Toujours au premier plan)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.TaskBar			= GUI__PROP_TASKBAR
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.NoTaskBar		= GUI__PROP_No_TASKBAR
												
												' Ombre sous la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Ombre = GUI__PROP_TYPE_Ombre
												
												
												' Transparence generale  ===> GUI__PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.MENU_CTX = GUI__PROP_CTX
												
												' Fichier de fonction source pour les evenement des objets
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_Click			= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseMove		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_KeyPress		= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_KeyPress 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_KeyEnter 	= TRUE
									
												End if
												
												' On cree la fenetre
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if
		
												
												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
												
											ELSEIF NOT IUG_CREATION_BOUTON = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.Identification_Objet.OS_id 		= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.Initialisation_OK = GUI__DEJA_INITIALISE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.PID_PARENT			= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.TID_PARENT			= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Handle_PARENT 		= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.NOM				= IUG_CREATION_BOUTON	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Handle				= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE			= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE", 3, _CLE_))	
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE	= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE_OPACITE", 3, _CLE_))	
												
												IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE < 0 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE = 0
												ElseIf CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE > 255 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE = 255
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE			= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_ANCIEN 	= GUI__PROP_IMAGE_ANCIEN
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_ID				= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_ORG_ID 			= GUI__PROP_IMAGE_ORG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_SURVOLE_ID 		= GUI__PROP_IMAGE_SURVOLE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_SURVOLE_ORG_ID 	= GUI__PROP_IMAGE_SURVOLE_ORG_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.BIT_ORG			= GUI__PROP_BIT_ORG ' Obtenir le pointeur du context GZE
												
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_BOUTON += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.TEXTE 		= GUI__PROP_TEXTE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.POS_Y		= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.SIZ_Y		= GUI__PROP_TY
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_KeyPress	= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_Click		 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_KeyPress 		= TRUE

									
												End if
												

												
												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											ELSEIF NOT IUG_CREATION_PICTUREBOX = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.Identification_Objet.OS_id 		= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.Initialisation_OK 	= GUI__DEJA_INITIALISE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.PID_PARENT			= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.TID_PARENT			= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Handle_PARENT 		= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.NOM				= IUG_CREATION_PICTUREBOX ' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Handle				= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMAGE			= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMAGE_ANCIEN 	= GUI__PROP_IMAGE_ANCIEN
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_ID		 	= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_ORG_ID		= GUI__PROP_IMAGE_ORG_ID
												
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_PTR			= GUI__PROP_IMAGEPTR ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_PTR_ORG		= GUI__PROP_IMAGEPTR_ORG ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_PTR_ANCIEN	= GUI__PROP_IMAGEPTR_ANCIEN ' Obtenir le pointeur du context GZE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.BIT_ORG			= GUI__PROP_BIT_ORG
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_PICTUREBOX += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.POS_Y		= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.SIZ_Y		= GUI__PROP_TY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Surbrillance = GUI__PROP_SURBRILLE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												
												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE
												
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
												
												' Couleur fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_KeyPress	= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_KeyPress 		= TRUE
									
												End if

												
												' Creer le picturebox
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PictureBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PictureBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
												
											ELSEIF NOT IUG_CREATION_TEXTEBLOCK = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.Identification_Objet.OS_id 		= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.Initialisation_OK = GUI__DEJA_INITIALISE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.THREAD_PARENT	= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Index_FNT_PARENT = GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.NOM				= IUG_CREATION_TEXTEBLOCK	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_TEXTBLOCK += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.TEXTE 		= GUI__PROP_TEXTE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.POS_Y		= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.SIZ_Y		= GUI__PROP_TY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE

												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fond_Couleur = GUI__PROP_Fond_Couleur
												
												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_KeyPress	= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseEnter = TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseLeave = TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK")	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseClick = TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_KeyPress 	= TRUE
									
												End if
												
												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBlock, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBlock, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
												
											ELSEIF NOT IUG_CREATION_TEXTEBOX = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Identification_Objet.OS_id 		= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Initialisation_OK = GUI__DEJA_INITIALISE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.THREAD_PARENT	= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Index_FNT_PARENT = GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.NOM				= IUG_CREATION_TEXTEBOX	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.IUG_UPDATER 		= GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_TEXTBOX += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.TEXTE 				= GUI__PROP_TEXTE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Image 				= GUI__PROP_EditBar
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Image_2 			= GUI__PROP_EditBar_L
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.IMG_ID		 		= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.IMG_ORG_ID		 	= GUI__PROP_IMAGE_ORG_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Editable = GUI__PROP_TYPE_Editable
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Multi_Lignes = GUI__PROP_TYPE_MultiLignes
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Console = GUI__PROP_TYPE_Console

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.POS_X				= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.POS_Y				= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.SIZ_X				= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.SIZ_Y				= GUI__PROP_TY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE

												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE


												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_Fond_Couleur
												
												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_Click			= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseMove		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_KeyPress		= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseEnter	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_KeyPress 	= TRUE
									
												End if
												
												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_TEXTBOX_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
											ELSEIF NOT IUG_CREATION_PROGRESSBAR = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet._CLE_ 			= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.Identification_Objet.OS_id 			= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.Initialisation_OK 						= GUI__DEJA_INITIALISE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.NOM				= IUG_CREATION_PROGRESSBAR	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IUG_UPDATER 							= GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_PROGRESSBAR += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.TEXTE 									= GUI__PROP_TEXTE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.VALEUR 								= GUI__PROP_VALEUR

												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMAGE									= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMAGE_ANCIEN 							= GUI__PROP_IMAGE_ANCIEN
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_ID		 							= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_prog_ID		 					= GUI__PROP_IMAGE_prog_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_ORG_ID								= GUI__PROP_IMAGE_ORG_ID
												
												
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_PTR								= GUI__PROP_IMAGEPTR ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_PTR_ORG							= GUI__PROP_IMAGEPTR_ORG ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_PTR_ANCIEN							= GUI__PROP_IMAGEPTR_ANCIEN ' Obtenir le pointeur du context GZE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.BIT_ORG								= GUI__PROP_BIT_ORG
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Multi_Lignes 				= GUI__PROP_TYPE_MultiLignes

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.POS_X									= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.POS_Y									= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.SIZ_X									= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.SIZ_Y									= GUI__PROP_TY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.LES_TYPES 					= GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.AutoSizeIMG 					= GUI__PROP_AUTOSIZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE


												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE


												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Alpha 						= val(GUI__PROP_COULEURALPHA)
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Bordure 						= GUI__PROP_TYPE_BORDURE
												
												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fond_Couleur 				= GUI__PROP_Fond_Couleur
												
												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fichier_evenement 			= GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Liste_Evenements				= GUI__PROP_EVENEMENT_DISPO
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_Click			= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseMove		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_KeyPress		= FALSE
												
													' Et on autorise certain evenements													
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_Click		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_KeyPress 	= TRUE
									
												End if
												
												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_PROGRESSBAR_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
											ELSEIF NOT IUG_CREATION_CHECKBOX = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet._CLE_ 			= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.Identification_Objet.OS_id 			= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.Initialisation_OK 					= GUI__DEJA_INITIALISE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.THREAD_PARENT	= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.NOM				= IUG_CREATION_CHECKBOX	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IUG_UPDATER 							= GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_CHECKBOX += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.TEXTE 								= GUI__PROP_TEXTE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.VALEUR 								= GUI__PROP_VALEUR

												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMAGE									= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMAGE_ANCIEN 							= GUI__PROP_IMAGE_ANCIEN
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_ID		 						= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_fond_ID		 					= GUI__PROP_IMAGE_fond_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_ORG_ID							= GUI__PROP_IMAGE_ORG_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE
												
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_PTR								= GUI__PROP_IMAGEPTR ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_PTR_ORG							= GUI__PROP_IMAGEPTR_ORG ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_PTR_ANCIEN						= GUI__PROP_IMAGEPTR_ANCIEN ' Obtenir le pointeur du context GZE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.BIT_ORG								= GUI__PROP_BIT_ORG
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Multi_Lignes 				= GUI__PROP_TYPE_MultiLignes

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.POS_X									= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.POS_Y									= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.SIZ_X									= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.SIZ_Y									= GUI__PROP_TY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_TX 								= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.SX", 3, _CLE_))	
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_TY								= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.SX", 3, _CLE_))	
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_CHECKED 							= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_CHECKED", 3, _CLE_))	
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_CHECKED_SURVOLE					= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_SURVOLE_CHECKED", 3, _CLE_))	
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_NCHECKED							= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_NOCHECKED", 3, _CLE_))	
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_NCHECKED_SURVOLE					= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_SURVOLE_NOCHECKED", 3, _CLE_))	
								
												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.LES_TYPES 					= GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.AutoSizeIMG 				= GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Alpha 						= val(GUI__PROP_COULEURALPHA)
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Bordure 						= GUI__PROP_TYPE_BORDURE
												
												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fond_Couleur 				= GUI__PROP_Fond_Couleur
												
												
												' Menu contextuel
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 0
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fichier_evenement 			= GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Liste_Evenements				= GUI__PROP_EVENEMENT_DISPO
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_KeyPress		= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_Click		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_KeyPress 	= TRUE
									
												End if
												
												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_CHECKBOX_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
												
												
											ELSEIF NOT IUG_CREATION_EXPLORER = "" Then
												Dim Retour_Resultat as string
												
												
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.Identification_Objet.OS_id 		= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.Initialisation_OK = GUI__DEJA_INITIALISE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.PID_PARENT			= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.TID_PARENT			= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.Handle_PARENT 		= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.NOM				= IUG_CREATION_EXPLORER	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.identification_objet.Handle				= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_SURVOLE			= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE", 3, _CLE_))	
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_SURVOLE_OPACITE	= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE_OPACITE", 3, _CLE_))	
												
												IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_SURVOLE_OPACITE < 0 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_SURVOLE_OPACITE = 0
												ElseIf CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_SURVOLE_OPACITE > 255 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_SURVOLE_OPACITE = 255
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE			= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMAGE_ANCIEN 	= GUI__PROP_IMAGE_ANCIEN
									
															
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMG_BUFFER_ID				= GUI__PROP_IMG_BUFFER_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMG_SELECTEUR_ID 			= GUI__PROP_IMG_SELECTEUR_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMG_SCROLL_ID 			= GUI__PROP_IMG_SCROLL_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.SCROLLING_Y 				= GUI__PROP_SCROLLING_Y
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.Mode_Affichage 			= GUI__PROP_Mode_Affichage

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE
												
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMG_SURVOLE_ID 		= GUI__PROP_IMAGE_SURVOLE_ID
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IMG_SURVOLE_ORG_ID 	= GUI__PROP_IMAGE_SURVOLE_ORG_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.BIT_ORG			= GUI__PROP_BIT_ORG ' Obtenir le pointeur du context GZE
												
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_EXPLORER += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.TEXTE 		= GUI__PROP_TEXTE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.POS_Y		= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.SIZ_Y		= GUI__PROP_TY
												
												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
												' Menu contextuel
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_KeyPress	= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_Click		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__EXPLORER.PROP_TYPE.EV_KeyPress 	= TRUE

									
												End if
												

												
												' Creer l'explorer
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_EXPLORER_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											ELSEIF NOT IUG_CREATION_LISTBOX = "" Then
												Dim Retour_Resultat as string
												
												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.Identification_Objet.OS_id 		= Nouvelle_OS_ID
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.Initialisation_OK = GUI__DEJA_INITIALISE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent 
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.NOM				= IUG_CREATION_LISTBOX	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_SURVOLE							= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE", 3, _CLE_))	
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_SURVOLE_OPACITE					= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE_OPACITE", 3, _CLE_))	
												
												IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_SURVOLE_OPACITE < 0 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_SURVOLE_OPACITE = 0
												ElseIf CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_SURVOLE_OPACITE > 255 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_SURVOLE_OPACITE = 255
												End if
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE			= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMAGE_ANCIEN 	= GUI__PROP_IMAGE_ANCIEN
									
															
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMG_BUFFER_ID				= GUI__PROP_IMG_BUFFER_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMG_SELECTEUR_ID 			= GUI__PROP_IMG_SELECTEUR_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMG_SCROLL_ID 			= GUI__PROP_IMG_SCROLL_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.SCROLLING_Y 				= GUI__PROP_SCROLLING_Y
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.Mode_Affichage 			= GUI__PROP_Mode_Affichage

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Blurry_Mode = GUI__PROP_BLURRY_MODE
												
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMG_SURVOLE_ID 		= GUI__PROP_IMAGE_SURVOLE_ID
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IMG_SURVOLE_ORG_ID 	= GUI__PROP_IMAGE_SURVOLE_ORG_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.BIT_ORG			= GUI__PROP_BIT_ORG ' Obtenir le pointeur du context GZE
												
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_LISTBOX += 1
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.TEXTE 		= GUI__PROP_TEXTE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.ContextMenu = GUI__PROP_TYPE_ContextMenu
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.POS_Y		= GUI__PROP_PY
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.SIZ_Y		= GUI__PROP_TY
												
												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Mode bureau
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.DESKTOPMODE = GUI__PROP_TYPE_DESKTOPMODE
												
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE
												
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))
												
												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))
												
												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)
												
												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE
												
												if GUI__PROP_CTX = -1 then GUI__PROP_CTX = 1
												' Menu contextuel
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.MENU_CTX = GUI__PROP_CTX

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO
												
												
												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then
													
													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_KeyPress	= FALSE
												
													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_Click		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__LISTBOX.PROP_TYPE.EV_KeyPress 	= TRUE

									
												End if
												

												
												' Creer la listbox
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Listbox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_LISTBOX_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Listbox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											End if
											
											Nouvelle_Cle_GUI = Nouvelle_Cle
											
											' Remettre les proprietes de type a zero
											GUI__PROP_UPDATER = 0 
											GUI__PROP_AUTOSIZE = 0
											
											GUI__Index_ENFANT = 0
											GUI__Handle = 0
								
											IUG_CREATION_FENETRE 		= ""
											IUG_CREATION_BOUTON 		= ""
											IUG_CREATION_PICTUREBOX 	= ""
											IUG_CREATION_TEXTEBOX 		= ""
											IUG_CREATION_TEXTEBLOCK 	= ""
											IUG_CREATION_PROGRESSBAR 	= ""
											IUG_CREATION_CHECKBOX 		= ""
											IUG_CREATION_EXPLORER 		= ""
											IUG_CREATION_LISTBOX 		= ""
											
											GUI__PROP_VALEUR 			= 0
											
											GUI__PROP_CONTENEUR_COMPLET = false
											GUI__PROP_ALPHA_MODE 		= 0
											GUI__PROP_BLURRY_MODE 		= 0
											GUI__PROP_SURBRILLE 		= 0
											Modification_IUG 			= false
											GUI__PROP_TYPE_OBJ 			= 0
											GUI__PROP_TYPE_DESKTOPMODE 	= false
											GUI__PROP_DEPLACABLE		= true
											GUI__PROP_REDUCTABLE		= true
											GUI__PROP_SIZEABLE			= true
											GUI__PROP_SIZEABLE_ANGL	 	= true

											GUI__PROP_PRIORITY			= false

											GUI__PROP_MINIMAL_SIZE_X	= 0
											GUI__PROP_MINIMAL_SIZE_Y	= 0
											GUI__PROP_MAXIMAL_SIZE_X	= 0
											GUI__PROP_MAXIMAL_SIZE_Y	= 0

											GUI__PROP_COLLISION			= true
											GUI__PROP_FERMABLE	 		= true
											GUI__PROP_TASKBAR			= 0
											GUI__PROP_No_TASKBAR		= false
											GUI__PROP_TYPE_BORDURE 		= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BORD", 3, _CLE_))
											GUI__PROP_TYPE_Ombre 		= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW", 3, _CLE_))
											GUI__PROP_COULEURALPHA 		= CCP_Lire_Variable("CPC_GUI.WINDOW.ALPHA", 3, _CLE_)

											' Et les couleurs etc. par defaut
											GUI__PROP_COULEURTITRE  	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_RGB", 3, _CLE_)
											GUI__PROP_COULEURTEXTE   	= CCP_Lire_Variable("CPC_GUI.TEXT_RGB", 3, _CLE_)
											GUI__PROP_COULEURFENETRE  	= CCP_Lire_Variable("CPC_GUI.WINDOW.RGB", 3, _CLE_)
											GUI__PROP_COULEURFOND 		= CCP_Lire_Variable("CPC_GUI.WINDOW.BACKGROUND_RGB", 3, _CLE_)
											GUI__PROP_COULEUR		 	= CCP_Lire_Variable("CPC_GUI.RGB", 3, _CLE_)
											
											GUI__PROP_TYPE_Console		= FALSE
											
											GUI__PROP_IMG_BUFFER_ID		= 0
											GUI__PROP_IMG_SELECTEUR_ID	= 0
											GUI__PROP_IMG_SCROLL_ID	= 0

											GUI__PROP_SCROLLING_Y = 0
											GUI__PROP_Mode_Affichage = 0
											
											' Menu contextuel
											GUI__PROP_CTX = -1
											
											' Pour eviter la redondance.
											GUI__PROP_EVENEMENT			= "" 
											GUI__PROP_EVENEMENT_DISPO	= ""
										End if
									END IF
									
									
									If Instr(RetourCCP, "FIX_NIVEAU") > 0 Then
										IF RetourCCP = "FIX_NIVEAU1" Then Niveau_2 = 1
										ELSEIF RetourCCP = "FIX_NIVEAU2" Then Niveau_2 = 2
										ELSEIF RetourCCP = "FIX_NIVEAU3" Then Niveau_2 = 3
										ELSEIF RetourCCP = "FIX_NIVEAU4" Then Niveau_2 = 4
										ELSEIF RetourCCP = "FIX_NIVEAU5" Then Niveau_2 = 5
									END IF
								End if ' SI Buffer_lecture > 0
							End if
							
							Buffer_lecture = ""
							Position_DEBUT = Position_FIN
' NoLGNSaut:
						Wend
_FIN_EXE_CCP_EXE:
						
						' Fonction CpcdosC+ introuvable
						IF Si_Non_EXE_FONCT = 1 Then
							Message_erreur = ERRAVT("ERR_050", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & ". Function name : " & CCP_Fonction_EXEC & " with " & CCP_Fonction_ARGS_N & " argument(s).", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
							CpcdosCP_SHELL = "ERR_050"
						End if
						
						ENTRER_SectionCritique()
						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] End executing " & Nom_Fichier, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						' Vider les variables utilises pour la creation de l'instance en memoire pour l'execution du code CpcdosC+
						Gest_variables_Suppr ("_EXE_PATH_", 	2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_PATH_F_", 	2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_PID_", 		2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_TID_", 		2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_DATE_", 	2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Memory cleaning [OK] (PID:" & Auth_PID & " TID:" & Nouvelle_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						SORTIR_SectionCritique()

						IF LEN(LabelAChercher) > 0 Then
							Message_erreur = ERRAVT("ERR_013", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & " --> :" & LabelAChercher & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						
					End scope
					
						if CCP_discretion = false Then CPCDOS_INSTANCE.En_Charge(false)
					
					End if ' Erreur interne de CPinti
				Else
					' Fichier existe pas
					Message_erreur = ERRAVT("ERR_015", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Param & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				' Instance impossible
				Message_erreur = ERRAVT("ERR_048", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Param & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			
			' ===================================================================
			END SCOPE
			
			
			
			exit _scope_CMD, _scope
		End if ' **** EXE/ ****	
		
	_end_scope_CMD
	
	_scope_CMD
	
		' ===============================================================
		'  Commande affichage d'une boite de dialogue
		' ===============================================================
		CommLang(2) = "msgbox/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " msgbox/                    Display an graphical message box"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'MSGBOX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fuctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to display an message box for user"
					Mess_Aide = Mess_Aide & CRLF & "    There are 5 types and 4 modes"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Arguments :"
					Mess_Aide = Mess_Aide & CRLF & "    /Title:Title of mesage"
					Mess_Aide = Mess_Aide & CRLF & "    /Error:Error type number"
					Mess_Aide = Mess_Aide & CRLF & "    /Type:Message type (yes,no,cancel..)"
					Mess_Aide = Mess_Aide & CRLF & "    /EVENT:Event file"
					Mess_Aide = Mess_Aide & CRLF & "    /Name:Window name"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Error type associated with an icon"
					Mess_Aide = Mess_Aide & CRLF & "    - 0 : (By default) Simple message"
					Mess_Aide = Mess_Aide & CRLF & "    - 1 : Information"
					Mess_Aide = Mess_Aide & CRLF & "    - 2 : Question"
					Mess_Aide = Mess_Aide & CRLF & "    - 3 : Caution"
					Mess_Aide = Mess_Aide & CRLF & "    - 4 : Error"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Event (By default):"
					Mess_Aide = Mess_Aide & CRLF & "     OK_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     YES_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     NO_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     CANCEL_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Message type :"
					Mess_Aide = Mess_Aide & CRLF & "    - 0 : (By default) "
					Mess_Aide = Mess_Aide & CRLF & "    - 1 : Yes, No buttons"
					Mess_Aide = Mess_Aide & CRLF & "    - 2 : BYes, No and Cancel button"
					Mess_Aide = Mess_Aide & CRLF & "    - 3 : OK button + Textbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Example 1 - Display an simple message"
					Mess_Aide = Mess_Aide & CRLF & "     msgbox/ Hello, I'm msgbox !"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Example 2 - Display an message with title + Caution"
					Mess_Aide = Mess_Aide & CRLF & "     Msgbox/ I like ONLY bananas ! /TITLE:Hello /ERROR:3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Example 3 - Yes/No question + Event"
					Mess_Aide = Mess_Aide & CRLF & "     Msgbox/ shutdown computer ? /ERROR:2 /TYPE:1 /EVENT:File.cpc"
					Mess_Aide = Mess_Aide & CRLF & "    When user will click on button, cpcdos will execute"
					Mess_Aide = Mess_Aide & CRLF & "    CLIC() function example"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Nettoyer les blancs
			
			Dim as integer FR_Titre, FR_Erreur, FR_Type, FR_EV, FR_Nom
			Dim as String STR_FR_Titre, STR_FR_Erreur, STR_FR_Type, STR_FR_EV, STR_FR_Nom
			
			Dim as integer EN_Titre, EN_Erreur, EN_Type, EN_EV, EN_Nom
			Dim as String STR_EN_Titre, STR_EN_Erreur, STR_EN_Type, STR_EN_EV, STR_EN_Nom
			
			Dim as String  STR_Titre, STR_Erreur, STR_Type, STR_EV, STR_Nom, STR_Message
			
			Dim Suite_msg as Integer
			
			STR_FR_Titre 	= "/TITRE:" 	: STR_EN_Titre 	= "/TITLE:"
			STR_FR_Erreur 	= "/ERREUR:" 	: STR_EN_Erreur = "/ERROR:"
			STR_FR_Type 	= "/TYPE:" 		: STR_EN_Type 	= "/TYPE:"
			STR_FR_EV 		= "/EVENEMENT:" : STR_EN_EV 	= "/EVENT:"
			STR_FR_Nom 		= "/NOM:" 		: STR_EN_Nom 	= "/NAME:"


			Param = Ltrim(Ltrim(Rtrim(Rtrim(Param), chr(09))), chr(09))
			
			Suite_msg = INSTR(Param, " /")
			STR_Message = Mid(Param, 1, Suite_msg - 1)
			
			FR_Titre = Instr(Ucase(Param), 	STR_FR_Titre)
			FR_Erreur = Instr(Ucase(Param), STR_FR_Erreur)
			FR_Type = Instr(Ucase(Param), 	STR_FR_Type)
			FR_EV = Instr(Ucase(Param), 	STR_FR_EV)
			FR_Nom = Instr(Ucase(Param), 	STR_FR_Nom)
			
			EN_Titre = Instr(Ucase(Param), 	STR_EN_Titre)
			EN_Erreur = Instr(Ucase(Param), STR_EN_Erreur)
			EN_Type = Instr(Ucase(Param), 	STR_EN_Type)
			EN_EV = Instr(Ucase(Param), 	STR_EN_EV)
			EN_Nom = Instr(Ucase(Param), 	STR_EN_Nom)
			
			' *****************
			' *** T I T R E ***
			' *****************
			
			IF FR_Titre > 0 Then
				Dim Suite as Integer = INSTR(FR_Titre, Param, " /")
				
				FR_Titre += Len(STR_FR_Titre)
				
				IF Suite > 0 Then
					STR_Titre = MID(Param, FR_Titre, Suite - FR_Titre) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Titre = MID(Param, FR_Titre)
				End if
			ElseIf EN_Titre > 0 Then
				Dim Suite as Integer = INSTR(EN_Titre, Param, " /")
				
				EN_Titre += Len(STR_EN_Titre)
				
				IF Suite > 0 Then
					STR_Titre = MID(Param, EN_Titre, Suite - EN_Titre) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Titre = MID(Param, EN_Titre)
				End if
			End if
			
			' *******************
			' *** E R R E U R ***
			' *******************
			
			IF FR_Erreur > 0 Then
				Dim Suite as Integer = INSTR(FR_Erreur, Param, " /")
				
				FR_Erreur += Len(STR_FR_Erreur)
				
				IF Suite > 0 Then
					STR_Erreur = MID(Param, FR_Erreur, Suite - FR_Erreur) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Erreur = MID(Param, FR_Erreur)
				End if
			ElseIf EN_Erreur > 0 Then
				Dim Suite as Integer = INSTR(EN_Erreur, Param, " /")
				
				EN_Erreur += Len(STR_EN_Erreur)
				
				IF Suite > 0 Then
					STR_Erreur = MID(Param, EN_Erreur, Suite - EN_Erreur) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Erreur = MID(Param, EN_Erreur)
				End if
			End if
			
			' ***************
			' *** T Y P E ***
			' ***************
			
			IF FR_Type > 0 Then
				Dim Suite as Integer = INSTR(FR_Type, Param, " /")
				
				FR_Type += Len(STR_FR_Type)
				
				IF Suite > 0 Then
					STR_Type = MID(Param, FR_Type, Suite - FR_Type) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Type = MID(Param, FR_Type)
				End if
			ElseIf EN_Type > 0 Then
				Dim Suite as Integer = INSTR(EN_Type, Param, " /")
				
				EN_Type += Len(STR_EN_Type)
				
				IF Suite > 0 Then
					STR_Type = MID(Param, EN_Type, Suite - EN_Type) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Type = MID(Param, EN_Type)
				End if
			End if
			
			' *************************
			' *** E V E N E M E N T ***
			' *************************
			
			IF FR_EV > 0 Then
				Dim Suite as Integer = INSTR(FR_EV, Param, " /")
				
				FR_EV += Len(STR_FR_EV)
				
				IF Suite > 0 Then
					STR_EV = MID(Param, FR_EV, Suite - FR_EV) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_EV = MID(Param, FR_EV)
				End if
			ElseIf EN_EV > 0 Then
				Dim Suite as Integer = INSTR(EN_EV, Param, " /")
				
				EN_EV += Len(STR_EN_EV)
				
				IF Suite > 0 Then
					STR_EV = MID(Param, EN_EV, Suite - EN_EV) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_EV = MID(Param, EN_EV)
				End if
			End if
			
			' *************
			' *** N O M ***
			' *************
			
			IF FR_Nom > 0 Then
				Dim Suite as Integer = INSTR(FR_Nom, Param, " /")
				
				FR_Nom += Len(STR_FR_Nom)
				
				IF Suite > 0 Then
					STR_Nom = MID(Param, FR_Nom, Suite - FR_Nom) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Nom = MID(Param, FR_Nom)
				End if
			ElseIf EN_Nom > 0 Then
				Dim Suite as Integer = INSTR(EN_Nom, Param, " /")
				
				EN_Nom += Len(STR_EN_Nom)
				
				IF Suite > 0 Then
					STR_Nom = MID(Param, EN_Nom, Suite - EN_Nom) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Nom = MID(Param, EN_Nom)
				End if
			End if
			
			CPCDOS_INSTANCE.SCI_INSTANCE.creer_Msgbox(STR_Nom, STR_Message, STR_Titre, val(STR_Erreur), val(STR_Type), STR_EV, _CLE_)
		
			
			'Scope
				'Dim handle_num 	as Integer
				'Dim Arguments 	as String = STR_Message
				
				' Concatener les arguments selon ce qui a ete ecrit
				'if NOT STR_Titre = "" Then 	Arguments += "," & STR_Titre
				'if NOT STR_Erreur = "" Then Arguments += "," & STR_Erreur
				'if NOT STR_Type = "" Then 	Arguments += "," & STR_Type
				'if NOT STR_EV = "" Then 	Arguments += "," & STR_EV
				'if NOT STR_Nom = "" Then 	Arguments += "," & STR_Nom
				
				

				

				' Pour recuperer le numero de PID si le @# a ete definit
				'if NOT CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour = "" Then
				'	CpcdosCP_SHELL("@#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " txt/ /F:Gui.MsgBox(" & Arguments & ")", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				'Else
				'	CpcdosCP_SHELL("txt/ /F:Gui.MsgBox(" & Arguments & ")", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				'End if
				
				
			'End Scope
			
			' ====================================================================
			END SCOPE
			
			exit _scope_CMD, _scope
		End if ' **** MSGBOX/ ****
	
	_end_scope_CMD
	
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour creer / stopper un serveur TCP
		' ===============================================================
		CommLang(2) = "server/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			CommandesAide = CommandesAide & CRLF & " Server/                    Start or stop a TCP server with your port number"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to start or stop a TCP/UDP server"
					Mess_Aide = Mess_Aide & CRLF & "   You can also start a TCP client connection"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  CCP mode=Line command interpretation in CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF & "  TEL mode=Telnet interpretation under CpcdosC+ console"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples sreate a TCP server :"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple server on 1234 port (VAR mode by default) :"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple server on 1234 port with CCP mode specified:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /MODE:CCP /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple server on 1234 port with TELNET or TEL mode specified:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /MODE:TELNET /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple echo server on 1234 port with ECHO mode specified:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /MODE:ECHO /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Stopping server with his port number:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /Stop:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Send message for specific connected client (socket number:8):"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /send:1234 TCP#8=Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   - Send message for all connected client (ex:4321):"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /send:1234 Hello all!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remark: This command return '1' if server has been created."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : ping/ , download/ , client/ "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			Dim posCMD2deSRV as integer
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			
			' Numero de port du serveur
			Dim Port_du_Serveur 		as Integer
			
			' Mode : RAW ou Admin
			Dim ModeDuServeurR			as String
			
			' Resultat: 1:TCP raw , 2:TCP admin , 3:UDP raw, 23:Telnet
			Dim Type_Serveur			as Integer
			
			' 0:Creer serveur , 1:Envoyer , 2:Recevoir , 3:STOP
			Dim Action					as integer
			
			Dim NombreUtilisateur		as integer = 8 ' 8 par defaut
			
			' Donnees recu ou a envoyer
			Dim DONNEES					as String
			
			' Arguments checker
			Dim PosSrvMode				as Integer
			Dim Pos2pTcp				as Integer
			Dim Pos2pUdp				as Integer

			Dim Pos2PStop				as Integer
			Dim Pos2PEnvoyer			as Integer
			Dim Pos2PSend				as Integer
			Dim Pos2PRecevoir			as Integer
			Dim Pos2PReceive			as Integer
			
			Dim Pos2ATTENDRE			as integer
			Dim Pos2WAIT				as integer
			Dim TempsAttente			as Double

			' IF Len(Param) < 4 then Goto SERVEUR_ParamDispo
			
			' Creation d'un serveur TCP/UDP
			Pos2pTcp 		= Instr(UCASE(Param), "/TCP:")
			Pos2pUdp 		= Instr(UCASE(Param), "/UDP:")
			
			' Mode CONSOLE ou Mode RAW (par defaut)
			PosSrvMode 		= instr(UCASE(Param), "/MODE:")
			
			' Discuter avec le buffer
			Pos2PEnvoyer	= Instr(UCASE(Param), "/ENVOYER:") ' Envoyer
			Pos2PSend		= Instr(UCASE(Param), "/SEND:") 	' Envoyer
			Pos2PRecevoir	= Instr(UCASE(Param), "/RECEVOIR:")' Receptionner
			Pos2PReceive	= Instr(UCASE(Param), "/RECEIVE:") ' Receptionner
			
			Pos2ATTENDRE	= Instr(UCASE(Param), "/ATTENDRE") ' Attendre la reception
			Pos2WAIT		= Instr(UCASE(Param), "/WAIT") 	' Attendre la reception
			
			' Arreter un serveur ou client
			Pos2PStop 		= Instr(UCASE(Param), "/STOP:")
			
			posCMD2deSRV 	= Instr(UCASE(Param), "SERVEUR/")
			if posCMD2deSRV < 1 then posCMD2deSRV = Instr(UCASE(Param), "SERVER/")


			' Verifier si les parametres ne sont pas suivit via une autre instance de 'SERVEUR/
			if posCMD2deSRV > 0 then
				if PosSrvMode 		>= posCMD2deSRV+5 then PosSrvMode 		= 0
				if Pos2PEnvoyer		>= posCMD2deSRV+8 then Pos2PEnvoyer		= 0
				if Pos2PSend		>= posCMD2deSRV+5 then Pos2PSend 		= 0
				if Pos2PRecevoir 	>= posCMD2deSRV+9 then Pos2PRecevoir 	= 0
				if Pos2PReceive		>= posCMD2deSRV+8 then Pos2PReceive 	= 0
				if Pos2pTcp 		>= posCMD2deSRV+4 then Pos2pTcp 		= 0
				if Pos2pUdp 		>= posCMD2deSRV+4 then Pos2pUdp 		= 0
				if Pos2PStop 		>= posCMD2deSRV+5 then Pos2PStop 		= 0
				if Pos2ATTENDRE		>= posCMD2deSRV+8 then Pos2ATTENDRE		= 0
				if Pos2WAIT			>= posCMD2deSRV+4 then Pos2WAIT			= 0
			end if

			' Envoyer les donnees
			If Pos2PEnvoyer > 0 then ' (SERVEUR/ /ENVOYER:[NoPort] Blablablabla..)
				Action = 1 ' Envoyer
				
				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PEnvoyer, Param, " ")
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PEnvoyer + 9, PosEspace - (Pos2PEnvoyer + 9)))), CHR(09)))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)

			Elseif Pos2PSend > 0 then ' (SERVEUR/ /SEND:[NoPort] Blablablabla..)
				Action = 1 ' Send
				
				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PSend, Param, " ")
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PSend + 6, PosEspace - (Pos2PSend + 6))), CHR(09))))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)
				
			' Recevoir des donnees
			Elseif Pos2PRecevoir > 0 then ' (SERVEUR/ /RECEVOIR:[NoPort])
				Action = 2 ' Recevoir
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PRecevoir + 10)), CHR(09))))
				
				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if
				
				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0
				
			Elseif Pos2PReceive > 0 then ' (SERVEUR/ /RECEIVE:[NoPort])
				Action = 2 ' Recevoir
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PReceive + 9))), CHR(09)))
				
				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if
				
				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0
			
			' ==== Protocole   T C P ==== (SERVEUR/ /TCP:[NoPort])
			ElseIf Pos2pTcp > 0 Then ' TCP
				Type_Serveur = 1
				Action = 0 ' creer
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2pTcp + 5)), CHR(09))))
	
			' ==== Protocole   U D P ====
			ElseIF Pos2pUdp > 0 Then ' UDP (SERVEUR/ /UDP:[NoPort])
				Type_Serveur = 2
				Action = 0 ' creer
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2pUdp + 5)), CHR(09))))
				
			' Arreter le serveur
			Elseif Pos2PStop > 0 Then ' (SERVEUR/ /STOP:[NoPort])
				Action = 3 ' arreter
				
				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PStop + 6)), CHR(09))))
				
			Else
	SERVEUR_ParamDispo:
					DEBUG("[CpcdosC+] Avaiable Parameters : /TCP:[No Port], /UDP:[No Port] , /SEND:[No Port] [TCP#[NoSocket]=] [UDP#[NoSocket]=]Data, /RECEIVE:[No Port]  , /STOP:[No Port]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				exit _scope_CMD, _scope
			End if
			
			' Mode du serveur (TCP, UDP, TCP admin (CCP) , Telnet ou Echo
			if PosSrvMode > 0 then
				ModeDuServeurR = Ucase(MID(Param, PosSrvMode + 6, 3))
				If ModeDuServeurR = "CCP" OR ModeDuServeurR = "TEL" OR ModeDuServeurR = "ECH" then
					' Acc�s a la console d'administration en CpcdosC+
					
					if Type_Serveur = 3 then
						' Serveur d'administrateur en UDP --> A eviter!
						
						Message_erreur = ERRAVT("AVT_067", 0) ' UDP en admin
							DEBUG("[CpcdosC+] " & Message_erreur & ". TCP will be used.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					end if
					
					if ModeDuServeurR = "CCP" Then
						Type_Serveur = 3 ' TCP admin (CCP)
					ElseIF ModeDuServeurR = "TEL" Then
						Type_Serveur = 4 ' TCP admin (Telnet)
					ElseIF ModeDuServeurR = "ECH" Then
						Type_Serveur = 5 ' TCP Echo 
					End if
					
				Elseif ModeDuServeurR = "STD" then
					' STanDard (Defaut) : Reception&Envoie des donnees via un buffer publique
					
				else
					' Si le mode specifie n'existe pas
						DEBUG("[CpcdosC+] Avaiable modes : STD, CCP.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
			else
				' Si aucun mode est specifie, par defaut il s'agit de STD
				ModeDuServeurR = "STD"
			End if
			Dim Resultat as integer = 0
			
			If Action = 1 Then ' Envoyer
				' **** Receptionner les donnees ****
				
				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.ENVOYER_Serveur(DONNEES, Port_du_Serveur, Auth_PID, RetourVAR)
				
			ElseIf Action = 2 Then
				' **** Receptionner les donnees ****
				
				IF Pos2ATTENDRE > 0 OR Pos2WAIT > 0 Then
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Serveur(Port_du_Serveur, Auth_PID, RetourVAR, TRUE, TempsAttente)
				Else
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Serveur(Port_du_Serveur, Auth_PID, RetourVAR, FALSE, 0)
				End if
				
			ElseIf Action = 3 Then
				' **** Arreter un serveur ****

				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.STOP_Serveur(Port_du_Serveur, Auth_PID, RetourVAR)
				
			ElseIf Action = 0 Then
				' **** Creer un serveur TCP/UDP ****

				if Type_Serveur = 1 OR Type_Serveur = 3 OR Type_Serveur = 4 OR Type_Serveur = 5 Then
					
					' Creer un serveur TCP
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.Serveur_TCP(Port_du_Serveur, NombreUtilisateur, Auth_PID, Type_Serveur, RetourVAR)
					
				ElseIf Type_Serveur = 2 OR Type_Serveur = 6 Then
				
					' Creer un serveur UDP
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.Serveur_UDP(Port_du_Serveur, NombreUtilisateur, Auth_PID, RetourVAR)
					
				End if
			Else ' Aucun
			
				
				
			end if
			
			
			IF Resultat = CPCDOS_INSTANCE._DOSBOX Then ' Mode DOSBOX
				Message_erreur = ERRAVT("AVT_055", 0)
					DEBUG("[Network] AVT_055:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ElseIf Resultat = CPCDOS_INSTANCE._SANS_Reseau Then ' Mode sans reseau ( Mode avion )
				Message_erreur = ERRAVT("AVT_072", 0)
					DEBUG("[Network] AVT_072:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -2 Then ' Erreur config socket
				Message_erreur = ERRAVT("ERR_054", 0)
				DEBUG("[Network]ERR_054: " & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -3 Then ' Driver manquant
				Message_erreur = ERRAVT("AVT_023", 0)
				DEBUG("[Network] AVT_023:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -4 Then ' Erreur binding
				DEBUG("[Network] ERR_055" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -5 Then ' Erreur ecoute
				Message_erreur = ERRAVT("ERR_056", 0)
				DEBUG("[Network] ERR_056" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -6 Then ' Erreur Select()
				Message_erreur = ERRAVT("ERR_057", 0)
				DEBUG("[Network] ERR_057:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -7 Then ' Erreur ERRPIPE
				Message_erreur = ERRAVT("ERR_058", 0)
				DEBUG("[Network] ERR_058:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -8 Then ' Erreur DNS (pour client!)
				Message_erreur = ERRAVT("AVT_071", 0)
				DEBUG("[Network] AVT_071:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -9 Then ' Erreur Memoire
				Message_erreur = ERRAVT("ERR_059", 0)
				DEBUG("[Network] ERR_059:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
			' ----------------------------------------------------------------
			
			ElseIf Resultat = -10 Then ' Port introuvable
				Dim Message_erreur as String = ERRAVT("AVT_068", 0)
				DEBUG("[Network] AVT_068:" & Message_erreur & " (" & Port_du_Serveur & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				
			ElseIf Resultat = -11 Then ' Port deja existant
				dim Message_erreur as String = ERRAVT("ERR_051", 0)
				DEBUG("[Network] ERR_051:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ElseIf Resultat = -12 Then ' Impossible de creer d'AUTRES serveurs
				dim Message_erreur as String = ERRAVT("AVT_070", 0)
				DEBUG("[Network] AVT_070:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			else
				IF Action = 0 Then
					' Serveur cree!
					DEBUG("1", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			END IF
			
			' ===================================================================
			END SCOPE
			' Fin de l'operation
			exit _scope_CMD, _scope
		End if ' **** SERVEUR/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour creer / stopper un client TCP/UDP
		' ===============================================================
		CommLang(2) = "client/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " Client/                    Start or stop a TCP/UDP client connection"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to start or stop a TCP server in CPinti"
					Mess_Aide = Mess_Aide & CRLF & "   You can also start a TCP client connection"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example connection to server as TCP client:"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ 192.168.1.7:1234"
					Mess_Aide = Mess_Aide & CRLF & "       (This command return a TID number --> Important!!)"
					Mess_Aide = Mess_Aide & CRLF & "    - Stop connection  (TID example 2803):"
					Mess_Aide = Mess_Aide & CRLF & "       client/ /stop:2803"
					Mess_Aide = Mess_Aide & CRLF & "    - Send a message to server: (Example, TID:2803):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ /Send:2803 Hello server!"
					Mess_Aide = Mess_Aide & CRLF & "    - Receive a message (Exemple, TID:2803):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ /Receive:2803"
					Mess_Aide = Mess_Aide & CRLF & "       (If server has closed connection, you will receive '#DECO')"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remark: You can redirect the TID number directly on a variable. Ex:"
					Mess_Aide = Mess_Aide & CRLF & "            @#MyTIDNumber SERVER/ /CLIENT 192.168.1.7:1234"
					Mess_Aide = Mess_Aide & CRLF & "            txt/ You TID number is %MyTIDNumber%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Server/ , ping/ , download/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			Dim posCMD2deCLIENT as integer
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			' Numero de port du serveur
			Dim Port_du_Serveur as Integer
			Dim TID_CLIENT 		as uInteger
			
			' Adresse du serveur
			Dim Adresse_du_Serveur		as String
			
			' 1:TCP , 2:TCP admin , 3:UDP
			Dim Type_Client				as integer
			
			' 0:Creer client , 1:Envoyer , 2:Recevoir , 3:STOP
			Dim Action					as integer
			' Donnees recu ou a envoyer
			Dim DONNEES					as String

			
			' Arguments checker
			Dim Pos2pTcp				as Integer
			Dim Pos2pUdp				as Integer

			Dim Pos2PStop				as Integer
			Dim Pos2PEnvoyer			as Integer
			Dim Pos2PSend				as Integer
			Dim Pos2PRecevoir			as Integer
			Dim Pos2PReceive			as Integer
			
			Dim Pos2ATTENDRE			as integer
			Dim Pos2WAIT				as integer
			Dim TempsAttente			as integer

			' IF Len(Param) < 4 then Goto SERVEUR_ParamDispo
			
			' Creation d'un client TCP/UDP
			Pos2pTcp 		= Instr(UCASE(Param), "/TCP:")
			Pos2pUdp 		= Instr(UCASE(Param), "/UDP:")
			
			
			' Discuter avec le buffer
			Pos2PEnvoyer	= Instr(UCASE(Param), "/ENVOYER:") ' Envoyer
			Pos2PSend		= Instr(UCASE(Param), "/SEND:") ' Envoyer
			Pos2PRecevoir	= Instr(UCASE(Param), "/RECEVOIR:") ' Receptionner
			Pos2PReceive	= Instr(UCASE(Param), "/RECEIVE:") ' Receptionner
			
			Pos2ATTENDRE	= Instr(UCASE(Param), "/ATTENDRE") ' Attendre la reception
			Pos2WAIT		= Instr(UCASE(Param), "/WAIT") 	' Attendre la reception
			
			' Arreter un client
			Pos2PStop 		= Instr(UCASE(Param), "/STOP:")
			
			posCMD2deCLIENT 	= Instr(UCASE(Param), "CLIENT/")
			if posCMD2deCLIENT < 1 then posCMD2deCLIENT = Instr(UCASE(Param), "CLIENT/")


			' Verifier si les parametres ne sont pas suivit via une autre instance de 'CLIENT/
			if posCMD2deCLIENT > 0 then

				if Pos2PEnvoyer		>= posCMD2deCLIENT+8 then Pos2PEnvoyer		= 0
				if Pos2PSend		>= posCMD2deCLIENT+5 then Pos2PSend 		= 0
				if Pos2PRecevoir 	>= posCMD2deCLIENT+9 then Pos2PRecevoir 	= 0
				if Pos2PReceive		>= posCMD2deCLIENT+8 then Pos2PReceive 		= 0
				if Pos2pTcp 		>= posCMD2deCLIENT+4 then Pos2pTcp 			= 0
				if Pos2pUdp 		>= posCMD2deCLIENT+4 then Pos2pUdp 			= 0
				if Pos2PStop 		>= posCMD2deCLIENT+5 then Pos2PStop 		= 0
				if Pos2ATTENDRE		>= posCMD2deCLIENT+8 then Pos2ATTENDRE		= 0
				if Pos2WAIT			>= posCMD2deCLIENT+8 then Pos2WAIT			= 0
			end if

			' ==== Protocole   T C P ==== (CLIENT/ /TCP:[NoPort])
			' Envoyer des donnees
			if Pos2PEnvoyer > 0 then ' (client/ /ENVOYER:[NoPort] Blablablabla..)
				Action = 1 ' Envoyer
				
				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PEnvoyer, Param, " ")
				
				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PEnvoyer + 9, PosEspace - (Pos2PEnvoyer + 9)))), CHR(09)))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)
				
			Elseif Pos2PSend > 0 then ' (client/ /SEND:[NoPort] Blablablabla..)
				Action = 1 ' Send
				
				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PSend, Param, " ")
				
				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PSend + 6, PosEspace - (Pos2PSend + 6))), CHR(09))))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)
				
			' Recevoir des donnees
			Elseif Pos2PRecevoir > 0 then ' (client/ /RECEVOIR:[NoPort])
				Action = 2 ' Recevoir
				
				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PRecevoir + 10)), CHR(09))))
				
				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if
				
				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0
				
			Elseif Pos2PReceive > 0 then ' (client/ /RECEIVE:[NoPort])
				Action = 2 ' Recevoir
				
				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PReceive + 9))), CHR(09)))
				
				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if
				
				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0

			ElseIf Pos2pTcp > 0 Then ' TCP
				Type_Client = 1
				Action = 0 ' creer
				
				Dim Pos2points as integer = INSTR(Pos2pTcp + 5, Param, ":")
				
				' Verifier si l'utilisateur a specifie un numero de port. Sinon c'est 80 par defaut.
				if Pos2points > 0 Then
					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(MID(Param, Pos2pTcp + 5, Pos2points - (Pos2pTcp +5))), CHR(09)))
				
					' Recuperer le port du client
					Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2points + 1)), CHR(09))))
				Else
					' Aucun numero de port specifie, on lui indique 80 par defaut (WEB/HTTP)
					Port_du_Serveur = 80
					
					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(Mid(Param, Pos2pTcp + 5)), CHR(09)))
				End if
	
			' ==== Protocole   U D P ====
			ElseIF Pos2pUdp > 0 Then ' UDP (client/ /UDP:[NoPort])
				Type_Client = 3
				Action = 0 ' creer
				
				Dim Pos2points as integer = INSTR(Pos2pUdp + 5, Param, ":")
				
				' Verifier si l'utilisateur a specifie un numero de port. Sinon c'est 80 par defaut.
				if Pos2points > 0 Then
					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(MID(Param, Pos2pUdp + 5, Pos2points - (Pos2pUdp +5))), CHR(09)))
				
					' Recuperer le port du client
					Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2points + 1)), CHR(09))))
				Else
					' Aucun numero de port specifie, on lui indique 80 par defaut (WEB/HTTP)
					Port_du_Serveur = 80
					
					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(Mid(Param, Pos2pUdp + 5)), CHR(09)))
				End if

			' Arreter le client
			Elseif Pos2PStop > 0 Then ' (client/ /STOP:[NoPort])
				Action = 3 ' arreter
				
				' Recuperer le TID
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PStop + 6)), CHR(09))))

			

			Else
					DEBUG("[CpcdosC+] Avaiable Parameters : /TCP:[IP address:port], /UDP:[IP address:port] , /SEND:[No TID] Data, /RECEIVE:[No TID], /STOP:[No TID]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				exit _scope_CMD, _scope
			End if

			Dim Resultat as integer

			If Action = 1 Then ' Envoyer
				' **** Envoyer les donnees ****
				
				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.ENVOYER_Client(DONNEES, Port_du_Serveur, TID_CLIENT, RetourVAR)
				
			ElseIf Action = 2 Then
				' **** Receptionner les donnees ****
				
				IF Pos2ATTENDRE > 0 OR Pos2WAIT > 0 Then
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Client(Port_du_Serveur, TID_CLIENT, RetourVAR, TRUE, TempsAttente)
				Else
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Client(Port_du_Serveur, TID_CLIENT, RetourVAR, FALSE, 0)
				End if

			ElseIf Action = 3 Then
				' **** Arreter un client ****
				
				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.STOP_Client(Adresse_du_Serveur, Port_du_Serveur, TID_CLIENT, RetourVAR)
				
			ElseIf Action = 0 Then
				' **** Creer un client TCP/UDP ****
				Dim Resultat_ as integer
				
				if Type_Client = 1 OR Type_Client = 2 Then
					
					' Creer un client TCP
					Resultat_ = CPCDOS_INSTANCE.RESEAU_INSTANCE.Client_TCP(Adresse_du_Serveur, Port_du_Serveur, Auth_PID, RetourVAR)

					if Resultat_ = 0 Then Resultat_ = -12
					if Resultat_ = 1 Then Resultat_ = CPCDOS_INSTANCE._DOSBOX 
					if Resultat_ = 2 Then Resultat_ = CPCDOS_INSTANCE._SANS_Reseau 
					
					if Resultat_ > 1 Then
						' Afficher le numero de TID
						DEBUG(STR(Resultat_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					
					
				ElseIf Type_Client = 3 Then
				
				
					' Creer un client UDP
					Resultat_ = CPCDOS_INSTANCE.RESEAU_INSTANCE.Client_UDP(Adresse_du_Serveur, Port_du_Serveur, Auth_PID, RetourVAR)
					
					if Resultat_ = 0 Then Resultat_ = -12
					if Resultat_ = 1 Then Resultat_ = CPCDOS_INSTANCE._DOSBOX 
					if Resultat_ = 2 Then Resultat_ = CPCDOS_INSTANCE._SANS_Reseau 
					
					if Resultat_ > 1 Then
						' Afficher le numero de TID
						DEBUG(STR(Resultat_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				End if

				
			Else ' Aucun
			
			End if
			
			IF Resultat = CPCDOS_INSTANCE._DOSBOX Then ' Mode DOSBOX
				Message_erreur = ERRAVT("AVT_055", 0)
					DEBUG("[Network] AVT_055:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ElseIF Resultat = CPCDOS_INSTANCE._SANS_Reseau Then ' Mode sans reseau ( Mode avion )
				Message_erreur = ERRAVT("AVT_072", 0)
					DEBUG("[Network] AVT_072:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -2 Then ' Erreur config socket
				Message_erreur = ERRAVT("ERR_054", 0)
				DEBUG("[Network] ERR_054:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -3 Then ' Driver manquant
				Message_erreur = ERRAVT("AVT_023", 0)
				DEBUG("[Network] AVT_023:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -4 Then ' Erreur binding
				Message_erreur = ERRAVT("ERR_055", 0)
				DEBUG("[Network] ERR_055:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -5 Then ' Erreur ecoute
				Message_erreur = ERRAVT("ERR_056", 0)
					DEBUG("[Network] ERR_056:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -6 Then ' Erreur Select()
				Message_erreur = ERRAVT("ERR_057", 0)
				DEBUG("[Network] ERR_057:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -7 Then ' Erreur ERRPIPE
				Message_erreur = ERRAVT("ERR_058", 0)
				DEBUG("[Network] ERR_058:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -8 Then ' Erreur DNS (pour client!)
				Message_erreur = ERRAVT("AVT_071", 0)
				DEBUG("[Network] AVT_071:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ELSEIF Resultat = -9 Then ' Erreur Memoire
				Message_erreur = ERRAVT("ERR_059", 0)
				DEBUG("[Network] ERR_059:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
			' ----------------------------------------------------------------
			
			ElseIf Resultat = -10 Then ' Port introuvable
				Dim Message_erreur as String = ERRAVT("AVT_068", 0)
				DEBUG("[Network] AVT_068:" & Message_erreur & " (" & Port_du_Serveur & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				
			ElseIf Resultat = -11 Then ' Port deja existant
				dim Message_erreur as String = ERRAVT("ERR_051", 0)
				DEBUG("[Network] ERR_051:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			ElseIf Resultat = -12 Then ' Impossible de creer d'AUTRES serveurs
				dim Message_erreur as String = ERRAVT("AVT_070", 0)
				DEBUG("[Network] AVT_070" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
			ElseIf Resultat = -13 Then ' TID introuvable
				Dim Message_erreur as String = ERRAVT("AVT_069", 0)
				DEBUG("[Network] AVT_069:" & Message_erreur & " (" & TID_CLIENT & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				
			END IF
			
			' Fin de l'operation
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CLIENT/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande pour se loger, creer, parametrer les comptes
		' ===============================================================
		CommLang(2) = "LOGIN/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
		
				CommandesAide = CommandesAide & CRLF & " Login/                     Open, create, modify an user account"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to manage user accounts"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   * Administrator privileges allow you to access in system without restrictions."
					Mess_Aide = Mess_Aide & CRLF & "   * Standard privileges allow you to access in system with some restrictions."
					Mess_Aide = Mess_Aide & CRLF & "   * Limited privileges allow you to access in imposed application by Administrator"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   If an action want more privilege, you will be invited to type Admin password"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Examples :"
					Mess_Aide = Mess_Aide & CRLF & "   Login as admin' (Without password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ admin"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Login as 'admin' (With password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ admin MyPassword123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Login as 'toto' (With password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ toto MyPassword123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Logout"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /close   or   Login/ /logout"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Lock opened session"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /lock"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   (Administrator privileges is expected for this commands)"
					Mess_Aide = Mess_Aide & CRLF & "   Creer un compte utilisateur standard et sans mot de passe"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /create Florian    ou    Login/ /create /std Florian"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create a standard accound (With password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /create Florian MyPassword123    ou    Login/ /create /std Florian MyPassword123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create a admin account"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer /admin Thomas"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create a limited account"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer /lim Thomas"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Debug(" La commande LOGIN/ n'est pas disponible, je sais que c'est pressant autant quand t-on a envie d'aller pisser, mais .. patience mon p'tit Cpcdosien! ;-)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End If ' **** LOGIN/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande de fermeture d'un processus
		' ===============================================================
		CommLang(2) = "close/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		REM 'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " close/                     Kill a process, thread or an object"
			
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to kill one or many process specified by his name or by his PID"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Simple killing. Close all processus with the same name"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ MY_WINDOW"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ APP1"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Killing process by PID number"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ /PID 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Killing by handle number"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ /handle 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Killing process/handle by KeyID"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ /KeyID 123456789"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : exe/"
					Mess_Aide = Mess_Aide & CRLF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Dim TypeOjetNOM		as String
			Dim Numero_INDEX	as integer = 0
			Dim TypeObjet		as integer = 0
			DIM Numero_KeyID 	as Double = 0
			DIM Numero_PID 		as integer = 0
			DIM Numero_TID 		as integer = 0
			DIM Numero_Handle 	as integer = 0
			
			Dim PosNUMcle	as integer = instr(UCASE(Param), "/CLEID") ' CleID (Decimal ou 0x hexa)
			Dim PosNUMKey	as integer = instr(UCASE(Param), "/KEYID") ' CleID (Decimal ou 0x hexa)
			Dim PosNUMCleB	as integer = instr(UCASE(Param), "/CLEIDB") ' CleID (Binaire)
			Dim PosNUMKeyB	as integer = instr(UCASE(Param), "/KEYIDB") ' CleID (Binaire)
			
			Dim PosNUMPid 	as integer = instr(UCASE(Param), "/PID") ' Procesus (Decimal ou 0x hexa)
			
			Dim PosNumTID 	as integer = instr(UCASE(Param), "/TID") ' Thread (Decimal ou 0x hexa)
			
			Dim PosNUMhandle as integer = instr(UCASE(Param), "/HANDLE") ' Handle
			
			' ===== Numero CleID =====
			IF PosNUMCle > 0 Then ' Numero de CleID
				Numero_KeyID = Val(MID(Param, PosNUMcle + 6))
				
			ElseIF PosNUMCle > 0 Then ' Numero de KeyID
				Numero_KeyID = Val(MID(Param, PosNUMcle + 6))
				
			ElseIF PosNUMCleB > 0 Then ' Numero de CleID binaire
				Numero_KeyID = Val(MID(Param, PosNUMCleB + 7))
				
			ElseIF PosNUMKeyB > 0 Then ' Numero de KeyID binaire
				Numero_KeyID = Val(MID(Param, PosNUMKeyB + 7))
			End if
			
			' ===== Numero Processus  =====
			IF PosNUMPid > 0 Then ' Numero de Processus
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_PID = Val("&h" & MID(Param, PosNUMPid + 5))
				else
					' Nombre decimal
					Numero_PID = Val(MID(Param, PosNUMPid + 5))
				End if
			End if
			
			' ===== Numero Thread =====
			IF PosNumTID > 0 Then ' Numero de Thread
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_TID = Val("&h" & MID(Param, PosNumTID + 5))
				else
					' Nombre decimal
					Numero_TID = Val(MID(Param, PosNumTID + 5))
				End if
			End if
				
			' ===== Numero Handle =====
			IF PosNumHandle > 0 Then ' Numero de handle
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_Handle = Val("&h" & MID(Param, PosNumHandle + 8))
				else
					' Nombre decimal
					Numero_Handle = Val(MID(Param, PosNumHandle + 8))
				End if
			End if
				
			' === On recupere le numero d'index et le type d'objet/instance ===
			IF Numero_KeyID > 0 Then
			
				' Chercher les fenetres
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

						' Si cest un desktop
						if CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = boucle Then
							CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = 0
						End if

						' Si c'est une taskbar
						if CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = boucle Then
							CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = 0
						end if
	
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				' Chercher les boutons
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				' Chercher les picturebox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				' Chercher les textbloc
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				

				' Chercher les TextBox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				' Chercher les checkbox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				' Chercher les Progressbar
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				' Chercher les explorer
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_EXPLORER
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle

				' Chercher les listbox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ListBox
						
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
			ElseIf Numero_PID > 0 Then
				' Supprimer un processus (Et tout ses threads)
				
				Dim NomPID as String = CPCDOS_INSTANCE.get_Nom_Processus(Numero_PID)

				' Detecter la presence d'objets graphiques
				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Search and deleting graphic objects (If present) ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				scope
					Dim NombreObjetSuppreime as integer = 0
					' Chercher les fenetres
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE - 1 ' correction : Ajout du "-1" le 08/03/2019
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.PID_PARENT = Numero_PID Then ' UN BUG ICI
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre
							
							' Si cest un desktop
							if CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = boucle Then
								CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = 0
							End if

							' Si c'est une taskbar
							if CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = boucle Then
								CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = 0
							end if

							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
					Next boucle
					
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI___OBJS - 1 ' correction : Ajout du "-1" le 08/03/2019
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)

						End if
					
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
					
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
						
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
						
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
						
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
						
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)

						End if

						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ListBox
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							NombreObjetSuppreime = NombreObjetSuppreime + 1
							
							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)

						End if
						
					Next boucle
					
					
					
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						If NombreObjetSuppreime > 0 Then
								DEBUG("[CpcdosC+] Deleting " & NombreObjetSuppreime & " terminated", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						Else
								DEBUG("[CpcdosC+] No graphic object associed", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
					End if
				
					If NombreObjetSuppreime > 0 Then
						' Si l'interface graphique est executee
						IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[CpcdosC+] Graphic actualisation", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							End if
							' Et actualiser l'interface graphique
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)
						End if
					End if
				
				End scope
				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Asking killing process " & NomPID & " (PID:" & Numero_PID & ") and his associed threads ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				CPCDOS_INSTANCE.Fermer_processus(Numero_PID)
				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Killing process " & NomPID & " (PID:" & Numero_PID & ") Sent!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				exit _scope_CMD, _scope
				
			ElseIf Numero_TID > 0 Then 
				' supprimer un thread
				
				Dim NomTID as String = CPCDOS_INSTANCE.get_Nom_Thread(Numero_TID)
				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
			
						DEBUG("[CpcdosC+] Asking killing thread '" & NomTiD & "' (PID:" & Auth_PID & "TID:" & Numero_TID & ") and his associed threads) ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				' On ne pourra supprimer le thread UNIQUEMENT du processus
				'  l'appelant ahah (Petite securite)
				CPCDOS_INSTANCE.Fermer_thread(Auth_PID, Numero_TID, false)
				
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Asking killing thread " & NomTID & " (PID:" & Auth_PID & " TID:" & Numero_TID & ") and his associed threads) Sent!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				exit _scope_CMD, _scope
			
			ElseIf Numero_Handle > 0 Then
				' Supprimer l'objet correspondant au handle
				
				TypeObjet = 0
		
				' Chercher les fenetres
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Handle = Numero_Handle Then
					
						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

						' Si c'est une fen�tre desktop, on delete!
						if CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = boucle Then
							CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = 0
						End if

						' Si c'est une taskbar
						if CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = boucle Then
							CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = 0
						end if
					
						' Et son numero d'index
						Numero_INDEX = boucle
						
						exit for
					End if
				Next boucle
				
				
				if TypeObjet = 0 Then
				
					' Chercher les boutons
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les picturebox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les textbloc
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les TextBox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les checkbox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				End if
				
				
				if TypeObjet = 0 Then
					' Chercher les Progressbar
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				End if
				
				if TypeObjet = 0 Then
				
					' Chercher les boutons
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_EXPLORER
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if

				if TypeObjet = 0 Then
				
					' Chercher les boutons
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet.Handle = Numero_Handle Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Listbox
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
				
				End if
				
			
			Else
				IF NOT Param = "" Then
					
					TypeObjet = 0
					' Si les parametres ont quelque chose on cherche par le nom
					
					' Nettoyer
					Param = Ucase(RTRIM(RTRIM(LTRIM(LTRIM(Param, chr(09))), chr(09))))
					
					' Chercher les fenetres
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Nom = Param Then
						
							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

							' Si c'est une fen�tre desktop, on delete!
							if CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = boucle Then
								CPCDOS_INSTANCE.SCI_INSTANCE.DESKTOPMODE_Index_Fenetre = 0
							End if

							' Si c'est une taskbar
							if CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = boucle Then
							 	CPCDOS_INSTANCE.SCI_INSTANCE.TaskBar_List_win = 0
							end if
							
							' Et son numero d'index
							Numero_INDEX = boucle
							
							exit for
						End if
					Next boucle
					
				
				
					if TypeObjet = 0 Then
						' Chercher les boutons
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if TypeObjet = 0 Then
						' Chercher les picturebox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if TypeObjet = 0 Then
						' Chercher les textbloc
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if TypeObjet = 0 Then
						' Chercher les TextBox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if TypeObjet = 0 Then
						' Chercher les checkbox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				
				
					if TypeObjet = 0 Then
						' Chercher les Progressbar
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
					
					if TypeObjet = 0 Then
						' Chercher les explorer
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_EXPLORER
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__EXPLORER(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Explorer
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if

					if TypeObjet = 0 Then
						' Chercher les listbox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_LISTBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__LISTBOX(boucle).Identification_Objet.Nom = Param Then
							
								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Listbox
								
								' Et son numero d'index
								Numero_INDEX = boucle
								
								exit for
							End if
						Next boucle
					End if
				Else
				
					' L'utilisateur n'a rien indique
					Message_erreur = ERRAVT("AVT_078", 0)
					DEBUG("[CpcdosC+] AVT_078 : " & Message_erreur & ". Please put name or parameter.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
			End if
			
			' Si on a trouve quelque chose
			if Numero_INDEX > 0 Then
			
			
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Deleting  ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					
				End if
				
				' Supprimer l'objet concerne
				CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
				
				' Si l'interface graphique est executee
				IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						DEBUG("[CpcdosC+] Graphic actualisation", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					End if
					' Et actualiser l'interface graphique
					CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)
				End if
			
			Else
				' Si on n'a pas trouve quelque chose
				Message_erreur = ERRAVT("AVT_077", 0)
					DEBUG("[CpcdosC+] AVT_077 : " & Message_erreur & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			End if
	'--------------------------- Fermer_Processus_par_PID(NumPID_2) --------------------------------------------
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
			
		END IF ' **** FERMER/ ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande pour configurer/afficher des Parametres du systeme
		' ===============================================================
		CommLang(2) = "sys/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " sys/                       Configure/display system informations"
			
		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'SYStem'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to setup system, or display system informations."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display free memory / used (bytes, Kb, Mb, Gb)"
					Mess_Aide = Mess_Aide & CRLF & "     Display free memory in bytes"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /mem"
					Mess_Aide = Mess_Aide & CRLF & "     Display used memory in bytes"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /memu"
					Mess_Aide = Mess_Aide & CRLF & "     Display free memory in Mb"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /mem mb"
					Mess_Aide = Mess_Aide & CRLF & "     Display used memory in Mb"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /memu mb"
					Mess_Aide = Mess_Aide & CRLF & "     ... also with Gb Giga Bytes, To for Tera Bytes."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Change font"
					Mess_Aide = Mess_Aide & CRLF & "     Sys/ /font /load_ttf"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /Font /load_char"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Enable/disable font manager"
					Mess_Aide = Mess_Aide & CRLF & "     Sys/ /font /Enable"
					Mess_Aide = Mess_Aide & CRLF & "     Sys/ /font /Disable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    Debug kernel. (Display all kernel activities)"
					Mess_Aide = Mess_Aide & CRLF & "      SYS/ /DEBUG {/CPINTICORE} {/SERVER:NoPort} = { 0, 1, 2, 3 }"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "       Display all detailled kernel activities"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Write all detailled kernel activities on DEBUG.LOG file"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 2"
					Mess_Aide = Mess_Aide & CRLF & "       Display and Write all detailled kernel activities on DEBUG.LOG file"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 3"
					Mess_Aide = Mess_Aide & CRLF & "       Stop this"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Display CPinti Core activities"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /CPintiCore = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Stop this"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /CPintiCore = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Enable COM1 debogger with by default (9600,N,8,1)"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1 = 1"
					Mess_Aide = Mess_Aide & CRLF & "       IDEM but more precise infos 9600 bauds, No parity, 8 data bits, 1 stop bit"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1:9600,N,8,1"
					Mess_Aide = Mess_Aide & CRLF & "       Disable debugger by COM1"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1 = 0"
					Mess_Aide = Mess_Aide & CRLF & "    --> You can use COM1, COM2, COM3, COM4"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Display server informations (eg:23)"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /Server:23 = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Stop this"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /Server:23 = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display actually screen resolution CONSOLE or GRAPHIC"
					Mess_Aide = Mess_Aide & CRLF & "    SYS/ /SCREEN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Change screen resolution"
					Mess_Aide = Mess_Aide & CRLF & "    You can change in console OR graphic resolution"
					Mess_Aide = Mess_Aide & CRLF & "    CONSOLE: SYS/ /SCREEN Number"
					Mess_Aide = Mess_Aide & CRLF & "     Number:"
					Mess_Aide = Mess_Aide & CRLF & "      - 1  : 320x200 (CGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 2  : 640x200 (CGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 7  : 320x200 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 8  : 640x200 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 9  : 640x350 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 11 : 640x480 (VGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 12 : 640x480 (VGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 13 : 320x200 (MCGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 14 : 320x240 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 15 : 400x300 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 16 : 512x384 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 17 : 640x400 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 18 : 640x480 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 19 : 800x600 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 20 : 1024x768 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 21 : 1280x1024 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "    GRAPHIC:"
					Mess_Aide = Mess_Aide & CRLF & "      Example: SYS/ /SCREEN 800x600"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display compatible list screen resolution"
					Mess_Aide = Mess_Aide & CRLF & "    This command must contain bit resolution number. 16, 24, 32 bits"
					Mess_Aide = Mess_Aide & CRLF & "     Examples :"
					Mess_Aide = Mess_Aide & CRLF & "      Display list screen resolution for 16 bits of colors"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /SCREEN /LIST 16"
					Mess_Aide = Mess_Aide & CRLF & "      For 24 bits"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /SCREEN /LIST 24"
					Mess_Aide = Mess_Aide & CRLF & "      And for 32 bits"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /SCREEN /LIST 32"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Display for Listbox format"
					Mess_Aide = Mess_Aide & CRLF & "       sys/ /screen /listb 32"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Getting video screen pointer"
					Mess_Aide = Mess_Aide & CRLF & "    Sys/ /screen /ptr"
					Mess_Aide = Mess_Aide & CRLF & "   or in hexadecimal"
					Mess_Aide = Mess_Aide & CRLF & "    Sys/ /screen /hexaptr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display Task manager"
					Mess_Aide = Mess_Aide & CRLF & "    sys/ /taskmgr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Using wrapper function (Experimental)"
					Mess_Aide = Mess_Aide & CRLF & "    This is reserved to Cpcdos SDK devlopper"
					Mess_Aide = Mess_Aide & CRLF & "    You must have your FunctionID!"
					Mess_Aide = Mess_Aide & CRLF & "    Examples :"
					Mess_Aide = Mess_Aide & CRLF & "	  For FunctionID '1234' :"
					Mess_Aide = Mess_Aide & CRLF & "      SYS/ /WRP 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Get bitmap ARGB array ptr from handle number"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /bitmap /get /ptrbyhandle 123"
					Mess_Aide = Mess_Aide & CRLF & "   Getting bitmap ID from handle number"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /bitmap /get /idbyhandle 123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Update OS list from OS.LST"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display OS list avaiable"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /list"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display number of OS"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /nb"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Update file format list"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /fileformat-update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Update personalized file format list"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /fileformat-update /yourpath/yourconfig.ini"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Load GUI icon list"
					Mess_Aide = Mess_Aide & CRLF & "    sys/ /fileformat-gui-load" 
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   List variables in memory with visibility level"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /listvar 4"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Charger/recharger les propri�t�s du curseur graphique"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /load-cursor-properties"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Charger/recharger les icones des curseurs graphiques"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /load-cursor-gui"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Create a new process"
					Mess_Aide = Mess_Aide & CRLF & "   This will able to host your threads, code in another"
					Mess_Aide = Mess_Aide & CRLF & "   process that you have created"
					Mess_Aide = Mess_Aide & CRLF & "    sys/ /process NameOfYourProcess"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the new PID number"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Check new kernel update:"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Download new last version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Install downloaded version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-install"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Download AND install the la avaiable version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get-install"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Download releases notes :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update-news"
					Mess_Aide = Mess_Aide & CRLF & "  Display line per line ESPACE et ECHAP"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update-news \#pause"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " For use 'Hot-release' version, add 'HR' at the end line."
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update hr"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get hr"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get-install hr"
					Mess_Aide = Mess_Aide & CRLF & "  !! Warning, version in test & developpment,"
					Mess_Aide = Mess_Aide & CRLF & "  !! Vous are responsible of your machine."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Change your cpcdos network ID (You can put 'anonymous'):"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /netid = MyName"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Stopping kernel :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /STOPK"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Shutdown system :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /SHUTDOWN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Restart system :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /RESTART    or   SYS/ /REBOOT"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Put in stand-by mode :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /STANDBY"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : fix/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			IF Instr(UCASE(Param), "/LISTVAR") > 0 Then
				Dim Chaine as String
				
				IF Instr(UCASE(Param), "1") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 1 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 1 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_Donnees) & "."
						
						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				
				IF Instr(UCASE(Param), "2") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 2 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 2 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_Donnees) & "."
					
						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				
				IF Instr(UCASE(Param), "3") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 3 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 3 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_Donnees) & "."
					
						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				
				IF Instr(UCASE(Param), "4") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 4 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 4 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_Donnees) & "."
					
						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				
				IF Instr(UCASE(Param), "5") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 5 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 5 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_Donnees) & "."
					
						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if

			' Charger les proprietes du curseur graphique
			IF Instr(UCASE(Param), "/LOAD-CURSOR-PROPERTIES") > 0 Then	
				CPCDOS_INSTANCE.SCI_INSTANCE.charger_Curseurs_properties()
				exit _scope_CMD, _scope
			END IF

			' Charger les icones du curseur graphique
			IF Instr(UCASE(Param), "/LOAD-CURSOR-GUI") > 0 Then	
				CPCDOS_INSTANCE.SCI_INSTANCE.charger_Curseurs(Auth_OS+1024)
				exit _scope_CMD, _scope
			End if

				IF Instr(UCASE(Param), "/SB16") > 0 Then		
					
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then 
						DEBUG("[CpcdosC+] SB16 deactivated", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						 CPCDOS_INSTANCE._dsp_reset()
						' temp asm function directly here
					

						' Lire le contenu depuis CPinti core
						' Dim Buffer_CCP as integer = CPCDOS_INSTANCE.dsp_reset()
					end if
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then DEBUG("[CpcdosC+] SB16 activated", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
						
					
					
					exit _scope_CMD, _scope
				End if			

			IF Instr(UCASE(Param), "/DEBUG") > 0 Then			
				Dim aDBG_DEBUG 				as Integer
				Dim aDBG_DEBUG_SRVTCP 		as Integer
				
				IF Instr(UCASE(Param), "/SERVER") > 0 OR Instr(UCASE(Param), "/SERVEUR") > 0 Then
					aDBG_DEBUG_SRVTCP = -1
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then aDBG_DEBUG_SRVTCP = 1
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then aDBG_DEBUG_SRVTCP = 0
					' ** Idee : Donner possibilite de preciser le No de port ***
					IF Instr(UCASE(Param), ":TCP") > 0 Then
						' Affichage des activites du serveur TCP
						IF aDBG_DEBUG_SRVTCP = -1 Then
							DEBUG(STR(CPCDOS_INSTANCE.RESEAU_INSTANCE.DBG_DEBUG_SRVTCP(1)), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							For Boucle_tcp_serveur as integer = 1 to 63
								CPCDOS_INSTANCE.RESEAU_INSTANCE.DBG_DEBUG_SRVTCP(Boucle_tcp_serveur) = aDBG_DEBUG_SRVTCP
							Next Boucle_tcp_serveur
						End if
						exit _scope_CMD, _scope
					ELSEIF Instr(UCASE(Param), ":FTP") > 0 Then
						' Affichage des activites du serveur FTP
						DEBUG("Serveur FTP non disponible sur cette version / FTP Server not avaiable on this version", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					ELSEIF Instr(UCASE(Param), ":HTTP") > 0 Then
						' Affichage des activites du serveur FTP
						DEBUG("Serveur HTTP non disponible sur cette version / HTTP Server not avaiable on this version", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					END IF
					Message_erreur = ERRAVT("ERR_007", 0)
						DEBUG("CpcdosC+ : Error ERR_007" & Message_erreur & ". Protocol name is missing.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
				


'---------------------------------------------- Test_ecran_console --------------------------------------
				IF Instr(UCASE(Param), "/COM") > 0 Then
					Dim NomPort 	as String
					Dim IndexCom 	as Long
					
					
					' Initialiser la config des ports en memoire
					IF Instr(UCASE(Param), "/INIT") > 0 Then 
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[SERIE/RS232] Initialization COM port configuration... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
						
						' Incrire en memoire la configuration
						For Boucle as integer = 1 to 4
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_Connecte 		= FALSE
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM 					= "COM" & Boucle
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_baud		 		= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BAUD[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_parity			= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.PARITY[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_bit_data	 		= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_DATA[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_bit_stop	 		= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_STOP[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_KeyID		 	= 0
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_IRQ				= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.IRQ[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_IO				= CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.IO[" & Boucle & "]", 5, _CLE_)
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_TAG				= Ucase(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.TAG[" & Boucle & "]", 5, _CLE_))
						Next Boucle
						
						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						
								DEBUG("[OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						End if
					End if
					
					IF Instr(UCASE(Param), "/COM1") > 0 Then NomPort = "COM1" : IndexCom = 1
					IF Instr(UCASE(Param), "/COM2") > 0 Then NomPort = "COM2" : IndexCom = 2
					IF Instr(UCASE(Param), "/COM3") > 0 Then NomPort = "COM3" : IndexCom = 3
					IF Instr(UCASE(Param), "/COM4") > 0 Then NomPort = "COM4" : IndexCom = 4
					
					
					IF NomPort = "" Then
						' Checker la liste des port COM
						For Boucle as integer = 1 to 8
							if NOT CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_IRQ = "" Then
								Dim Est_Ouvert as String = "closed"
								
								' Si c'est connecte
								if CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_Connecte = TRUE Then Est_Ouvert = "Opened by KeyID " & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_KeyID
								
								' Afficher la liste des ports COM
								DEBUG(Boucle & " : " & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM _
										& " Baud:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_baud _
										& " data:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_bit_data _
										& " stop:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_bit_stop _
										& " parity:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_parity _
										& " IO:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_IO _
										& " IRQ:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_IRQ _
										& " " & Est_Ouvert _
										& " '" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_TAG & "'"_
										, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.Log, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						Next Boucle
						exit _scope_CMD, _scope
					Else
						' Fermer un port com
						IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then
						
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							
									DEBUG("[SERIE/RS232] Closing port '" & NomPort & "' ... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								
							END IF
							
							' Verifier si le port est ouvert
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte 	= TRUE Then
							
								' Si le port est ouvert, alors on reset le tout
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte 		= FALSE
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_baud		 	= 0
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_parity			= ""
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_data	 	= 0
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_stop	 	= 0
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_KeyID		 	= 0
								
								' Et on ferme le port
								Close #IndexCom
								
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										DEBUG("[OK] Port '" & NomPort & "' closed !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									
								END IF
							Else
								' Avertissement, port deja ferme
								Message_erreur = ERRAVT("AVT_075", 0)
								
									DEBUG("[ERROR] : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
							End if
						ElseIF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 OR Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=2") > 0 Then
							' Ouvrir le port avec les parametres par defauts
							
							IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								
										DEBUG("[SERIE/RS232] Opening port '" & NomPort & "' in reading mode... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									
								END IF
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_ecriture = FALSE
							Else
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									DEBUG("[SERIE/RS232] Opening port '" & NomPort & "' in reading and writing mode... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									
								END IF
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_ecriture = TRUE
							End if
							
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte 	= FALSE Then
								Dim Resultat as long
								Dim com_BAUD 		as integer = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BAUD[" & IndexCom & "]", 5, _CLE_))
								Dim com_BIT_DATA 	as integer = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_DATA[" & IndexCom & "]", 5, _CLE_))
								Dim com_BIT_STOP 	as integer = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_STOP[" & IndexCom & "]", 5, _CLE_))
								Dim com_KEYID 		as double = 1 '_CLE_ 1:DEBOGGEUR
								Dim com_TAG			as String = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.TAG[" & IndexCom & "]", 5, _CLE_))
								Dim com_PARITY 		as String = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.PARITY[" & IndexCom & "]", 5, _CLE_))

								' Si le port est ferme alors on reconfigure le tout
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte	= TRUE
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_baud	 	= com_BAUD
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_parity 	= com_PARITY
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_data 	= com_BIT_DATA
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_stop 	= com_BIT_STOP
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_KeyID 		= com_KEYID
								
	
								' Ouverture du port COM
								Resultat = Open Com(NomPort & ":" & com_BAUD & "," & com_PARITY & "," & com_BIT_DATA & "," & com_BIT_STOP, as #IndexCom)
								
								' Ouverture impossible
								if Resultat = 0 Then
									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										DEBUG("[OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										
									END IF
								Else
									Message_erreur = ERRAVT("AVT_076", 0)
										DEBUG("[ERROR] : " & Message_erreur & ". Error number  " & Resultat & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									
									CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte = FALSE
								End if
							Else
								' Avertissment port deja ouvert
								Message_erreur = ERRAVT("AVT_074", 0)
									DEBUG("[ERROR] : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
							End if
						End if
					End if ' COM1, COM2, COM3, COM4
				End if ' /COM

				IF Instr(UCASE(Param), "/MENU") > 0 Then
					Dim aCPinti_MENU as boolean = CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU = TRUE
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU = FALSE
					IF CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = -1 then ' Si on met rien alors on affiche la valeur en cours
						CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU = aCPinti_MENU
						DEBUG(str(CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
				IF Instr(UCASE(Param), "/CPINTICORE") > 0 Then
					Dim aCPinti_DebugMode as integer = CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode
					CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = -1
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=2") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 2' : Screen 0
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 1' : Screen 0
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 0' : Test_ecran_console(1)
					IF CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = -1 then
						CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = aCPinti_DebugMode
						DEBUG(str(CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						if CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 2 then ' Mode CPinti Core sans avoir le debug!
							CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 2
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(0)
						else
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(1)
						end if
					End if
					IF CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 1 Then
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(1)
						
							DEBUG(" --> 'CPinti core' debogger mode enabled", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					Elseif CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 0 then
						' CPCDOS_INSTANCE.NOGUI = FALSE
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(0)
						
							DEBUG(" --> 'CPinti core' debogger mode disable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					End if
					exit _scope_CMD, _scope
				END IF
				
				Dim aDebugMode as integer = CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG()
				CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(-1)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(0)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(1)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=2") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(2)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=3") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(3)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() = -1 then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(aDebugMode)
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				exit _scope_CMD, _scope
			END IF
			
			IF Instr(UCASE(Param), "/BITMAP") > 0 Then
			
				IF Instr(UCASE(Param), "/GC") > 0 OR Instr(UCASE(Param), "/GARBAGECOLLECTOR") > 0 Then
					
					' Rechercher les bitmaps non r�f�rences en memoire
					Dim Resultat as String = CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.GarbageCollector()
					
					IF NOT Resultat = "" Then
						DEBUG("[OK] -> " & Resultat, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				
				ElseIF Instr(UCASE(Param), "/RECHARGER") > 0 OR Instr(UCASE(Param), "/RELOAD") > 0 Then
				
					' Recharger les bitmap depuis les flags "FILE"
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Auto_Reload_FILE() = TRUE Then
						DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("ERROR", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				
				ElseIf Instr(UCASE(Param), "/LIST") > 0 OR Instr(UCASE(Param), "/LISTE") > 0 Then
					
					' Lister les bitmap en memoire (id, handle, nom, offset...)
					DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_Liste(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				ElseIF Instr(UCASE(Param), "/TAILLE") > 0 OR Instr(UCASE(Param), "/SIZE") > 0 Then
				
					' Recuperer la taille total de la memoire BITMAP
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_Taille()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				ElseIF Instr(UCASE(Param), "/OBTENIR") > 0 OR Instr(UCASE(Param), "/GET") > 0 Then
					If Instr(UCASE(Param), "/PTRBYHANDLE") > 0 Then
						Dim NumeroHandle as integer = Val(Mid(Param, instr(Ucase(Param), "/PTRBYHANDLE") + 13))
						DEBUG("0x" & hex(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_ptr_by_Handle(NumeroHandle), 8), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					ElseIf Instr(UCASE(Param), "/IDBYHANDLE") > 0 Then
						Dim NumeroHandle as integer = Val(Mid(Param, instr(Ucase(Param), "/IDBYHANDLE") + 12))
						DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_id_by_Handle(NumeroHandle)), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				Else
					' Autrement, simplement afficher le nombre de bitmap en memoire
					DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_Nombre() & " bitmap(s)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if
			

			

			Dim PosParam1 as integer = 0
			' Changer la police d'ecriture du systeme
			IF Instr(UCASE(Param), "/FONT") > 0 Then

				IF Instr(UCASE(Param), "/WRITE") > 0 Then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Ecrire_ecran_font(0, "Hello i'm Arial font", 8, "arial", 10, 10, 255, 255, 255)
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Ecrire_ecran_font(0, "In italic !", 8, "ariali", 10, 30, 255, 255, 255)
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Ecrire_ecran_font(0, "In comic sans ms BOLD!", 8, "comicbd", 10, 50, 255, 255, 255)
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Ecrire_ecran_font(0, "And in IMPACT Tadaaaa !", 8, "impact", 10, 70, 255, 255, 255)
				End if

				' Convertir les fichiers TTF en PNG		
				IF Instr(UCASE(Param), "/LOAD_TTF") > 0 Then
					if CPCDOS_INSTANCE.SYSTEME_INSTANCE.Convert_TTF_to_PNG() = true Then
						
					else
						
					End if

					
				End if
				
				' Charger les bitmap
				IF Instr(UCASE(Param), "/LOAD_CFG") > 0 Then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.Load_TTF_config()
				End if

				IF Instr(UCASE(Param), "/LOAD_MAP") > 0 Then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.Load_TTF_Map()
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.is_loaded = true
				End if
				
				' Activer la police d'ecriture
				IF Instr(UCASE(Param), "/ENABLE") > 0 Then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.enable = true

					IF Instr(UCASE(Param), "/ALL:") > 0 Then
						Dim police as string = Mid(Param, Instr(UCASE(Param), "/ALL:") + 5)


						' Check if font exist
						for verif as integer = 0 to CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.fonts_number

							if ucase(CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.font_name(verif)) = ucase(police) Then

								' If exist, put this font
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.general_font = ucase(CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.font_name(verif))

							end if
						next verif
					End if
				End if

				' Desactiver la police d'ecriture
				IF Instr(UCASE(Param), "/DISABLE") > 0 Then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.font_manager.enable = false
				End if

				
			END IF


			IF Instr(UCASE(Param), "/MEM") > 0 Then
				' Afficher la memoire RAM
				Dim Memoire_DISPO 			as Integer = -1
				Dim MemAPrendre 			as Integer
				
				MemAPrendre = 0
				' Afficher la memoire utilise
				IF Instr(UCASE(Param), "/MEMU") > 0 Then MemAPrendre = 1
				IF Instr(UCASE(Param), "KB") > 0 OR Instr(UCASE(Param), "KO") > 0 Then 
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024) ' Kilo-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024) ' Kilo-octets
					END IF
				END IF
				IF Instr(UCASE(Param), "MB") > 0 OR Instr(UCASE(Param), "MO") > 0 Then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024^2) ' Mega-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024^2) ' Mega-octets
					END IF
				END IF
				IF Instr(UCASE(Param), "GB") > 0 OR Instr(UCASE(Param), "GO") > 0 Then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024^3) ' Giga-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024^3) ' Mega-octets
					END IF
				END IF
				IF Instr(UCASE(Param), "TB") > 0 OR Instr(UCASE(Param), "TO") > 0 Then ' Non mais t'as trop cru!
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024^4) ' Tera-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024^4) ' Mega-octets
					END IF
				END IF
				IF Memoire_DISPO = -1 then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = _Memoire_actuel ' Octets
					ELSE
						Memoire_DISPO = _Memoire__krnl_occupe ' Octets
					END IF
				END IF

				IF Memoire_DISPO > -1 Then
					IF Memoire_DISPO < 1 Then
						DEBUG("1<", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG(str(Memoire_DISPO), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

				ELSE
					Message_erreur = ERRAVT("ERR_011", 0) ' erreur fatale
					
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". Problem to access in RAM memory, you must restart your machine!!.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				END IF
			END IF
			
			' Executer une FunctionID wrapped
			IF Instr(UCASE(Param), "/WRP") > 0 Then
				Dim FunctionID_INT as integer
				Dim FunctionID_RET as integer
				Dim FunctionID_POS as integer
				Dim FunctionID_STR as string
				
				FunctionID_POS = Instr(UCASE(Param), "/WRP")
				FunctionID_STR = Mid(Param, FunctionID_POS + 5)
				FunctionID_INT = val(FunctionID_STR)
				IF FunctionID_INT < 1 then 
					Message_erreur = ERRAVT("AVT_062", 0) ' Vous devez specifier un numero ID superieur a 0
					
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				else
					' Pas oublier le doevents!
					Dim ARG_1 as String 	= CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").1", 3, _CLE_)
					Dim ARG_2 as Integer 	= val(CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").2", 3, _CLE_))
					
					Dim str_arg3 as string = CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").3", 3, _CLE_)
					Dim str_arg4 as string = CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").4", 3, _CLE_)
					Dim str_arg5 as string = CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").5", 3, _CLE_)
					
					Dim ARG_3 as any ptr 	= cast(ZString ptr, strptr(str_arg3))
					Dim ARG_4 as any ptr 	= cast(ZString ptr, strptr(str_arg4))
					Dim ARG_5 as any ptr 	= cast(ZString ptr, strptr(str_arg5))
					
					FunctionID_RET = Exec_WRAPPER(FunctionID_INT, _CLE_, ARG_1, ARG_2, ARG_3, ARG_4, ARG_5)

					
					IF FunctionID_RET = -1 then
						Message_erreur = ERRAVT("AVT_063", 0) ' FunctionID non disponible
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					END IF
				End if
			end if

			' Executer le gestionnaire de taches 
			IF Instr(UCASE(Param), "/TASKMGR") > 0 Then
			
					DEBUG("[CpcdosC+] Launching task manager.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				
				CpcdosCP_SHELL("/F:display_taskmgr()", _CLE_, 3, Param_1, Param_2) 
			End if
			
'------------------------------- ECRAN --------------------------------
			' Gerer l'ecran
			IF Instr(UCASE(Param), "/ECRAN") > 0 OR Instr(UCASE(Param), "/SCREEN") > 0 Then
				IF Instr(UCASE(Param), "/PTR") > 0 Then 
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_EcranPTR()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				ElseIF Instr(UCASE(Param), "/HEXAPTR") > 0 Then 
					DEBUG("0x" & Hex(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_EcranPTR(), 8), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				END IF
				' Lister les resolutions compatibles
				IF Instr(UCASE(Param), "/LISTE ") > 0 OR Instr(UCASE(Param), "/LIST ") > 0 Then
					IF Instr(UCASE(Param), " 16") > 0 Then DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(16), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					IF Instr(UCASE(Param), " 24") > 0 Then DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(24), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					IF Instr(UCASE(Param), " 32") > 0 Then DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(32), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
				' Lister les resolutions compatibles pour listbox (avec ; comme separateur)
				IF Instr(UCASE(Param), "/LISTB ") > 0 Then
					IF Instr(UCASE(Param), " 16") > 0 Then DEBUG(CPCDOS_INSTANCE.remplacer_Caractere(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(16), " ", ";"), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					IF Instr(UCASE(Param), " 24") > 0 Then DEBUG(CPCDOS_INSTANCE.remplacer_Caractere(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(24), " ", ";"), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					IF Instr(UCASE(Param), " 32") > 0 Then DEBUG(CPCDOS_INSTANCE.remplacer_Caractere(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(32), " ", ";"), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
				
				' Tester une resolution + couleur
				IF Instr(UCASE(Param), "/TEST ") > 0 Then
					Dim PosTestres as integer = Instr(UCASE(Param), "/TEST ")
					Dim CouleurPos as integer = InstrREV(UCASE(Param), "X")
					Dim Couleur as string = MID(Param, CouleurPos + 1)
					Dim Resolution as String = MID(Param, PosTestres + 6, (CouleurPos) - (PosTestres + 6))
					
					' Couleur mal specifie
					IF val(Couleur) > 32 OR val(Couleur) < 16 then 
						Message_erreur = ERRAVT("AVT_058", 0)
						
							DEBUG("[CpcdosC+] " & Message_erreur & ". Example: SYS/ /SCREEN /TEST 1024x768x16. " & CHR(34) & Commande & CHR(34) & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					End if
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.test_Resolution(Resolution, val(Couleur))), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if				
				
				
				
				IF Instr(UCASE(Param), "/SCREEN") > 0 Then Param = MID(Param, Instr(UCASE(Param), "/SCREEN") + 7)

				
				Param = RTRIM(LTRIM(LTRIM(Param), CHR(09)))
				
				' CHANGER ou AFFICHER une resolution
				IF Param = "" Then
					' Afficher la resolution actuelle 
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = FALSE Then
						' En console
						DEBUG(Str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_ResolutionMode()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						' En graphique
						DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_Resolution_XY(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				Else
					' Changer la resolution

					' Mode graphique
					IF Instr(Ucase(Param), "X") > 0 Then
					
						Dim var_SCR_BIT as integer 	= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("SCR_BIT", 4, _CLE_))
					
						CPCDOS_INSTANCE.SCI_INSTANCE.Initialiser_ECRAN(Param, var_SCR_BIT)
					
					' Mode console 
					ElseIF NOT Val(Param) = 0 OR STR(Param) = "0" Then
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_Resolution(Val(Param))
					Else
						' Afficher tout de meme la resolution actuelle 
						DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_Resolution_XY(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					
				End if				
			End if
			
'-------------------------------


			' Afficher ou configurer les parametres de l'OS
			
			IF Instr(UCASE(Param), "/WITHOUTOS") > 0 OR Instr(UCASE(Param), "/SANSOS") > 0 Then
				Dim NumeroOS as integer = CPCDOS_INSTANCE._MAX_NOMBRE_OS
				

					DEBUG("[CpcdosC+] Switching to without OS [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				
				CpcdosCP_SHELL = "SWITCH:OS_ID=#WITHOUT-SANSOS#"
				
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "/OS") > 0 Then
				Dim UtiliseParametre as boolean = false
				
				' Mettre a jout la liste des OS present dans le fichier OS.LST
				IF Instr(UCASE(Param), "/UPDATE") > 0 Then
					CPCDOS_INSTANCE.update_OS_LISTE()
					UtiliseParametre = true
				End if
				
				' Lister les OS presents
				IF Instr(UCASE(Param), "/LIST") > 0 OR Instr(UCASE(Param), " /LISTE") > 0 Then
					DEBUG(CPCDOS_INSTANCE.get_OSPresent(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					UtiliseParametre = true
				End IF
				
				' Compter le nombre d'OS presents
				IF Instr(UCASE(Param), "/NB") > 0 Then
					DEBUG(str(CPCDOS_INSTANCE.get_NombreOSPresent()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					UtiliseParametre = true
				End IF
				
				' Switcher l'OS id
				if UtiliseParametre = False Then
					IF Mid(Param, Instr(Ucase(Param), "/OS") + 4) <> "" Then
						Dim tmpNomOS as String = Ucase(Ltrim(Rtrim(Mid(Param, Instr(Ucase(Param), "/OS") + 4))))
							DEBUG("[CpcdosC+] OS id switch to " & tmpNomOS & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						CpcdosCP_SHELL = "SWITCH:OS_ID=" & tmpNomOS
						UtiliseParametre = true
					End IF 
				End if
				
				if UtiliseParametre = false then
					
					Dim NomOSPresent as String = CPCDOS_INSTANCE.get_OSPresent(CPCDOS_INSTANCE.SCI_INSTANCE.get_OSid())
					
					IF NomOSPresent = "" OR NomOSPresent = "<null>" Then
							DEBUG("Nothing OS loaded", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					Else
						DEBUG(NomOSPresent & " OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.get_OSid(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				End if
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "/STOPK") > 0 Then
				Dim NombreProcessus as uinteger = cpinti.gestionnaire_tache.cpinti_get_nombre_processus()
				Dim NombreThread as uinteger = cpinti.gestionnaire_tache.cpinti_get_nombre_threads()
				
				' CpcdosCP_SHELL("SYS/ /DEBUG = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				CpcdosCP_SHELL("SYS/ /DEBUG /CPINTICORE = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				CpcdosCP_SHELL("SYS/ /ECRAN 0", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				doevents(10000)
				
				
					DEBUG("[CPCDOSC+] Stopping kernel in progress...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				doevents(500000)
				
					DEBUG("[CPCDOSC+] Closing all process (" & NombreProcessus & ") and thread(s) (" & NombreThread & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				For Boucle as uinteger = 0 to NombreProcessus - 1
						DEBUG("[SHELL] Closing " & Boucle & "/" & NombreProcessus, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					CpcdosCP_SHELL("CLOSE/ /PID:" & NombreProcessus - Boucle, _CLE_, 5, Param_1, Param_2)
					
				Next Boucle
				
					DEBUG("[CPCDOSC+] All stopping signal has been sent to all process and thread !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					DEBUG("[CPCDOSC+] Waiting ending closing (2 seconds)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				
				doevents(3000000) ' 3 Secondes d'attente
			End if
			
			IF Instr(UCASE(Param), "/VERSION") > 0 Then
				DEBUG(_VER_NET_BUILD, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			
			IF Instr(UCASE(Param), "/NETID") > 0 Then
				' Modifier le Net ID
				Dim NetID as String = Mid(Param, Instr(UCASE(Param), "/NETID") + len("/NETID "))
				
				if NetID = "" then
					dim NetID_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = NetID_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3) 
					DEBUG("--> CURRENT SERVER NET ID : '" & Final_NetID & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
				
				' 12 Caracteres MAX !
				NetID = Mid(NetID, 1, 12)
				
				' Filtrer pour eviter les erreur HTTP
				NetID = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(NetID, CHR(09)), CR), LF)), CHR(09)))
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "[", "")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "]", "")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, " ", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, ":", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "/", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "\", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "#", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "&", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, ";", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, ",", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "!", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "=", "_")
				
				if NetID = "" then
					dim Net_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = Net_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3) 
					DEBUG("--> CURRENT SERVER NET ID : '" & Final_NetID & "' saved!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
				
				' Redefinir la variable
				CpcdosCP_SHELL("SET/ CPC_SYS.NET.ID = [" & NetID & "]", _CLE_, 5, Param_1, Param_2)
				
				' Ecrire dans le fichier config
				CPCDOS_INSTANCE.Ecrire_fichier_complet("KRNL\CONFIG\ENV_NET\NET_ID.CPC", "CCP/ /SET.LEVEL = 5" & CRLF & "SET/ CPC_SYS.NET.ID = [" & NetID & "]" & CRLF & CRLF, 0)
				
				' On relit tout
				dim Username as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
				dim Final_NetID as string = Username & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3) 
				
				
				' Et on affiche le resultat
				DEBUG("--> NEW SERVER NET ID : '" & Final_NetID & "' saved!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			End if

			' Mettre a jour la liste des extensions de fichiers
			IF Instr(UCASE(Param), "/FILEFORMAT-UPDATE") > 0 Then
				param = Mid(Param, Instr(Param, "/FILEFORMAT-UPDATE") + Len("/FILEFORMAT-UPDATE")+2)
				if len(param) < 5 Then
					' Si pas de parametres on load le fichier par defaut
					CPCDOS_INSTANCE.Load_list_format(Recherche_Fonction_Var("CPC.REP.KRNL", _CLE_) & "\CONFIG\FORMATS.INI")
				else
					CPCDOS_INSTANCE.Load_list_format(param)
				End if
				exit _scope_CMD, _scope
			End if
			
			IF Instr(UCASE(Param), "/FILEFORMAT-GUI-LOAD") > 0 Then
				' Charger les icones
				CPCDOS_INSTANCE.SCI_INSTANCE.FILE_FORMAT_load_icons()

				
				exit _scope_CMD, _scope
			End if
			
			
			' Mettre a jour le noyau
			IF Instr(UCASE(Param), "/UPDATE") > 0 Then
				Dim telecharger_HotRelease as boolean = false
				
				if Instr(UCASE(Param), "HR") > 0 Then telecharger_HotRelease = true
				
				Dim Download_flag 			as boolean = false
				Dim Install_flag 			as boolean = false
				Dim Download_Releases_news 	as boolean = false
				Dim Download_AND_Install 	as boolean = false
				Dim Versions_Identiques 	as boolean = false
				dim Old_RetourVAR 			as String = RetourVAR
				Dim URL_ZIP 				as String = ""
				Dim Texte_ReleaseNote 		as String = ""
				
				if Instr(UCASE(Param), "/UPDATE-NEWS") > 0 Then Download_Releases_news = true : RetourVAR = ""
				if Instr(UCASE(Param), "/UPDATE-GET") > 0 Then Download_flag = true
				if Instr(UCASE(Param), "/UPDATE-INSTALL") > 0 Then Install_flag = true
				if Instr(UCASE(Param), "/UPDATE-GET-INSTALL") > 0 Then Download_AND_Install = true

				DEBUG("[UPDATE] Current LOCAL version  '" & _VER_NET_BUILD & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				
				
				Dim Serveur_depot as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.UPDATE.SERVER", 3, _CLE_)
				Dim TEMP_NET as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_TEMP.NET", 3, _CLE_)
				
				if len(Serveur_depot) < 2 then
					Serveur_depot = "deposit.cpcdos.net"
						DEBUG("[CPCDOSC+] Variable %CPC_SYS.NET.UPDATE.SERVER% level 3 not defined. Using defaut server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				end if
				
				if Download_Releases_news = true then
					' telecharger et afficher la release notes de la derniere version
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 1", _CLE_, 2, 0, RetourVAR)
					if telecharger_HotRelease = true Then
							DEBUG("[UPDATE] Checking last release note of hot-release kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					else
							DEBUG("[UPDATE] Checking last release note of hot-release kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					End if
					
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)
					
					' SUPPRIMER LE FICHIER
					CPCDOS_INSTANCE.Supprimer_Fichier(TEMP_NET & "\" & Serveur_depot & "\update.php", false, 0)
					
					doevents(10000)
					
					dim pseudo_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = pseudo_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3) 
					
					' Chercher une mise a jour disponible
					if telecharger_HotRelease = true Then ' & "&id=" & CPCDOS_INSTANCE.UNIQUE
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=hotnews&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					Else
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=news&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					End if

					doevents(1000000)
					
					
					' Recuperer l'URL du ZIP
					Texte_ReleaseNote = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")
					
					if len(Texte_ReleaseNote) < 100 then
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					end if
					
					RetourVAR = Old_RetourVAR
					DEBUG(Texte_ReleaseNote, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					exit _scope_CMD, _scope
				End if
				
				' Recherche ET / OU telechargement du ZIP. Install_flag uniquement si le ZIP est dans le dossier
				if Install_flag = false OR Download_AND_Install = true then
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 1", _CLE_, 2, 0, RetourVAR)
					
					if telecharger_HotRelease = true Then
							DEBUG("[UPDATE] Checking hot-release kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					else
							DEBUG("[UPDATE] Checking public kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
					End if
					  
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)
					
					' SUPPRIMER LE FICHIER
					CPCDOS_INSTANCE.Supprimer_Fichier(TEMP_NET & "\" & Serveur_depot & "\update.php", false, 0)
					
					doevents(10000)
					
					dim pseudo_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = pseudo_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3) 
					
					' Chercher une mise a jour disponible
					if telecharger_HotRelease = true Then ' & "&id=" & CPCDOS_INSTANCE.UNIQUE
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=hotupdate&older=" & _VER_NET_BUILD & "&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					Else
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=update&older=" & _VER_NET_BUILD & "&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					End if

					doevents(1000000)
					
					' Recuperer l'URL du ZIP
					URL_ZIP = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")
					
					' Filtrer les parasites!
					URL_ZIP = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(URL_ZIP, CHR(09)), CR), LF)), CHR(09)))
					
					if len(URL_ZIP) < 6 then
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					end if
					
					if instr(ucase(URL_ZIP), "HTTP://") > 0 AND instr(URL_ZIP, ".ZIP") Then
						
						Dim NomFichierZIP as String = Ucase(Mid(URL_ZIP, InstrREV(URL_ZIP, "/") + 1))
						
						Dim NouvelleUpdate as String = Mid(NomFichierZIP, 1, InstrREV(NomFichierZIP, ".ZIP") - 1)
						
						DEBUG("[UPDATE] Current SERVER version '" & NouvelleUpdate & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						if Mid(NouvelleUpdate, 1, Instr(NouvelleUpdate, "_") - 1) > Mid(_VER_NET_BUILD, 1, Instr(_VER_NET_BUILD, "_") - 1) Then
								DEBUG("[UPDATE] New update is avaiable!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
							
							if telecharger_HotRelease = true Then
									DEBUG("[UPDATE] Warning, this is a 'hot-release' version, an unfinished test version. You will remain responsible in the event of a problem.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
							End if
							
							Versions_Identiques = false
						elseif Mid(NouvelleUpdate, 1, Instr(NouvelleUpdate, "_") - 1) = Mid(_VER_NET_BUILD, 1, Instr(_VER_NET_BUILD, "_") - 1) Then
							Versions_Identiques = true
								DEBUG("[UPDATE] You have the last kernel version.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						elseif Mid(NouvelleUpdate, 1, Instr(NouvelleUpdate, "_") - 1) < Mid(_VER_NET_BUILD, 1, Instr(_VER_NET_BUILD, "_") - 1) Then
							Versions_Identiques = true
								DEBUG("[UPDATE] You have a more recent version of the kernel than that of the server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						else
								DEBUG("[UPDATE] We could not compare the kernel version with server." & CRLF & "It is possible that this is an unofficial Cpcdos version.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						End if
					else
						
							DEBUG("[UPDATE] Error, unable to check update info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					End if
					
					' Si on veut telecharger ET installer
					if Download_AND_Install = true then 
						Download_flag = true
						Install_flag = true
					end if
					
				End if ' Install_flag  false
				
				' Telecharger l'update ZIP
				if Download_flag = true Then
				
					' Recuperer l'URL du ZIP
					URL_ZIP = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")
					
					' Filtrer les parasites!
					URL_ZIP = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(URL_ZIP, CHR(09)), CR), LF)), CHR(09)))
					
					if len(URL_ZIP) < 6 then
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					end if
					
					if instr(ucase(URL_ZIP), "HTTP://") > 0 AND instr(URL_ZIP, ".ZIP") Then
				
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 1", _CLE_, 2, 0, RetourVAR)
						
						Dim NomFichierZIP as String = Mid(URL_ZIP, InstrREV(URL_ZIP, "/") + 1)
						Dim PathZIP as String = Serveur_depot & "\" & Mid(URL_ZIP, Instr(URL_ZIP, Serveur_depot) + Len(Serveur_depot) + 1)
						Dim DossierZIP as String = Mid(PathZIP, 1, InstrREV(PathZIP, "/") - 1)
						
							DEBUG("[UPDATE] Downloading in progress [" & URL_ZIP & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

						dim var_progression 	as integer = 0
						dim var_size 			as integer = 0
						dim var_speed 			as integer = 0
						dim var_socket 			as integer = 0
						
						' Creer les variables niveau 2
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Progress = 0"	, _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Speed = 0"		, _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Bytes = 0"		, _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Socket = 0"		, _CLE_, 2, 0, RetourVAR)
						
						' Telecharger le ZIP
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ " & URL_ZIP & " /Progression:VAR_Progress /BytesBySec:VAR_Speed /Bytes:VAR_Bytes /socket:VAR_Socket", _CLE_, 2, 0, RetourVAR)

						
						DEBUG("[UPDATE] 'C' --> STOP", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						Dim Touche_inkey as String = ""
						' Attendre 1 ms
						' doevents(1000)

						' Attendre jusqu'a 100%
						while var_progression < 100
							
							Touche_inkey = Inkey
							
							if ucase(Touche_inkey) = "C" Then
								CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("client/ /send:" & var_socket & " #STOP", _CLE_, 2, 0, RetourVAR)
								
								DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
									DEBUG("[UPDATE] Downloading stopped", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
								
								' Attendre 10 ms
								doevents(100000)
								
								exit _scope_CMD, _scope
							End if
							' Recuperer les statistiques
							var_progression 	= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Progress", 2, _CLE_))
							var_size 			= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Bytes", 2, _CLE_))
							var_speed 			= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Speed", 2, _CLE_))
							var_socket 			= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Socket", 2, _CLE_))
							
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)
						
							DEBUG("[UPDATE] " & NomFichierZIP & " --> " & var_progression & "% ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
							if cint(var_speed) < CPCDOS_INSTANCE._KILO_OCTETS Then
								DEBUG("(" & cint(var_speed) & " bytes/sec)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif cint(var_speed) < CPCDOS_INSTANCE._MEGA_OCTETS Then
								DEBUG("(" & cint(var_speed/CPCDOS_INSTANCE._KILO_OCTETS) & " kb/sec)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif cint(var_speed) < CPCDOS_INSTANCE._GIGA_OCTETS Then
								DEBUG("(" & cint(var_speed/CPCDOS_INSTANCE._MEGA_OCTETS) & " mb/sec)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							end if
							
							if cint(var_size) < CPCDOS_INSTANCE._KILO_OCTETS Then
								DEBUG(" - " & cint(var_size) & " bytes downloaded.     ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif cint(var_size) < CPCDOS_INSTANCE._MEGA_OCTETS Then
								DEBUG(" - " & cint(var_size/CPCDOS_INSTANCE._KILO_OCTETS) & " kb downloaded.     ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif	 cint(var_size) < CPCDOS_INSTANCE._GIGA_OCTETS Then
								DEBUG(" - " & cint(var_size/CPCDOS_INSTANCE._MEGA_OCTETS) & " mb downloaded.     ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							end if
							
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)
							
							locate CsrLin, 1
							
							' Attendre 1 sec
							doevents(500000)
						wend
						
						DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						' Tester la taille du fichier
						if CPCDOS_INSTANCE.Taille_Fichier(TEMP_NET & "\" & PathZIP) < 1024 Then
							Dim Contenufichier as String = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & DossierZIP)
							
							
							if Instr(Contenufichier, "301") > 0 OR Instr(Contenufichier, "302") > 0 Then 	
									DEBUG("[UPDATE] 301/302 ERROR : Redirection not supported.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
								
								exit _scope_CMD, _scope
							End if
							
							if Instr(Contenufichier, "400") > 0 Then 			
									DEBUG("[UPDATE] 400 ERROR : Wrong request syntax.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
								
								exit _scope_CMD, _scope
							End if
							
							if Instr(Contenufichier, "401") > 0 OR Instr(Contenufichier, "403") > 0 Then 	
									DEBUG("[UPDATE] 403 ERROR : Access denied !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								
								exit _scope_CMD, _scope
							End if
							
							if Instr(Contenufichier, "404") > 0 Then 	
									DEBUG("[UPDATE] 404 ERROR : File is missing.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

								
								exit _scope_CMD, _scope
							End if
							
							if Instr(Contenufichier, "500") > 0 OR Instr(Contenufichier, "503") > 0 Then 		
									DEBUG("[UPDATE] 500/503 ERROR : Server error.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

								
								exit _scope_CMD, _scope
							End if	
							
								DEBUG("[UPDATE] ERROR : Unable to update " & CRLF & Contenufichier, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							

							exit _scope_CMD, _scope
							
						End if
						
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)
							DEBUG("[UPDATE] Downloading ok !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)
						
						DEBUG("[UPDATE] Package '" & TEMP_NET & "\" & PathZIP & "' [OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					else
						
							DEBUG("[UPDATE] Error, unable to check update info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					End if
					
					
				elseif Install_flag = false AND Versions_Identiques = false then
					' Si la commande n'installe pas et que la recheche dit que la version est differente, proposer la commande pour l'installer
					
						DEBUG("[UPDATE] Please use '/update-get' to download update.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
				
				' Installer le ZIP
				if Install_flag = true Then
				
					' Recuperer l'URL du ZIP
					URL_ZIP = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")
					
					' Filtrer les parasites!
					URL_ZIP = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(URL_ZIP, CHR(09)), CR), LF)), CHR(09)))
					
					if len(URL_ZIP) < 6 then
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
						exit _scope_CMD, _scope
					end if
					
					if instr(ucase(URL_ZIP), "HTTP://") > 0 AND instr(URL_ZIP, ".ZIP") Then

						Dim NomFichierZIP as String = Mid(URL_ZIP, InstrREV(URL_ZIP, "/") + 1)
						Dim PathZIP as String = Serveur_depot & "\" & Mid(URL_ZIP, Instr(URL_ZIP, Serveur_depot) + Len(Serveur_depot) + 1)
						Dim DossierZIP as String = Mid(PathZIP, 1, InstrREV(PathZIP, "/") - 1)

						
						Dim Fichier_Existant as boolean = CPCDOS_INSTANCE.Fichier_Existe(TEMP_NET & "\" & PathZIP)
						
						If Fichier_Existant = true Then 
						
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)
							
								DEBUG("[UPDATE] Extracting package in progress [" & TEMP_NET & "\" & PathZIP & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)
							
							' Attendre 1 sec
							doevents(1000000)
														
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("decompress/ " & TEMP_NET & "\" & PathZIP & " .", _CLE_, 2, 0, RetourVAR)
							
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)
							
								DEBUG("[UPDATE] Installation OK !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						
							
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)
							
							' Remettre le Pseudo ID
							CpcdosCP_SHELL("SYS/ /NETID " & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_), _CLE_, 5, Param_1, Param_2)
							
								DEBUG("[UPDATE] Please to restart your PC", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
						Else
								DEBUG("[UPDATE] Error, ZIP package not found Please re-launch downloading", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
							exit _scope_CMD, _scope
						End if
					End if
				elseif Versions_Identiques = false then
						DEBUG("[UPDATE] Please use /update-install to install update.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					exit _scope_CMD, _scope
				End if
			End if
			
			IF Instr(UCASE(Param), "/SHUTDOWN") > 0 Then
				
					DEBUG("[CPCDOSC+] Asking for shutdown system ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				cpinti.gestionnaire_tache._exit()
				
				CX_APM_MODE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.CX_Shutdown
				CpcdosCP_SHELL("SYS/ /STOPK", _CLE_, 5, Param_1, Param_2)
			ElseIF Instr(UCASE(Param), "/STANDBY") > 0 Then
					DEBUG("[CPCDOSC+] Asking for standby mode the system ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				
				CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.signal_systeme(CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.CX_StandbyMode)
			ElseIF Instr(UCASE(Param), "/REBOOT") > 0 OR Instr(UCASE(Param), "/RESTART") > 0 Then
					DEBUG("[CPCDOSC+] Asking for restarting the system ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
				
				cpinti.gestionnaire_tache._exit()
				
				CX_APM_MODE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.Restart
				CpcdosCP_SHELL("SYS/ /STOPK", _CLE_, 5, Param_1, Param_2)
			END IF
			
'-------------------------------

			' Creer un nouveau processus
			
			IF Instr(UCASE(Param), "/PROCESS") > 0 Then
				Dim NomProcessus as String
				Dim NumeroPID as integer
				
				' Lister la liste des processus & threads
				IF Instr(UCASE(Param), "/LIST") > 0 Then
					IF Instr(UCASE(Param), "/ARRAY") > 0 Then
						Dim NomVariable as String = Mid(Param, Instr(UCASE(Param), "/ARRAY") + 7)
						Dim ListeProcessus as String
						
						IF Instr(UCASE(Param), "/INDEX") > 0 Then
							ListeProcessus = CPCDOS_INSTANCE.get_List_PID(4)
						Else
							ListeProcessus = CPCDOS_INSTANCE.get_List_Processus(4)
						End if

						for index as integer = 0 to CPCDOS_INSTANCE.SYSTEME_INSTANCE._MAX_PROCESSUS
							if instr(ListeProcessus, ";") > 0 Then
								' Recuperer l'item
								dim item as String = Mid(ListeProcessus, 1, Instr(ListeProcessus, ";") - 1)

								' Cuter apres le ;
								ListeProcessus = Mid(ListeProcessus, Instr(ListeProcessus, ";") + 1)

								' Creer le tableau
								CpcdosCP_SHELL("SET/ " & NomVariable & "(" & index & ") = " & item, _CLE_, NIVEAU_CCP, Param_1, Param_2) 
							Else
								dim item as String = ListeProcessus

								CpcdosCP_SHELL("SET/ " & NomVariable & "(" & index & ") = " & item, _CLE_, NIVEAU_CCP, Param_1, Param_2) 

								exit for
							End if

						Next index

					

					elseif Instr(UCASE(Param), "/LISTB") > 0 Then
						' ListBox mode
						if Instr(UCASE(Param), "/ICON") > 0 Then
							' Get icon path
							DEBUG(CPCDOS_INSTANCE.get_List_Processus_icon(4), CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						ElseIF Instr(UCASE(Param), "/NAMEONLY") > 0 Then
							DEBUG(CPCDOS_INSTANCE.get_List_Processus(4), CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG(CPCDOS_INSTANCE.get_List_Processus(6), CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Else
						' Liste en CRLF
						IF Instr(UCASE(Param), "/NAMEONLY") > 0 Then
							DEBUG(CPCDOS_INSTANCE.get_List_Processus(0), CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG(CPCDOS_INSTANCE.get_List_Processus(2), CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					End if

				else

					IF Instr(UCASE(Param), "/PROCESS") > 0 Then
						NomProcessus = Mid(Param, Instr(UCASE(Param), "/PROCESS") + 9)
					End if
					
					' Reformater le nom du processus
					NomProcessus = Mid(CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(NomProcessus, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE), 1, 16)

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[CpcdosC+] Asking creation new process  '" & NomProcessus & "' (KernelID:" & Auth_Kernel & " OSID:" & Auth_OS & " UserID:" & Auth_Utilisateur & ") ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						
					END IF

					' Verifier s'il existe deja
					dim test_existing_pid as integer = CPCDOS_INSTANCE.get_pid_by_name_process(NomProcessus)

					if test_existing_pid > 0 Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] Le processus existe deja (" & test_existing_pid & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						END IF

						NumeroPID = test_existing_pid

					Else
					

					
						Dim INSTANCE_STRUCT_PROCES as _STRUCT_PROCESSUS_Cpcdos_OSx__
						
						' Remplir la structure
						INSTANCE_STRUCT_PROCES.Nom 				= NomProcessus			' Nom du processus
						INSTANCE_STRUCT_PROCES.PROC_ID_PARENT	= Auth_PID				' PID du processus parent (qui l'a cree)
						INSTANCE_STRUCT_PROCES.THREAD_ID_PARENT	= Auth_TID				' TID du thread parent (qui l'a cree)
						INSTANCE_STRUCT_PROCES.OS_ID			= Auth_OS				' ID de l'OS
						INSTANCE_STRUCT_PROCES.USER_ID			= Auth_Utilisateur		' ID de l'user
				
						' Creer le processus
						NumeroPID = CPCDOS_INSTANCE.Creer_processus(INSTANCE_STRUCT_PROCES)

						
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								DEBUG("[CpcdosC+] New process '" & NomProcessus & "' is in execution with 0 threads (KernelID:" & Auth_Kernel & " OSID:" & Auth_OS & " UserID:" & Auth_Utilisateur & " PID:" & NumeroPID & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							
						END IF

					End if
					
					' Retourner le nouveau numero de PID
					DEBUG("" & NumeroPID, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
				End if
			End if

			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** SYS/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour afficher du texte a l'ecran
		' ===============================================================
		CommLang(2) = "colorf/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " colorf/                    Change fonts colors utf-8 or ascii"
			
		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  'ColorFont'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to change font color of LC2, LC3 console and IUG(GUI)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Graphic example :"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ R:255 V:100 B:010"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur Orange"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Colorf/ R:255 V:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Red/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorF/ V:255 R:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Green/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ B:255 R:000 V:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ R:100"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Purple/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ V:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  light blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   ColorF/ B:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  White/#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  EGA Console example (4 bits) 11 by default:"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ 10"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ I'm in blue color"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ 15"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ I in white color"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   0:Black 1:Blue 2:Green 3:Cyan 4:Red 5:Magenta 6:Brun 7:Ligh gray 8:Black gray"
					Mess_Aide = Mess_Aide & CRLF & "   9:Light blue 10:Light green 11:Light cyan 12:Light red 13:Light magenta"
					Mess_Aide = Mess_Aide & CRLF & "   14:Yellow 15:White"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , colorb/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			Dim couleurC_R				as Integer
			Dim couleurC_V				as Integer
			Dim couleurC_B				as Integer
			Dim Test_CouleurEGA as String
			Param = UCASE(Param)
			' On recherche les couleurs
			couleurC_R = instr(UCASE(Param), "R:")
			couleurC_V = instr(UCASE(Param), "V:")
			IF couleurC_V < 1 Then couleurC_V = instr(UCASE(Param), "G:")
			couleurC_B = instr(UCASE(Param), "B:")
			' Et on attribue
			IF couleurC_R > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R = Val(MID(Param, couleurC_R + 2, 3))
			IF couleurC_V > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V = Val(MID(Param, couleurC_V + 2, 3))
			IF couleurC_B > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B = Val(MID(Param, couleurC_B + 2, 3))
			
			' Tester si c'est une couleur EGA
			Test_CouleurEGA = MID(LTRIM(RTRIM(LTRIM(Param)), CHR(09)), 1)
			IF NOT Test_CouleurEGA = "" Then
				CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal = Val(Test_CouleurEGA)
			End if
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Selected graphic color " & CRLF & " - Red " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R & CRLF & " - Green " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V & CRLF & " - Blue " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B & CRLF & " - EGA " & CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF
			' Recuperer les Parametres
			'DEBUG(Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** COULEURC ****	
		
	_end_scope_CMD
		
	_scope_CMD

		' ===============================================================
		'  Commande pour changer la couleur texte du fond
		' ===============================================================
		CommLang(2) = "colorb/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " colorb/                    Change background color"
		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""

					Mess_Aide = Mess_Aide & CRLF & "  'ColorBackground'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to change background console"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ R:255 V:100 B:010"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur Orange"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ R:255 V:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Red/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ V:255 R:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Green/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ B:255 R:000 V:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ R:100"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Purple/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ V:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  light blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ B:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  White/#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  EGA Console example (4 bits) 0 by default:"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ 10"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ I'm in blue color"
					Mess_Aide = Mess_Aide & CRLF & "   colorB/ 4"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ I in red color"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   0:Black 1:Blue 2:Green 3:Cyan 4:Red 5:Magenta 6:Brun 7:Ligh gray 8:Black gray"
					Mess_Aide = Mess_Aide & CRLF & "   9:Light blue 10:Light green 11:Light cyan 12:Light red 13:Light magenta"
					Mess_Aide = Mess_Aide & CRLF & "   14:Yellow 15:White"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , colorf/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'Affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Dim couleurC_R				as Integer
			Dim couleurC_V				as Integer
			Dim couleurC_B				as Integer
			
			Dim Test_CouleurEGA as String
			Param = UCASE(Param)
			' On recherche les couleurs
			couleurC_R = instr(UCASE(Param), "R:")
			couleurC_V = instr(UCASE(Param), "V:")
			IF couleurC_V < 1 Then couleurC_V = instr(UCASE(Param), "G:")
			couleurC_B = instr(UCASE(Param), "B:")
			' Et on attribue
			IF couleurC_R > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurF_R = Val(MID(Param, couleurC_R + 2, 3))
			IF couleurC_V > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurF_V = Val(MID(Param, couleurC_V + 2, 3))
			IF couleurC_B > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurF_B = Val(MID(Param, couleurC_B + 2, 3))
			
			' Tester si c'est une couleur EGA
			Test_CouleurEGA = MID(LTRIM(RTRIM(LTRIM(Param)), CHR(09)), 1)
			IF NOT Test_CouleurEGA = "" Then
				CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_FOND_caractere = Val(Test_CouleurEGA)
			End if
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Selected console background color " & CRLF & " - Red " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R & CRLF & " - Green " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V & CRLF & " - Blue " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				
			END IF
			' Recuperer les Parametres
			'DEBUG(Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** COULEURF/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
	
		' ===============================================================
		'  Commande pour declarer une fonction CpcdosC+
		' ===============================================================
		CommLang(2) = "declare/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " declare/                   Declare CpcdosC+ function with a level"

		END IF

		IF CommLang(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to declare CpcdosC+ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 (public method) :"
					Mess_Aide = Mess_Aide & CRLF & "   declare/ My_Exemple() : level(5)"
					Mess_Aide = Mess_Aide & CRLF & "   Function/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      Return/ Foo!"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Function"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display : Foo!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2(Public for current application only) :"
					Mess_Aide = Mess_Aide & CRLF & "   ccp/ /set.level = 2"
					Mess_Aide = Mess_Aide & CRLF & "   declare/ My_Exemple() : level(2)"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      txt/ I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "      return/ tada!!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "            tada!!"
					Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  Exemple 3 (Declarer from extern)"
					' Mess_Aide = Mess_Aide & CRLF & "   ccp/ /set.level = 2"
					' Mess_Aide = Mess_Aide & CRLF & "   declare/ My_Exemple():MyProgram.cpc"
					' Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					' Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  Exemple 4 (With 2 arguments)"
					' Mess_Aide = Mess_Aide & CRLF & "   ccp/ /set.level = 2"
					' Mess_Aide = Mess_Aide & CRLF & "   Declare/ Addition(Value1, Value2)"
					' Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Addition(Value1, Value2)"
					' Mess_Aide = Mess_Aide & CRLF & "      retourner/ /C(Value1 + Value2)"
					' Mess_Aide = Mess_Aide & CRLF & "   End/ function"
					' Mess_Aide = Mess_Aide & CRLF & "   Txt/ Results /F:Addition(5, 2)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : Results 7"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			
			Dim NIVEAU_CCP_FONCT		as integer = 2 ' Par defaut
			Dim Position_Fonction 		as integer = 1
			Dim Position_1erParenthese 	as integer = Instr(Param, "(")
			Dim Position_2emParenthese	as integer = Instr(Param, ")")

			Dim NomFonction 			as string = Mid(Param, Position_Fonction, (Position_1erParenthese) - Position_Fonction)
			
			Dim Arguments 				as string = Mid(Param, Position_1erParenthese + 1, Position_2emParenthese - (Position_1erParenthese + 1))
			Dim Pos_Virgule_DEBUT 		as integer = 0
			Dim Pos_Virgule_FIN 		as integer = 0

			Dim Boucle as integer 
			For Boucle = 1 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
				
				if len(NomFonction) > 0 Then
					' Si le nom de fonction est deja declare
					if ucase(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle)) = Ucase(NomFonction) Then

						Dim Boucle_ARGS as integer = 0

						' Verifier le nombre d'arguments
						For Boucle_ARGS = 0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
							' Recuperer les positions
							Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
							Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

							' Verifier la presence d'une vigule
							IF Pos_Virgule_FIN = 0 Then
								IF Boucle_ARGS = 0 Then exit for ' Aucun arguments
								exit for
							End if
						Next Boucle_ARGS

						' Si ca correspond au meme nombre d'arguments
						if this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) = Boucle_ARGS Then
							' ALORS C'EST LA MEME FONCTION, MAIS QU'ON REMPLACE !

								DEBUG("[CpcdosC+] Fonction redefinition for " & NomFonction & "() with " & Boucle_ARGS & " arguments.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							
							exit for
						End if
					End if
				End if

				IF this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) = "" Then
					exit for
				End if
			Next Boucle

			' Push le name
			this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) = Ucase(NomFonction)
			
			' On recupere le nombre d'arguments
			Pos_Virgule_DEBUT 	= 0
			Pos_Virgule_FIN 	= 0
			
			For Boucle_ARGS 		as integer = 0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
				' Recuperer les positions
				Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
				Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

				' Verifier la presence d'une vigule
				IF Pos_Virgule_FIN = 0 Then
					IF Boucle_ARGS = 0 Then exit for ' Aucun arguments
					' Ah .. C'est finis mon gros ;)
					this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) = Boucle_ARGS ' Nombre d'arguments
					exit for
				End if
			Next Boucle_ARGS
			
			' Il y a 1 argument
			IF NOT Arguments = "" Then this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) = this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) + 1


			
			' ON recupere le chemin d'acces de la fonction
			this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle) = Gest_variables_LIRE("_EXE_PATH_", 2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)

			' On recherche le niveau de publicite.
			'  REMARQUE: Niveau 2 et 1 ne peuvent etre definit puisse que par defaut
			'				les fonctions sont d�j� au niveau 2 et le 1 le voit.
			IF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(5)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(5)") Then
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 5
			ElseIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(4)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(4)") Then
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 4
			ELSEIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(3)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(3)") Then
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 3
			ELSEIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(2)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(2)") Then ' par defaut
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 2 
			ELSEIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(1)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(1)") Then ' Inutile!
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 3
				Message_erreur = ERRAVT("AVT_064", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & ". Automatic definition to level 3. Function name : " & NomFonction & ".", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				
			End if
			
			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					DEBUG("[CpcdosC+] Registration function '" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) & "()' in memory. " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) & " argument(s). Level : " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) & ". Importation source : '" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle) & "'. [OK]", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				
				DEBUG("(" & Auth_Kernel & ", " & Auth_OS & ", " & Auth_Utilisateur & ", " & Auth_PID & ", " & Auth_TID & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			End if
			
			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** DECLARER/ ****	
		
	_end_scope_CMD
		
	_scope_CMD
		
		' ===============================================================
		'  Commande pour executer une application DOS
		' ===============================================================
		CommLang(2) = "dos/"
		CommLang(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLang(2) = "[F.#).|" : CommLang(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
				CommandesAide = CommandesAide & CRLF & " dos/                       Launch a DOS file/Command"
		END IF
		IF CommLang(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch a DOS command or file."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Simple example:"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ EDIT.COM"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ Echo Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ MonProg.bat"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("SET/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
	
			CpcdosCP_SHELL("/F:Before_DOS()", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			SHELL(Param)
			CpcdosCP_SHELL("/F:After_DOS()", _CLE_, NIVEAU_CCP, Param_1, Param_2)

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** DOS/ ****
		
		
	_end_scope_CMD
		
	_end_scope
	

	' =========================================================
	' ========================= F I N =========================
	' =========================================================
	
	IF LEN(CommandesAide) > 1 then
	REM IF CommandesAide <> "" then
		DEBUG(CommandesAide, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.couleur_normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, "")

		CommandesAide = ""
	else

		IF VerifierLabel = 0 then ' Si ce n'est pas non plus un label
			IF CommTrouve = 0 then
			
				' Verifier si c'est pas un fichier a executer
				dim ProbableFichier as String = _COMMANDE_
				' Obtenir le path courant si le path n'est pas abolue mais relative
				if NOT instr(ProbableFichier, ":") > 0 Then ProbableFichier = CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_ExeEnCours(2) & "\" & ProbableFichier
				

				
				ProbableFichier = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(ProbableFichier, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)

				if CPCDOS_INSTANCE.Fichier_Existe(ProbableFichier) = true then
					' C'est un fichier existant !
					if CPCDOS_INSTANCE.Executer_Fichier(ProbableFichier, _CLE_) = false then
						DEBUG("[CpcdosC+] Unknow file format '" & ProbableFichier & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						CpcdosCP_SHELL = "ERR_009"
					End if
					
				else
					Message_erreur = ERRAVT("ERR_009", 0)
					IF Numero_de_Ligne > 0 Then Message_erreur = "(lgn:" & Numero_de_Ligne & ") " & Message_erreur
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					
					' IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
						' CpcdosCP_SHELL("Msgbox/ " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". /TITLE:ERR_009 : " & Nom_Fichier_DBG & ":" & Numero_de_Ligne & " - CpcdosC+ Shell /ERROR:3", _CLE_, NIVEAU_CCP, Param_1, Param_2)
					' End if
					
					CpcdosCP_SHELL = "ERR_009"
				End if
			End if
		End if
	END IF
	IF testCMD > 10 Then
		Message_erreur = ERRAVT("ERR_010", 0)
		IF Numero_de_Ligne > 0 Then Message_erreur = "(" & Nom_Fichier_DBG & ":" & Numero_de_Ligne & ") " & Message_erreur
		DEBUG("[SHELL CC+] > " & Message_erreur & " " & CHR(34) & _COMMANDE_ & CHR(34) & " -> '" & CHR(testCMD - 10) & "'.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
		
		' IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then 
			' CpcdosCP_SHELL("Msgbox/ " & Message_erreur & " " & CHR(34) & _COMMANDE_ & CHR(34) & " -> '" & CHR(testCMD - 10) & " /TITLE:ERR_010:" & Nom_Fichier_DBG & ":" & Numero_de_Ligne & " - CpcdosC+ Shell /ERROR:3", _CLE_, NIVEAU_CCP, Param_1, Param_2)
		' End if
		
		CpcdosCP_SHELL = "ERR_010"
	End if

	exit function
	' *** E R R O R   I N T E R C E P T I O N ***
	Intercept_Error:
		cpinti.interception.Erreur_Fatale(Err, Erl, cptr(ZString ptr, Ermn), cptr(ZString ptr, Erfn))
	
End Function






